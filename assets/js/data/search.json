[ { "title": "Docker 6 - Copy", "url": "/posts/Docker_6_Copy/", "categories": "Grind, Docker", "tags": "docker, copy", "date": "2023-01-18 00:00:00 +0900", "snippet": "Intro 생각보다 파일을 복사할일이좀 많더라. 문서보니까 잘 정리되어있길래.cp container - host간파일 / 폴더 복사 양방항 가능. 명령어는 docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH 대충 이런식. docker cp py:/FromContainer.txt testdocker cp test py:/ 왼쪽에 src 오른쪽이 dest,container의 경우 이름명시. 이정도. container실행여부는 상관없음. container끼리는 안됨. 경로는 절대경로 또는상대경로일 수 있음.SRC - DEST 동작SRC_PATH가 file일때 DEST_PATH가 없을때 DEST_PATH생성, 파일저장 DEST_PATH가 없고 /로 끝날때 error : 대상 dir이 있어야함. DEST_PATH가 있고 file일때 src파일의 내용으로 덮어씀. DEST_PATH가 있고 dir일때 SRC_PATH의 이름으로dir에 file이 복사됨. SRC_PATH가 dir일때 DEST_PATH가 없을때 DEST_PATH가 dir로 생성 SRC_PATH의 contents가여기로 복사됨. DEST_PATH가 있고 file일때 error : dir을 file로 복사할 수 없음. DEST_PATH가 있고 dir일때 SRC_PATH의 끝이 /.일때src dir이 여기로 복사됨. SRC_PATH의 끝이 /.아닐때src dir의 contents가 여기로 복사됨. Outro 쓰면서 보니까빈번하게 파일 수정이 많으면굳이 cp쓸거없이Bind mounts하면 더 좋을것같음." }, { "title": "Docker 5 - Exec / Attach", "url": "/posts/Docker_5_Exec_Attach/", "categories": "Grind, Docker", "tags": "docker, exec, attach", "date": "2023-01-17 00:00:00 +0900", "snippet": "Intro 지금까지 -i -t를 써서직접 조작하는 일이 많았다.아무래도 테스트 중심이어서 그런가봄. 이때 container에 접속해야되는데attach와 exec가 있다. 둘이 결과는 비슷하지만 좀 다름. 여기에서는 python container로함. docker create -i -t --name py python:latestdocker stsrt py Exec Container에 명령을 실행한다. docker exec [OPTIONS] CONTAINER COMMAND [ARG...] docker exec py ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 06:45 pts/0 00:00:00 python3root 19 0 0 06:45 ? 00:00:00 ps -ef container의 기본 process는 pid 1인데이게 실행되는동안에만 가능함. 일회성임.container를 다시 시작히도다시 실행하지 않음. command는 실행 파일이어야함. docker exec -i -t my_container sh -c &quot;echo a &amp;amp;&amp;amp; echo b&quot; 이건 되는데 docker exec -i -t my_container &quot;echo a &amp;amp;&amp;amp; echo b&quot; 이건 안됨. 명령을 실행한다고 했지만-i -t 가 붙으면서연결되는것같은 효과.Attach container에 연결한다. docker attach [OPTIONS] CONTAINER docker attach py&amp;gt;&amp;gt;&amp;gt; 실행 중인 container에로컬 stdin, stdout, stderr 스트림 연결 container에서 일어나는 일들을host에서 볼 수 있게됨. 이미 실행하고 있는 프로세스에 연결. 연결을 특정하지 않는거보면pid 1 인가싶음.pid 1 은 container에서특별한 process라고 했는데attach된 상태에서 종료하면container도 같이 꺼지기도하고. 아무튼, attach된 상태에서는종료하면 container도 종료된다.이건 원치 않으면 option을 준다 **docker attach --detach-keys &amp;lt;string&amp;gt; &amp;lt;container&amp;gt;** 예를들어 docker attach --detach-keys ctrl-@ 이런식으로.해당 option에 맞춰 종료하면container는 종료되지 않음. 이거 쓰면서 찾았는데이 옵션은 exec에도 가능함. Outro 막상 써보면 비슷해서신경안썼는데 찾아보니 이정도. exec는 명령어 실행 attach는 container에 접속 " }, { "title": "Docker 4 - Container Option", "url": "/posts/Docker_4_Container_Option/", "categories": "Grind, Docker", "tags": "docker, container, option", "date": "2023-01-11 00:00:00 +0900", "snippet": "Container Option container의 실행부터 종료까지명령어만 본다면 간단히 끝났다. create - start 와 run을 보면선택적으로 option을 넣을 수 있었다. 이 때 들어가는 option이 좀 많은데이미 image에 명시된 조건을조정할 때 쓰이는것같다. create - start와 run은결국엔 같은 기능이므로대부분의 option을 공유한다. 자주 쓰는거 위주로 필요할때마다 추가.--name container name 지정 docker create --name tc2 tomcat:latest CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb2f22b9f2fc2 tomcat &quot;catalina.sh run&quot; 3 days ago Exited (143) 40 hours ago tc2 option 없이 생성하면 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5ad53c428d37 centos &quot;/bin/bash&quot; 57 seconds ago Created peaceful_kare 이름이 아무렇게나 만들어지는데이걸 지정할 수 있음. container에 대한 조작은id나 name으로 하기때문에보통 이게 기본적으로 쓰임. -p , --publish network 사용이 필요할 때외부로 공개할 포트를 지정 container가 독립공간이므로쓰는 port가 있더라도net으로 외부에서 접속할 수 없고이 port를 host에 연결해야한다. 포트 포워딩 할때 쓰는것같은데포트 써야할 떄 이거 안써주면 안되는듯? 인자값은 &amp;lt;공개 port&amp;gt;:&amp;lt;image port&amp;gt;. container에서 쓰일 port정보는image에 써있다. 예를들어 tomcat은 &quot;ExposedPorts&quot;: { &quot;8080/tcp&quot;: {} }, publish없이 실행은 할 수 있다. docker --name tc tomcat 이 경우 NetworkSettings에별다른 정보가 없다. 이 상태로 실행해도할수있는게 없다. network를 통해 접속할 수 없다.가 원래 결론이었고 별도로아마 container에서 갖고있는bash에는 될것같음. 반대로 docker --name tc2 -p 9999:8080 tomcat 이 경우 실행해보면 docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScd214ecd1a84 tomcat:latest &quot;catalina.sh run&quot; 19 minutes ago Up 19 minutes 0.0.0.0:9999-&amp;gt;8080/tcp tc2 option없이 했을때랑 다르게PORTS에 조건이 더 생겼다. 또한NetworkSettings에관련 정보들이 들어가 있는데둘 간의 차이를 보면 &amp;lt;tc&amp;gt; &quot;NetworkSettings&quot;: { ... &quot;Ports&quot;: {}, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/e04b1ad8ff29&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;&quot;, &quot;Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;&quot;, &quot;IPPrefixLen&quot;: 0, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;9b025930652cabdf1c38676ce480a6df5b82598f2996429ebf7067db9e0a976f&quot;, &quot;EndpointID&quot;: &quot;&quot;, &quot;Gateway&quot;: &quot;&quot;, &quot;IPAddress&quot;: &quot;&quot;, &quot;IPPrefixLen&quot;: 0, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;&quot;, &quot;DriverOpts&quot;: null } } &amp;lt;tc2&amp;gt; &quot;NetworkSettings&quot;: { ... &quot;Ports&quot;: { &quot;8080/tcp&quot;: [ { &quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;9999&quot; } ] }, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/c6013703193c&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;0167447f944aa96aa3b4843afef94fe5b2c8ca4f1a7757fad4a222dffa17a261&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;9b025930652cabdf1c38676ce480a6df5b82598f2996429ebf7067db9e0a976f&quot;, &quot;EndpointID&quot;: &quot;0167447f944aa96aa3b4843afef94fe5b2c8ca4f1a7757fad4a222dffa17a261&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null } } host를 확인해 보면 windows netstat -an | findstr :9999 TCP 0.0.0.0:9999 0.0.0.0:0 LISTENING TCP [::]:9999 [::]:0 LISTENING TCP [::1]:9999 [::]:0 LISTENING wsl netstat -an | grep :9999tcp6 0 0 :::9999 :::* LISTEN 둘 다 option으로 줬던 port를 쓰기 시작하고 이 때부터network 관련 기능을 쓸 수 있어진다. -t, --tty tty 모드를 사용한다. bash를 사용하려면 써야한다. 먼저 centos를 option없이 해보면 docker run --name test centos:latest docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd7de0fda2455 centos:latest &quot;/bin/bash&quot; 7 seconds ago Exited (0) 7 seconds ago test 실행했던 흔적은 남아있는데아무 반응없이 꺼진다.Exited로 앞서 설명처럼명령어 실행 후 끝난것. docker 문서에서도 tty는pseudo-TTY를 할당한다고 설명하는데tty는 terminal, bash, shell 등이 관련있고이걸 정리할 수 있다면 따로. 아무튼 대충 이해한바로는명령 하나만 보내는게 이 전까지 방법이면terminal을 사용하는 환경으로 바꿔주는듯함. 다시말해 명령전달에서 terminal실행으로. 이 명령어를 써야 bash를 사용한다. docker run -t --name test centos:latest[root@59279bc00159 /]# 다만, 위 상태에서 뭘 더 할수있는건 없음그 이유와 필요한건 다음으로.-i, --interective -t의 경우 bash를 실행하고결과만 보여주고 명령을 전달할수 없었는데container는 기본적으로stdout으로 동작한다.그래서 더이상 할수있는게 없던것. -i 는 stdin을 추가해준다. docker run --name test -i -t centos:latest [root@8e7aedf13e36 /]#[root@8e7aedf13e36 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var docker create --name test -i -t centosdocker start test run의 경우 입력도 가능해짐. create-start의 경우exec, attach등으로container로 접속을 하면 됨.이건 나중에. -d --detach run의 경우 -t -i 를 쓰면시작되면서 container의 bash로바로 연결되는데 이걸 방지함. daemon, background 그런거. docker run --name test -i -t -d centos:latest --rm 위와같이 테스트 등에 쓸 container는유지할필요가 없다. docker run --rm -t -i centos:latest container가 종료되면 자동으로 삭제한다. -e, --env 환경변수를 설정한다. 일단은 db쓸때 사용해봐서db를 예로 들기로 한다. 근데 다른 용도의 사용도 많은듯함. mysql을 기준으로 docker create --name test -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=Sample_db \\-e MYSQL_USER=user -e MYSQL_PASSWORD=passwd mysql:latest option에 -e는 여러개일 수 있음. MYSQL_ROOT_PASSWORD : root계정 pw MYSQL_DATABASE : db 생성. MYSQL_USER : user 계정 MYSQL_PASSWORD : user 계정 pw 이건 여기는 안썼는데MYSQL_ALLOW_EMPTY_PASSWORD :yes/no로 root pw 강제 설정 유무 환경설정 적용확인은 db접속으로. datagripip, port로 접속하는데아무튼 됨 근데 사진찍기 귀찮음. console docker exec -i -t test bash bash-4.4# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 15Server version: 8.0.29 MySQL Community Server - GPL Copyright (c) 2000, 2022, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&amp;gt; show databases;+--------------------+| Database |+--------------------+| Sample_db || information_schema || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) mysql&amp;gt; exitByebash-4.4# mysql -u user -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 16Server version: 8.0.29 MySQL Community Server - GPL Copyright (c) 2000, 2022, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&amp;gt; show databases;+--------------------+| Database |+--------------------+| Sample_db || information_schema |+--------------------+2 rows in set (0.01 sec) mysql&amp;gt; option으로 줬던 계정과sample_db가 있다. inspection을 비교해보면이와 관련해 달라지는 구간이 있는데Config-Env가 그렇다. &amp;lt;mysql image&amp;gt; &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;GOSU_VERSION=1.14&quot;, &quot;MYSQL_MAJOR=8.0&quot;, &quot;MYSQL_VERSION=8.0.29-1.el8&quot;, &quot;MYSQL_SHELL_VERSION=8.0.29-1.el8&quot; ], &amp;lt;test container&amp;gt; &quot;Env&quot;: [ &quot;MYSQL_ROOT_PASSWORD=root&quot;, &quot;MYSQL_DATABASE=Sample_db&quot;, &quot;MYSQL_USER=user&quot;, &quot;MYSQL_PASSWORD=passwd&quot;, &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;GOSU_VERSION=1.14&quot;, &quot;MYSQL_MAJOR=8.0&quot;, &quot;MYSQL_VERSION=8.0.29-1.el8&quot;, &quot;MYSQL_SHELL_VERSION=8.0.29-1.el8&quot; ], 일단은 db를 예시로 들었지만이 옵션은 활용도에 따라 사용할수 있는 범위가 넓어지고image에 따라 쓸 수 있는 env가 다르다.-v, --volume container의 data가 저장될위치를 지정한다. container는 상태가 저장되지 않는다.container가 삭제되면내부에서 쓰던 data도 삭제된다. container의 data는 필요하다면기본적으로 volume으로 관리되는데보통 container랑 생사를 같이함. 이 volume을 조정해 data를container 외부에 저장하면서container에 상관없이data를 영속적으로 보존할 수 있다. 부가적으로 container끼리data를 공유하는 효과도 있다. volume 관련 설정은 Mounts에 있다. docker create --name test -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=Sample_db \\-e MYSQL_USER=user -e MYSQL_PASSWORD=passwd mysql:latest docker inspect test &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;7bf5fb839a6c7e953b3113b94bc8fc3977ffb94ce3c9d18df57331629798a252&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/7bf5fb839a6c7e953b3113b94bc8fc3977ffb94ce3c9d18df57331629798a252/_data&quot;, &quot;Destination&quot;: &quot;/var/lib/mysql&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; }], 아무런 설정없이 만든경우volume은 임의로 만들어져 할당된다. volume은 필요한 경우 생성된다.위는 db라서 생성됐지만os나 언어 container의 경우이부분이 비어있음. 실제로 volume는 Source에 있다고 하는데linux같은 경우가 그렇고 wsl은 \\\\\\wsl$\\docker-desktop-data\\ version-pack-data\\community\\ docker\\volumes\\&amp;lt;volume name&amp;gt;\\\\_data에 있다. Destination은 container내부에data가 쌓이는 위치 같은 기능의 option으로--mount가 있는데 --mount를 더 권장함.더 명시적이고 더 많이 쓸 수 있어서. docker document에서는 크게 3가지 방법을 소개한다.Volume docker에서 생성, 관리하는 data. 이 방법을 더 권장하고 있다. os에 따라 dir등이 달라질 수 있는데이건 docker에서 관리하기때문에신경쓸필요가 적어짐. 등등 그 외에 많은 이점을 설명하고 있음. 아마 기본으로 설정된방법인것같은데 위처럼 아무 조건없이 만들어졌을 떄type을 보면 volume이다. volume은 docker volume ls ls로 확인할 수 있는데보통은 이름이 무작위로 만들어져있고volume에 대한 확인또한 docker volume inspect &amp;lt;volume name&amp;gt; inspect로 가능하다. container에 특정 volume을명시하기 위해서는먼저 volume을 생성해야한다. docker volume create [OPTIONS] [VOLUME] 예를들어 docker volume create test_vol volume를 container에 연결한다. docker create -v test_vol:/var/lib/mysql \\--name test -p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=Sample_db \\-e MYSQL_USER=user -e MYSQL_PASSWORD=passwd mysql:latest -v 부분이고&amp;lt;volume name&amp;gt; : &amp;lt;target&amp;gt; target는 container내부의 경로로 dir이나 file상관없고dir경우 없으면 생성까지 해줌 mysql은 Destination이 명시되어있었고그 위치를 생성한 volume으로 mount한것. Destination이 없더라도 혹은 필요에 따라특정 dir을 쓰면 됨. container의 해당 부분을 확인해보면 &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;test_vol&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/test_vol/_data&quot;, &quot;Destination&quot;: &quot;/var/lib/mysql&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;z&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; }], 실행하면 -e때랑 같다. 이 상태에서 container를 삭제하고-e MYSQL_DATABASE=Sample_db를지운상태로 다시 생성한다. 이 container에는Sample_db가 없어야 하지만이 전 data는 volume에 여전히 있으므로 show databases; 하면 보임. 따라서 이 volume만 지워지지 않는다면container에 상관없이data를 보호할 수 있음.Bind mounts host의 임의의 경로에container를 mount한다. volume도 경로를 따라가면host에서 찾을 수 있었는데docker에서 관리하는 data형식이었다면이 경우는 host의 dir을 직접적으로 사용. option에서 volume 자리에host의 dir을 쓰면 된다. docker create --name test1 -i -t -v ~/test:/test centos:latestdocker create --name test2 -i -t -v ~/test:/test centos:latest 결과는 volume mount랑 같음. inspect경우 type이 달라진다. &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/psy/test&quot;, &quot;Destination&quot;: &quot;/test&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; }], 일단 volume랑 bind랑 비교해보면docker에서 관리해주냐가 다른점. 직접 관리해주는 volume이 더 권장됨.tmpgs mounts 이 방법도 있는데container를 readonly로 만들고그 상태에서 뭔가 쓸 때 사용. 암튼 상황이 어거지긴했음.그래서 굳이 안하기로함.volume share volume은 container끼리data를 공유가 가능하게 한다. 같은 volume를 쓰면 됨. docker create --name test1 -i -t -v test_vol:/test centos:latestdocker create --name test2 -i -t -v test_vol:/test centos:latest Volume, Bind mounts 둘 다 상관없음" }, { "title": "Docker 3 - Container", "url": "/posts/Docker_3_Container/", "categories": "Grind, Docker", "tags": "docker, container", "date": "2023-01-09 00:00:00 +0900", "snippet": "Intro image는 container를 생성하는데 필요한모든 정보를 갖고있었다(inspect). container는 그 정보를 토대로 실행한다. 아무튼 image를 local로 pull한 뒤 부터.Create image에서 container를 생성.실행은 하지 않는다. docker create [OPTIONS] IMAGE [COMMAND] [ARG...] 아무런 option없으면 알아서 만들어줌.정상적으로 만들어지면container id가 나오고 끝. docker create tomcat:latest 8bb7897eacbe81e7e7530dc2381083b8e8cfe253551b9fbd48b2a9c1fb1bfa4a 이 때 만들어진 container는 docker ps -a 로 확인을 할 수 있음. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8bb7897eacbe tomcat:latest &quot;catalina.sh run&quot; 3 seconds ago Created friendly_lumiere 생성에 필요한 부가정보는 option에 선택적으로 넘겨줄 수 있다. 없어도 생성되는 이유는이미 image에 기본 정보가 있어서일듯함.Start create로 생성된 container를 실행한다. docker start [OPTIONS] CONTAINER [CONTAINER...] 위 CONTAINER에는 container을 쓰는데container id나 name을 쓴다. docker start friendly_lumiere friendly_lumiere 또는 docker start 8bb7897eacbe 8bb7897eacbe 정상실행일 경우 container id 또는 name을 상황에 맞게 출력. container create 이후 조작은 create할때 나오는container id 또는 name으로 하게됨.id는 생성할때 나온게 full 실행중인 container는 docker ps 로 확인한다. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8bb7897eacbe tomcat:latest &quot;catalina.sh run&quot; 12 minutes ago Up 3 minutes 8080/tcp friendly_lumiere docker ps는 실행하고 있는 containerdocker ps -a는 전체 containerRestart container 다시시작 docker restart [OPTIONS] CONTAINER [CONTAINER...] docker restart friendly_lumiere friendly_lumiere option으로 -t 또는 –time를 지정해다시 시작 전 대기시간을 설정한다. Stop container 정지. docker stop [OPTIONS] CONTAINER [CONTAINER...] docker stop friendly_lumiere friendly_lumiere option으로 -t 또는 –time를 지정해정지하기전 대기시간을 설정한다. Remove container 삭제 docker rm friendly_lumiere friendly_lumiere 정지되어있는 container만 가능. 여기까지 하면container 생성, 시작, 정지, 삭제.Run create - start를 동시에. docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 예를들어 tomcat을 해보면 docker run tomcat:latest 이 후 알아서 실행함. 확인해보면 docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1bbadf422714 tomcat:latest &quot;catalina.sh run&quot; About a minute ago Up About a minute 8080/tcp gallant_yonath start 결과와 같음. 또한 docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1bbadf422714 tomcat:latest &quot;catalina.sh run&quot; 8 minutes ago Up 8 minutes 8080/tcp gallant_yonath 8bb7897eacbe tomcat:latest &quot;catalina.sh run&quot; 19 hours ago Exited (143) 18 hours ago friendly_lumiere create로 만든 것과 다른 name으로 새로 생성됨. COMMAND docker을 처음에 쓰면서가벼운 vmware정도로 생각하고 썼는데실제로 centos를 실행해보면 바로 종료된다. vmware등의 가상화 프로그램과 차이점인데docker은 os자체를 실행하는게 아니라그 환경을 빌려 application layer에서격리된 환경을 만들고 실행한다. 이 실행하는것이 정확히는 ‘명령어’이다. container가 실행되면주어진 환경에서 명령어를 실행했고그 결과를 보여줬던것.실행한 명령어는 COMMAND에 있다. centos는 “/bin/bash” 였고이 전에 tomcat같은 경우“catalina.sh run”등등.이 중 tomcat은 실행 후 동작하고 있었는데서비스 형태로 동작하는것들이 이런듯하다.db, 웹서버등이 이경우. image에 기본적으로 실행할command가 적혀있는데 변경도 가능함.run을 보면 끝에 arg를 전달할 수 있었는데 docker run centos:latest ps PID TTY TIME CMD 1 ? 00:00:00 ps 이 경우 docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESbe1ea0bdedf3 centos:latest &quot;ps&quot; 52 seconds ago Exited (0) 50 seconds ago wizardly_lamarr COMMAND가 바꿘걸 확인할 수 있다. Outro container의 생성, 시작, 정지, 삭제는명령어만 보면 저게 전부임. 여기에는 image관련 키워드의기능적인면만 보려고 option을 생략함. 다만 container를 상황에 맞게 사용하려면그에 맞는 option이 필요함. option을 잘 못 쓰면 그만큼원하는 동작을 안할가능성이 크다. option관련은 길어서 따로." }, { "title": "Docker 2 - Image", "url": "/posts/Docker_2_Image/", "categories": "Grind, Docker", "tags": "docker, image", "date": "2023-01-02 00:00:00 +0900", "snippet": "Intro 처음 docker을 사용할 때image를 받는것부터 시작한다.dockerfile은 좀 나중에 다시하기로하고. Docker Hub - local까지 범위Image 검색 여러가지로 Docker Hub에서 찾는게 편한데조건이 별다른게 없으면 여기서 찾을 수 있음. docker search [OPTIONS] TERM 이름만 넣고 찾는게 편함. 예를들어 centos를 찾아보면 docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos DEPRECATED; The ... 7427 [OK] kasmweb/centos-7-desktop CentOS 7 desktop ... 26 couchbase/centos7-systemd centos7-systemd ... 6 [OK]dokken/centos-7 CentOS 7 image ... 5 이런식의 결과가 나옴.결과는 더 있는데 생락한것. Image Name은 [publisher]/[name] 이고publisher가 없는 것들은 official image로OFFICIAL OK가 끝에 다시 써있다. AUTOMATED는 자동화 빌드 된것..?Image 다운로드 image는 pull로 받는다. docker pull [OPTIONS] NAME[:TAG|@DIGEST] image는 search할때 나온 이름 넣으면 됨. option은 쓴적없어서 모르겠음. 예를들어 docker pull centos Tag는 default option이 lastest인데만약 image tag에 lastest가 없으면 error. docker pull kasmweb/centos-7-desktop Using default tag: latestError response from daemon: manifest for kasmweb/centos-7-desktop:latest not found: manifest unknown: manifest unknown 이런경우 tag를 명시하면되는데terminal에서 tag를 찾는게 좀 복잡함.아무튼, 위같은 경우는docker pull kasmweb/centos-7-desktop:1.12.0 terminal에서 하더라도docker hub에서 읽어오는거라 그냥 해당 hub페이지 드가서 보는게 편함 Image 확인 로컬에 있는 image 보여줌. docker images docker image ls 둘은 같은 결과임 REPOSITORY TAG IMAGE ID CREATED SIZEnbmis_maria_basic latest cbf594fa4667 5 weeks ago 1.07GBnbims_java latest 34e761e64a32 5 weeks ago 721MBdeb latest b11359bab05c 3 months ago 102MBdebian &amp;lt;none&amp;gt; f8fc33af3a75 3 months ago 100MB 가끔 이렇게 다른 명령어가같은 결과를 보여주는게 있는데버전 올라가면서 새로 생기고 없어지고 함. Image 제거 image 제거 방법 docker rmi [OPTIONS] IMAGE [IMAGE...] 예를들어 docker rmi kasmweb/centos-7-desktop:1.12.0 마찬가지로 Tag까지. Image 정보 확인 Image자체의 정보를 확인하려면 docker inspect [OPTIONS] NAME|ID [NAME|ID...] 해당 image또는 container의 정보가 나온다. image는 container실행에 필요한모든 정보를 갖고있다고 했는데그 정보들을 볼 수 있다. 따라서 image에 따라 써있는내용은큰 맥락빼고는 다 다름. 좀 길기도하고 나중에 또 나올테니 passOutro 쓰고보니 생각보다 별거 없긴한데그만큼 쓰기 편했음." }, { "title": "Docker 1 - Intro", "url": "/posts/Docker_1_Intro/", "categories": "Grind, Docker", "tags": "docker, image, container", "date": "2022-12-16 00:00:00 +0900", "snippet": "Environment wsl2, ubuntu 22.04 가끔 wsl2에서만 나오는 문제가 있는것같길래..Docker Linux의 container기술을 사용해 만든container 기술 이 설명이 좀 이상할 수 있는데vitualization에 좀 더 설명이 있음. 아무튼 원래 linux에는os vitualization을 이용한 기술이 있었고그걸 바탕으로 만들어졌다. 당연히 장/단점은 os vitualization를 따름.설치apt install docker.ioWhy Docker?장점 일단은 가벼움. hw vitualization type2 보다 훨씬. 편의성이 있는데 image만 받아서 바로 실행 가능한 점으로image는 실행 할 때 필요한모든걸 갖고있는상태로 타겟프로그램을 실행하기 위해 필요한여러 부가적인 설치를 생각할 필요가 없다. 격리된 공간의 이점으로 환경 세팅에 부담이 없고테스트환경 세팅이 쉬워진다. 어떤 환경을 세팅할 때익숙한 방식이라니라면 좀 헤메는 경우가 많음게다가 어떤 프로그램은 삭제를 해도 가끔이 전 정보가 남는 경우가 있음oracle db 같은거. container는 os, container에 독립적이었다.뭔짓을해도 외부에 영향을 주지 않는다.삭제 생성이 쉬워서부담없이 호로록 할 수도 있고. vmware에서 snapshot같은기능을image를 이용해 사용할 수 있음. 배포가 쉬워지는데image를 그 자체로 넘기면 바로 실행 가능해지고또는 dockerfile을 이용하면 훨씬 쉬워진다. 그 외 확장이 쉽고 어찌고 하는게 있는데암튼 좋다.단점 os에 종속적임.os와 kernel을 공유하면서 당연한거겠지만.. 원래 linux의 container기술 기반이었음.다만, 윈도우에서 linux를 사용하기가 비교적 편해지면서 이 불편함은 옅어졌는데그래도 linux용 sw만 있는건 또 맞는것같음. 태생적으로 cli가 더 적합해서gui앱은 좀 힘든것같다.근데 서버는 서버고 외부에서는 web이나다른식으로 하는게 보통이지 않음? 용어 주요 용어로는 image, container가 대표적Image container 실행에 필요한resource, 설정값의 모음. container가 실행 될 모든 요소를온전히 갖고있는상태이다. 예를들어 linux, db등image만 받으면 실행이 됨. readonly속성으로image자체는 수정할 수 없다. container에서 변경된 내용을commit해 그 상태를 다시 image로 저장 할 수 있다. 그래서 container의 어떤 시점을저장해 놓은거라고 봐도됨 이 때 새로 저장하는 부분을 layer이라함.Container image가 실행된 상태. application처럼 동작하는실제 상태가 이거. container 생성 및 실행 이후container에서의 변경사항은image에 영향을 주지 않는다. 예를들어 db container의 경우db에 어떤 데이터가 들어가도image는 그 상태를 저장하지 않고container에는 있음. container의 생성, 삭제 또한image나 같은 image로 부터 나온다른 container또한 영향을 주지 않음. 모든 container는 host os와 kernel을 공유한다.다만 위에 설명에 있듯각 container끼리는 영향을 주지 않음. kernel공유, container의 격리 같은 특성은os vitualization에서 기인함.Image - Container Image를 설치한다는 느낌이 아니고 Class instance = new Class();이느낌에 가까움.image container = new image();이렇게. class가 image, instance가 container인데 instance(container)의 변화가class(image)에 영향이 없는건 비슷함. 단, 위 비유와 달리 container의 변경사항을image에 다시 쓸 수도 있는데이부분은 git랑 비슷함.이 전에 썼듯 layer라 하고,이 전 상태에 변경된 부분을 쌓는다는 느낌. 이 둘 스까 생각하면 될듯.Life Cycle 전반적인 주기 docker hub에서 pull 한게 image image에서 create 또는 run을 한게 container Outro 써보니 확실히 편함. 잘쓰면 당연히 훨씬 더 편할것같음. 다만, 생각보다 이것저것 신경써줄게 많음. 또 지금 당장 필요함. 이 뒤로 설명은 위 cycle를 따라가면서필요한 명령어들을 쓸 생각." }, { "title": "Python 18 - Module, Package", "url": "/posts/Python_18_Module_Package/", "categories": "Grind, Python", "tags": "python, module, package", "date": "2022-10-18 00:00:00 +0900", "snippet": "Module 보통 예시들을 보면인터프리터로 실행하는 경우가 많았음.다만, 지금까지 해왔던 방식이 있어서익숙한건 코드를 써서 하는쪽이고.처음엔 좀 신기했던점이입력은 한줄한줄인데이 전 입력을 기억하고있던거? 아무튼 인터프리터로 실행을 했다면당연하게도 종료하면 그 내용은 다 날아감. 그래서 편집기로 내용을 준비해 실행하는것이 좋고이 준비된것을 스크립트라고함. 스크립트라고 하지만 일반적으로 보는 코드형태임.아마 스크립트라고 하는건그 코드형태의 파일 하나하나가독자적으로 실행가능할 수 있기 때문인것같음. 이 스크립트가 길고 복잡해질수록쉽게 관리하고 싶어짐.또는 다른 프로그램에서 썼던function, class등 편리하게 재사용하고싶음. 이런 상황을 지원하기위해어떤 정의들을 파일에 넣고스크립트, 인터프리터에서사용할 수 있도록 만든것이 module. 필요한것 끼리 모아놓은 집합정도.함수, 변수, 클래스등을 모아놓은 파일. 확장자는 .py 지금까지 python을 쓴 방식을봤을 때module은 필요한것 끼리 모아놓은function, class등의 구분없는 집합.일단 내부 구성요소는 attr이라고 하겠음 module은 독자적 namespace를 갖음. import 기본적으로 이 전까지 쓰던 그거임. ## module.pyimport calendarimport datetime print(&quot;module&quot;) modtemp = 1234 def mtd(): print(&quot;mtd&quot;) def prtcal(): calendar.prmonth(datetime.datetime.today().year, datetime.datetime.today().month) class cls(): def __init__(self): pass def clsmtd(self): print(&quot;clsmtd&quot;) ## main.pyimport module as md md.mtd() temp = md.cls()temp.clsmtd() md.prtcal() import할 때 as 붙여서 이름 바꿔쓸 수 있음. module에서 다른 module을 import할 수 있음.이 때 import module 이름이module 최상위 수준(함수 또는 클래스 외부)에 있는 경우module 전역 네임스페이스에 추가됨. from module import prtcal 이런식으로 하면module import를 선택적으로 할 수 있음.당연히 이 경우 import된것만 쓸 수 있음.반대로는 import module 또는from module import *Module Execution 위 경우 module.py를 실행하면아무 반응도 없음. module을 단독으로 실행할 수 있는데module 끝에 다음을 추가한다. if __name__ == &quot;__main__&quot;: passelse: pass if가 직접 실행부분.else는 선택적. 위 예시에서 # module.py import calendarimport datetime print(&quot;module&quot;) modtemp = 1234 def mtd(): print(&quot;mtd&quot;) def prtcal(): calendar.prmonth(datetime.datetime.today().year, datetime.datetime.today().month) class cls(): def __init__(self): pass def clsmtd(self): print(&quot;clsmtd&quot;) if __name__ == &quot;__main__&quot;: mtd() 이런식. main.py는 그대로. 사용자 인터페이스를 제공하거나테스트용이라는데random이나 calendar 보면 얼추 그래보임. 생각해보면 .py로 된 파일은 뭐든 main이 될 수 있었다.main()같이 진입점이 있을때와 다른점인데이 구별이 없어서 저게 필요함.상단에 print(&quot;module&quot;)은외부에서 이 module을 쓰건 직접 실행하건무조건 실행하는데 이런 차이를 두고자 쓰는것같다.Module Path module를 추가할 떄 인터프리터는다음 규칙으로 module을 찾음. 스크립트를 포함하는 디렉터리또는 현재 디렉터리. PYTHONPATH 설치 종속 기본값.site module에서 처리하는site-packages 디렉토리를포함하는 규칙에 따름. 그렇다고 한다.이게 문서에 저렇다고 하고설명이 조금씩 다르길래 자세한건 포기. 아무튼 sys.path가 그 결과인듯함. import sysprint(sys.path) [&#39;c:\\\\Users\\\\psy02\\\\Desktop\\\\python&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\python39.zip&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\DLLs&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\win32&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\Pythonwin&#39;] 같은걸 다른데서 해보면, [&#39;f:\\\\W\\\\Python&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\python39.zip&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\DLLs&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\win32&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\win32\\\\lib&#39;, &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\site-packages\\\\Pythonwin&#39;] 보면 project dir이 항상 위,다음 python lib - 여긴 anaconda로아무튼 PYTHONPATH였을것같고,그 다음 site-packages가 붙은거보니위 설명처럼 3개방식으로 하나봄. 또, sys.path return은 list임.수정이 가능한데추가할 다른 module이 경로가 다르다면 여기 추가하면됨. 아니면 설치된위치-lib에 넣으면 되는듯. 스크립트를 포함하는 디렉터리는 검색 경로의 처음으로,표준 라이브러리 경로의 앞에 온다.만약 두 이름이 같은 경우스크립트를 포함하는 디렉터리의 것이 로드도되록 의도된 규칙인것같다. 근데 sys.path.append()맞나?위 규칙이면 내가 추가할거는sys.path.insert()아닌가?보통 append()로 하는듯?package, module 위치 package나 module관련 정보는inspect로 본다. 기능이 많은것같은데 getfile만 일단. import inspectimport randomimport sys print(inspect.getfile(random.randint))print(inspect.getfile(mod2Mtd))print(inspect.getfile(mod3cls)) module expose 보통의경우from module import attr 은특정 attr을 명시하기때문에조금 다르더라도import module,from module import * 은 같다. module에 __all__이 있으면약간 달라지는데 # module.py import calendarimport datetimeimport random __all__ = [&#39;mtd&#39;, &#39;cls&#39;,&#39;modtemp&#39;] print(&quot;module&quot;) modtemp = 1234 def mtd(): print(&quot;mtd&quot;) def prtcal(): calendar.prmonth(datetime.datetime.today().year, datetime.datetime.today().month) class cls(): def __init__(self): pass def clsmtd(self): print(&quot;clsmtd&quot;) if __name__ == &quot;__main__&quot;: mtd() module에 __all__을 추가하고 from module import *from module import prtcalimport module 이 세 경우를 비교하면 # main.pytry: mtd()except Exception as e: print(e) try: cls().clsmtd()except Exception as e: print(e) try: print(modtemp)except Exception as e: print(e) try: prtcal()except Exception as e: print(e) from module import * module mtd clsmtd 1234 name &#39;prtcal&#39; is not defined from module import prtcal name &#39;mtd&#39; is not defined name &#39;cls&#39; is not defined name &#39;modtemp&#39; is not defined October 2022 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import module이때는 호출이 달라짐. import module try: module.mtd() except Exception as e: print(e) try: module.cls().clsmtd() except Exception as e: print(e) try: print(module.modtemp) except Exception as e: print(e) try: module.prtcal() except Exception as e: print(e) module mtd clsmtd 1234 October 2022 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 __all__은 from module import * 할 때실제로 노출할 attr들을 명시해주는 역할을 한다. __all__이 없으면 전부 노출. import module, from module import prtcal은__all__과는 전혀 상관없어보인다. Package module를 dir구조로 관리. module 들의 집합. module은 기능을 모은 하나의 파일이면package는 module이 모인 폴더쯤. 설명보면 package도 독자적 namespace.따라서 대충 dir + namespace느낌 전체적으로 보면 |- main.py|- module.py|- pak |- mod2.py |- mod3.py 이런 구조같은.사실 module, package들은비슷한 방식의 구조화 방법은흔히 볼 수 있긴함. 기본적으로 # mod2.py __all__ = [&#39;mod2Fnc1&#39;] def mod2Fnc1(): print(&quot;mod2Fnc 1&quot;) def mod2Fnc2(): print(&quot;mod2Fnc 2&quot;) # mod3.py class mod3cls(): def __init__(self): pass def clsmtd(self): print(&quot;mod3cls.clsmtd&quot;) if __name__ == &quot;__main__&quot;: print(&quot;mod3.py is being run directly&quot;)else: print(&quot;mod3.py is being imported into another module&quot;) ## main.pyimport pak.mod3 as m3import pak.mod2 as m2m3.mod3cls().clsmtd()m2.mod2Fnc1() from pak.mod3 import mod3cls as m3clsfrom pak.mod2 import mod2Fnc1 as m2fncm3cls().clsmtd()m2fnc() main에서 mod2, mod3을 불러오는 방법. import로 시작하면 module 이름까지.from으로 시작하면 import에attr또는 module이름까지 명시할 수 있음.package expose package에도 module에서 쓰는__all__을 쓸 수 있는데이 경우 __init__.py를해당 package 의 dir에 만들고그 안에 명시해야한다. 따라서 |- main.py|- module.py|- pak |- __init__.py |- mod2.py |- mod3.py # __init__.py __all__ = [&#39;mod2&#39;] package에서는 from pak import mod3 from pak import mod3 try: mod3.mod3cls().clsmtd() except Exception as e: print(e) mod3.py is being imported into another module mod3cls.clsmtd __all__에 상관 없음. from pak import * from pak import * try: mod3.mod3cls().clsmtd() except Exception as e: print(e) try: mod2.mod2Fnc2() except Exception as e: print(e) name &#39;mod3&#39; is not defined mod2Fnc 2 __all__에 명시된 mod2만 가능 from pak.mod2 import mod2Fnc1 from pak.mod2 import mod2Fnc1 from pak.mod2 import mod2Fnc2 try: mod2Fnc1() mod2Fnc2() except Exception as e: print(e) 명시된 module에서 명시된 attr만 사용가능한데 여기도package의 __all__은 상관없음 또 module의 __all__도 상관없는것같은데 from pak.mod2 import * try: mod2Fnc1() except Exception as e: print(e) try: mod2Fnc2() except Exception as e: print(e) mod2Fnc 1 name &#39;mod2Fnc2&#39; is not defined 이렇게 해야 module의 __all__이 적용됨 import pak.mod2 import pak.mod2 try: pak.mod2.mod2Fnc1() pak.mod2.mod2Fnc2() except Exception as e: print(e) 여기도 __all__은 상관없음 import pak import pak try: print(dir(pak)) except Exception as e: print(e) [&#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;] package에서 쓸 수 있는것만 보이는듯? 아무튼 하위 module은 둘 다 안보임 Sum Up 내용이 생각보다 섞였는데아무튼 다시 위를 정리해보면 module, package를 import할 때from package.module import *로 하는 경우__all__에 명시된 attr만 쓸 수 있다. 다른식의 import는 상관없다. 다르게보면 package, module를 만들 때__all__을 사용해 노출할 attr을 명시할 수 있다. from item import *에서item은 package 또는 module이 가능하고 노출하는 대상은item이 package면 package의 module을,module이면 module의 attr을 대상으로 한다. pip install pypi에 많음. 잘 골라쓰자. pip install beautifulsoup4 이런거. pip list pip show [package] pip install –upgrade [package] pip uninstall [package]내장함수 지금까지 쓰던 것 들 중 import 필요 없는것들. input, dir 등등. Built-in Functions외장함수 지금까지 쓰던 것 들 중 import필요한 것들 glop, os, time, datetime 등등. Python Module Index" }, { "title": "Python 17 - Exception", "url": "/posts/Python_17_Exception/", "categories": "Grind, Python", "tags": "python, excetion, try, except, else, finally, raise, with", "date": "2022-10-13 12:00:00 +0900", "snippet": "exception 뭐든 적당히 하다보면 보이는.. 아무튼 예외처리 주요 키워드는 try, except,else, finally 가 있음 추가로 raise, with까지. 아무튼 기본 형식으로 try: &#39;&#39;&#39; some statement&#39;&#39;&#39; except condition: &#39;&#39;&#39; statement exception &#39;&#39;&#39; except condition`: &#39;&#39;&#39; statement exception &#39;&#39;&#39; except condition``: &#39;&#39;&#39; statement exception &#39;&#39;&#39; else: &#39;&#39;&#39; other exception &#39;&#39;&#39; finally: &#39;&#39;&#39; some statement &#39;&#39;&#39; try try ~ except사이 문장들 실행 exception이 없으면 except를 건너뜀 exception이 있으면 그 블록의뒤 코드는 건너뛰고조건에 따라 except 실행except try에서 exception이 있고,해당 유형이 명명되어 있으면해당 블록 실행 except만 쓰면 exception은 잡아주는데구체적인 상황을 보려면작업이 더 필요함 예를들어, import sys try: &#39;&#39;&#39; some statement&#39;&#39;&#39; print(1) 1/0except : print(sys.exc_info()) &#39;&#39;&#39; statement exception &#39;&#39;&#39; print(2)else: &#39;&#39;&#39; other exception &#39;&#39;&#39; print(3)finally: print(4) 1(&amp;lt;class &#39;ZeroDivisionError&#39;&amp;gt;, ZeroDivisionError(&#39;division by zero&#39;), &amp;lt;traceback object at 0x0000013D4E508CC0&amp;gt;)24 반대로, exception을 지정할 수 있고선택적으로 alias를 줄 수도 있음. ~ except Exception as e: print(e) print(e.with_traceback) &#39;&#39;&#39; statement exception &#39;&#39;&#39; print(2) ~ except만 쓸때랑 차이는 쓰기좀더 편하다는거? exception condition에 따라처음 예시처럼 여러개가 올 수 있는데실행은 하나만 됨또는 조건을 묶어서 튜플로 쓸 수 있음 ~except (FileExistsError, InterruptedError) as e: print(e) print(e.with_traceback)~ 명시된 except에 일치하는 exception이 아니면외부 try로 전달됨.else else는 선택적으로 쓸 수 있는데항상 except뒤에 와야하며try에서 exception이 없는 경우 실행. 아래 case 1, case 2의 출력을 비교해보면 def mtd(num1, num2): res = num1 / num2 return res try: print(mtd(10, &quot;asdf&quot;)) # case 1 # print(mtd(10,1)) # case 2except ZeroDivisionError: print(&quot;Error: Cannot divide by zero&quot;)except TypeError as err: print(&quot;Error: Invalid type : {0}&quot;.format(err.args))except: print(&quot;Error: Unknown error&quot;)else: print(&quot;No error&quot;)finally: print(&quot;Executed&quot;) # case 1Error: Invalid type : (&quot;unsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;&quot;,)Executed # case 210.0No errorExecuted 정상적인 경우 처리를 위해? 또 try에 코드를 추가하는 것보다else 의 사용을 권장하는듯한데, except에 명시하지 않은 예외를우연히 잡게 되는 것을 방지하기 위해서. 라고 하는거 보면 try 안에는exception나올것만 하라는것같음except를 명확하게 하라는 아무튼 그럼. finally try에서 exception에 상관없이 실행되는구간. try에서 발생한 exception이 except에서처리되지 않으면 finally가 실행되고exception다시 발생. try: print(&#39;start try&#39;) 10/&#39;asdf&#39;except ZeroDivisionError: print(&quot;Error&quot;)else: print(&quot;No error&quot;)finally: print(&quot;Executed&quot;) start tryExecutedTraceback (most recent call last): File &quot;F:\\W\\Python\\test.py&quot;, line 31, in &amp;lt;module&amp;gt; 10/&#39;asdf&#39;TypeError: unsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39; except에 명시되지 않은 exception은finally이후 발생. except, else에서 exception이 발생해도finally를 실행하고 다시 exception발생. try: print(&#39;start try&#39;) 10/3except ZeroDivisionError: print(&quot;Error&quot;)else: 10/&#39;a&#39; print(&quot;No error&quot;)finally: print(&quot;Executed&quot;) start tryExecutedTraceback (most recent call last): File &quot;F:\\W\\Python\\test.py&quot;, line 35, in &amp;lt;module&amp;gt; 10/&#39;a&#39;TypeError: unsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39; else에 exception이 있어도finally이후 exception 발생. finally에서 break, continue를 실행하면return exception이 발생하지 않음. try 에서 break, continue , return 을 만나면,finally 는 break, continue ,return 을실행하기 직전에 실행. finally 절에 return 이 포함되면,reutrn값은 try 의 return 값이 아니라,finally 의 return 이 주는 값이 된다. def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;) divide(2, 1)divide(2, 0)divide(&quot;2&quot;, &quot;1&quot;) result is 2.0executing finally clausedivision by zero!executing finally clauseexecuting finally clauseTraceback (most recent call last): File &quot;F:\\W\\Python\\test.py&quot;, line 56, in &amp;lt;module&amp;gt; divide(&quot;2&quot;, &quot;1&quot;) File &quot;F:\\W\\Python\\test.py&quot;, line 42, in divide result = x / yTypeError: unsupported operand type(s) for /: &#39;str&#39; and &#39;str&#39; 아무튼 어떤 경우던간에 finally가항상, 마지막에 실행된다는게 주요내용. try에서 외부 resource를 사용할 때,exception상황에 관계없이resource를 반납하는데 유용함.파일 네트워크 등등.raise 강제로 exception을 발생시킴 raise TypeError Traceback (most recent call last): File &quot;F:\\W\\Python\\test.py&quot;, line 40, in &amp;lt;module&amp;gt; raise TypeErrorTypeError custom exception class형태로 정의해 사용할 수 있음 보통 Error로 끝남. 보통 Exception을 상속. class MyException(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) try : for i in range(10): if i == 5: raise MyException(i) print(i)except MyException as e: print(&quot;MyException:&quot;, e.value) 01234MyException: 5 Exception을 상속하는게 아니면 def f(): print(&#39;in f&#39;) try: raise f()except Exception as e: print(e)else: print(&#39;no err&#39;) print(&#39;after try&#39;) in fexceptions must derive from BaseExceptionafter try 실행은 어찌어찌되는것같은데BaseException을 상속하라함BaseException은 Exception바로 상위라그런듯? with 일부(?) class는 객체가 필요 없을 때스스로 resource를 정리함. 객체사용의 성공여부는 상관없음. finally가 항상 붙어있는형태. 예를들어 f = open(&quot;text.txt&quot;, &quot;r&quot;)print(f.closed)try: firstline = f.readline() print(firstline)except Exception as e: print(e) print(f.closed) print(f.closed)f.close()print(f.closed) False&#39;cp949&#39; codec can&#39;t decode byte 0xed in position 0: illegal multibyte sequenceFalseFalseTrue # text.txt# 한글 text.txt파일에 한글이 써져있어서 Exception인 상황.그래도 f.close하기 전까지 file은 열려있다.이런 경우를 위함. with은 사용 후 resource가정리되도록 보장함. with open(&quot;text.txt&quot;, &quot;r&quot;, encoding=&#39;utf-8&#39;) as f: for line in f: print(line) with블록 이후 어떤 경우에도 파일은 닫힘. 여기저기 대충 요약해보면 with EXPR as VAR: BLOCK 이게 아래와 같음. VAR = EXPRVAR.__enter__()try: BLOCKfinally: VAR.__exit__() 근데 except가 없음.exception은 따로처리해야함. 그래서 with를 사용가능하게class를 만들 수 있는데 예를들어 class CustomClass: def __init__(self, args): self.args = args def __enter__(self): # must return resource return self def use(self): print(self.args) def __exit__(self, type, value, traceback): self.arg = None with CustomClass(&quot;test&quot;) as cc: cc.use() 이거 알아서 잘 써먹으면됨. class까지 귀찮으면 from contextlib import contextmanager @contextmanagerdef use(args): data = args yield data data = None with use(&#39;text&#39;) as u: print(u) ㅇㅇ decorator.위랑 같은 표현임. 이부분은 더 설명이 많음.필요하면 나중에.Exception hierarchyBaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- EncodingWarning +-- ResourceWarning" }, { "title": "Python 16 - Built-In Functions", "url": "/posts/Python_16_Built_In_Functions/", "categories": "Grind, Python", "tags": "python, built-in functions", "date": "2022-10-11 12:00:00 +0900", "snippet": "built-in function docs 내장함수라고도 하고import없이 쓸 수 있는 method들abs(x) 절댓값i = -10j = -13-4jk = -3.14print(abs(i))print(abs(j))print(abs(k))1013.601470508735444 3.14aiter(async_iterable) async iterable에 대한 async iterator return x.__aiter__() 랑 동일.all(iterable) iterable이 비어있거나모든 element가 참일경우 true return. l = [1,2,3] print(all(l)) l = [1,0,3] print(all(l)) l = [1,&#39;&#39;,3] print(all(l)) l = [1,None,3] print(all(l)) l = [] print(all(l)) True False False False True 0, ‘’, None이 걸러짐 any(iterable) iterable에 element가 하나라도 참일경우 true return.비어있는경우 false l = [1,2,3] print(any(l)) l = [1,0,3] print(any(l)) l = [1,&#39;&#39;,3] print(any(l)) l = [1,None,3] print(any(l)) l = [] print(any(l)) True True True True False anext(asunc_iterator[, default]) next의 async 기다리면 지정된 async iterator에서 다음 항목을 reutrn. next가 없는경우 default인데 이 경우는 지정해줘야함.아니면 StopAsyncIteration. async_iterator의 x.__anext__() 와 같음.ascii(object) 해당 문자열이 ascii에 있으면 출력없으면 유니코드로 표현 유니코드는 prefix로 \\u를 붙여서 표현a = ascii(&#39;a가Bㅏ!@#&#39;)print(a)&#39;a\\uac00B\\u314f!@#&#39;bin(x) 정수를 이진 문자열로 번환 prefix로 0b가 붙음 prefix는format()으로 수정할 수 있음a = bin(5)print(a)a = format(5, &#39;#b&#39;) print(a)a = format(5, &#39;b&#39;)print(a)a = f&#39;{5:#b}&#39; print(a)a = f&#39;{5:b}&#39;print(a) 0b1010b1011010b101101bool([x]) True또는 Falsereturna = bool(1&amp;gt;2)print(a)a = bool(1)print(a)a = bool()print(a)a = bool(0)print(a)a = bool(&#39;&#39;)print(a)a = bool(&#39;false&#39;)print(a)FalseTrueFalseFalseFalseTruebreakpoint(*args, **kws) ide에서 볼수 있는 debug모드처럼중단점을 설정할 수 있음 pdb(python debugger)를 호출한다. pdb는 내용이 길어 나중에 따로 정리하기로.bytearray([source[, encoding[, errors]]]) byte배열 생성 가변 시퀀스 bytes의 가변형으로 bytes의 특징과 가변시퀀스형의 특징을 갖고있음 bytearray의 요소에는 정수(int)를 할당한다.문자를 넣고 싶으면 ord를 사용해문자의 ASCII 코드(정수)를 넣는다. bytearray(num)의 num으로 길이만큼 생성하며0으로 초기화되어있음bytes([source[, encoding[, errors]]]) bytearray에서 수정만 안됨 str.encode()를 하거나 str앞에 b를 붙임 s = &#39;asdf&#39; print(s.encode()) by = b&#39;1234&#39; encode기본값은 UTF-8 print(&#39;hell로&#39;.encode(&#39;euc-kr&#39;)) print(&#39;hell로&#39;.encode(&#39;utf-8&#39;)) b&#39;hell\\xb7\\xce&#39; b&#39;hell\\xeb\\xa1\\x9c&#39; decode()는 bytes를 str로. s1 = b&#39;hell\\xb7\\xce&#39;.decode(&#39;euc-kr&#39;) s2 = b&#39;hell\\xeb\\xa1\\x9c&#39;.decode(&#39;utf-8&#39;) print(s1) print(type(s1)) callable(object) object 인자가 콜러블인 것처럼 보이면 True,그렇지 않으면 False. True일 때도 호출이 실패할 가능성이 있지만,False일 때 호출하면 반드시 실패. 클래스는 호출 가능임.(인스턴스 반환) 클래스에 __call__() 메서드가 있으면 인스턴스도 콜러블.chr(i) 유니코드 코드 포인트가 정수인문자를 나타내는 문자열 return. 유효 범위는 0에서 0x10FFFF까지.범위 밖은ValueError 발생. 예를 들어, chr(97) 은 &#39;a&#39; 이고,chr(8364) 는 &#39;€&#39;. ord() 의 반대.classmethod() 메서드를 클래스 메서드로 변환. @classmethod로 쓰나봄. method는 self를 가져야하는것처럼 cls를 쓰는데 자세한건 필요하게되면.compile(source, filename, mode, flags=0, dont_inherit=False, optimize=- 1) 일반 문자열, 바이트열 또는 AST 객체등을 컴파일. exec()또는 eval()로 실행할 수 있음. eval() : 지정 표현식 평가 후, Python 실행 구문이면 실행. exec() : 지정 코드 (또는, 객체)를 실행. codeInString = &#39;a = 8\\nb=7\\nsum=a+b\\nprint(&quot;sum =&quot;,sum)&#39; codeObject = compile(codeInString, &#39;sumstring&#39;, &#39;exec&#39;) exec(codeObject) # Output: 15 complex([real[, imag]]) 복소수 (Complex number)만들어줌complex(num1, num2) num1, 2 는 생략될 수 있는데각 상황마다 알아서 만들어줌 print(complex(2.1, 3.1)) print(complex(2.1)) print(complex()) (2.1+3.1j) (2.1+0j) 0j complex(str) string를 argument로 할 경우단 하나만 전달할 수 있음. real과 img와 부호에는 공백이 있으면 안됨 print(complex(&quot;2.1+3.1j&quot;)) (2.1+3.1j) delattr(object, name) 객체의 해당 attr을 삭제 delattr(x, &#39;foobar&#39;)는 del x.foobar와 같음. 반대로 setattr()이 있음dict() 새 딕셔너리를 생성dir([object]) arg가 없으면 현재 지역 스코프에 있는 이름들의 리스트 arg가 있으면 해당 객체에 유효한 어트리뷰트들의 리스트 해당 클래스에 뭐있나 볼때 쓰던 그거.divmod(a,b) 복소수가 아닌 두 숫자를 arg로몫과 나머지로 구성된 숫자 쌍 반환. 혼합 피연산자 유형의 경우이진 산술 연산자에 대한 규칙이 적용. 정수의 경우 (a // b, a % b)와 같음. 부동 소수점의 경우 (q, a % b). 여기서 q는 일반적으로 math.floor(a / b)이지만 그보다 1 작을 수 있음. 어쨌든 q * b + a % b는 a에 매우 가깝고, a % b가 0이 아니면 b와 동일한 부호를 가지며 0 &amp;lt;= abs(a % b) &amp;lt; abs(b). enumerate(iteratable, start=0) iterable를 넣으면 열거(enumerate)객체 반환 seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] print(list(enumerate(seasons))) [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)] for할때 편한데 seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] for n, item in enumerate(seasons): print(n,item,sep=&quot;:&quot;) for n in range(len(seasons)): print(n, seasons[n],sep=&quot;:&quot;) n = 0 for item in seasons: print(n,item,sep=&quot;:&quot;) n+=1 0:Spring 1:Summer 2:Fall 3:Winter 세 경우 결과는 위와 같은데 enumerate가 훨씬 깔끔해짐 eval(expression[, globals[, locals]]) arg는 문자열 및 선택적 globals, locals이고return 은 표현된 식의 결과 라고 하는데 대충 str값을 넣으면 계산해주고 결과를 뱉는다. 그 대충이 print(eval(&#39;1+2&#39;)) a=10 print(eval(&#39;list(range(a))&#39;)) 3 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] import도 외부에서 먼저 할 수도,eval안에서 할 수도 있음. import calendar print(eval(&quot;calendar.prmonth(2022, 12)&quot;)) print(eval(&quot;__import__(&#39;random&#39;).randint(0,10)&quot;)) December 2022 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 None 4 adv 웹에서 데이터를 받는 경우,json, list인데 str로 받아지는 경우가 있는데 import pprint import requests import json url = &#39;https://api.upbit.com/v1/candles/minutes/1?market=KRW-BTC&amp;amp;count=10&amp;amp;to=2022-09-01T12:24:00Z&#39; response = requests.get(url) print(response.text) 이 경우 response.text는 str이다. [{&quot;market&quot;:&quot;KRW-BTC&quot;,&quot;candle_date_time_utc&quot;:&quot;2022-09-01T12:23:00&quot;,&quot;candle_date_time_kst&quot;:&quot;2022-09-01T21:23:00&quot;,&quot;opening_price&quot;:27456000.00000000,&quot;high_price&quot;:27470000.00000000,&quot;low_price&quot;:27451000.00000000,&quot;trade_price&quot;:27453000.00000000,&quot;timestamp&quot;:1662035038118,&quot;candle_acc_trade_price&quot;:62605542.26424000,&quot;candle_acc_trade_volume&quot;:2.28024306,&quot;unit&quot;:1},{&quot;market&quot;:&quot;KRW-BTC&quot;,&quot;candle_date_time_utc&quot;:&quot;2022-09-01T12:22:00&quot;,&quot;candle_date_time_kst&quot;:&quot;2022-09-01T21:22:00&quot;,&quot;opening_price&quot;:27466000.00000000,&quot;high_price&quot;:27467000.00000000,&quot;low_price&quot;:27456000.00000000,&quot;trade_price&quot;:27457000.00000000,&quot;timestamp&quot;:1662034979703,&quot;candle_acc_trade_price&quot;:93717934.09229000,&quot;candle_acc_trade_volume&quot;:3.41238910,&quot;unit&quot;:1},{&quot;market&quot;:&quot;KRW-BTC&quot;,&quot;candle_date_time_utc&quot;:&quot;2022-09-01T12:21:00&quot;,&quot;candle_date_time_kst&quot;:&quot;2022-09-01T21:21:00&quot;,&quot;opening_price&quot;:27476000.00000000,&quot;high_price&quot;:27478000.00000000,&quot;low_price&quot;:27466000.00000000,&quot;trade_price&quot;:27466000.00000000,&quot;timestamp&quot;:1662034915054,&quot;candle_acc_trade_price&quot;:89887982.31181000,&quot;candle_acc_trade_volume&quot;:3.27204237,&quot;unit&quot;:1},{&quot;market&quot;:&quot;KRW-BTC&quot;,&quot;candle_date_time_utc&quot;:&quot;2022-09-01T12:20:00&quot;,&quot;candle_date_time_kst&quot;:&quot;2022-09-01T21:20:00&quot;,&quot;opening_price&quot;:27505000.00000000,&quot;high_price&quot;:27506000.00000000,&quot;low_price&quot;:27476000.00000000,&quot;trade_price&quot;:27478000.00000000,&quot;timestamp&quot;:1662034859955,&quot;candle_acc_trade_price&quot;:75471936.31508000,&quot;candle_acc_trade_volume&quot;:2.74561004,&quot;unit&quot;:1},{&quot;market&quot;:&quot;KRW-BTC&quot;,&quot;candle_date_time_utc&quot;:&quot;2022-09-01T12:19:00&quot;,&quot;candle_date_time_kst&quot;:&quot;2022-09-01T21:19:00&quot;,&quot;opening_price&quot;:27515000.00000000,&quot;high_price&quot;:27515000.00000000,&quot;low_price&quot;:27500000.00000000,&quot;trade_price&quot;:27500000.00000000,&quot;timestamp&quot;:1662034800050,&quot;candle_acc_trade_price&quot;:293063146.74727000,&quot;candle_acc_trade_volume&quot;:10.65468406,&quot;unit&quot;:1}] 이렇게 정리 안된 문자열로 받음. &quot;[{a:&#39;1&#39;,b:2},{c:&#39;3&#39;,d:4},{e:&#39;5&#39;,f:6}]&quot; 짧게 줄여보면 이런식의 데이터인데 parsing도 애매해짐. 이럴 때 방법으로 json을 이용하면 res = json.loads(response.text) pprint.pprint(res) 이런 방법도 있겠지만 eval을 사용하면 l = eval(response.text) print(l) print(type(l)) 이렇게 하면 str이 list로 나옴. disadv 편해보이긴한데 대부분 설명을 보면쓰지 않는걸 권장하는것같음. 이유는 자유도가 높은게 큼 print(eval(input())) 실행 후 __import__(&quot;os&quot;).listdir(&quot;E:&quot;) 이런식의 맞는 입력만 들어가면 뭐든 할 수 있다는게 문제였음. exec(object[, globals[, locals]]) eval은 식을 실했했다면exec는 문도 가능. eval은 그 줄에 끝나고 return이 있는데 exec는 return이 없고 뒤로 이어질 수 있음 exec(&quot;a=0&quot;) exec(&quot;b=a+10&quot;) exec(&quot;c=b+10&quot;) eval(&quot;print(c)&quot;) 20 이렇게 쓰일 수 있음 뿐만 아니라 문이 된다는 점은오만게 다 들어갈 수 있다는거임. i = 1 j = 2 a = f&#39;&#39;&#39; def mtd(a,b): print(a+b) mtd({i},{j}) &#39;&#39;&#39; exec(a) filter(function, iterable) iterable에서 function에 true인 element를 반환. def fn(a): return a % 2 == 0 l = list(range(0,10)) nl1 = list(filter(fn, l)) nl2 = list(filter(lambda i : i%2==0, l)) nl3 = list(filter(None, l)) print(l) print(nl1) print(nl2) print(nl3) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [0, 2, 4, 6, 8] [0, 2, 4, 6, 8] [1, 2, 3, 4, 5, 6, 7, 8, 9] 첫 arg에는 function을 직접 넣거나보통 lambda를 쓰는게 많이보임 첫번쨰 arg에 None일 경우,false를 거르고 return.아마, bool()에서 걸러지는것들일듯.float([x]) 숫자, 문자를 float으로 만들어줌기본은 0.0 조건이 많은데 귀찮. 알아서 쓰자.format(value[, format_apec]) value를 format_spec에 따르는 형식화된표현으로 변환. s = &quot;some string {0} * {1} = {2}&quot; print(s.format(1,2,1*2)) s = &quot;some string {info} : {mail} / {age}&quot; print(s.format(info=&quot;name&quot;, mail=&quot;gmail&quot;, age=&quot;20&quot;)) some string 1 * 2 = 2 some string name : gmail / 20 frozenset([iterable]) 새 frozenset 객체 생성 선택적으로 iterable 에서 가져온 요소를 포함. 이거 썼을껄?…getattr(object, name[,default]) 객체의 명명된 속성값 반환. import random l = list(range(0,5)) print(l) random.shuffle(l) print(l) getattr(random,&#39;shuffle&#39;)(l) print(l) [0, 1, 2, 3, 4] [1, 0, 3, 4, 2] [1, 3, 2, 0, 4] globals() 현재 모듈 네임스페이스를 구현하는 dic을 반환. 함수 내 코드의 경우 함수가 정의될 때 설정되며함수가 호출되는 위치에 관계없이 동일하게 유지. import pprint g = globals() pprint.pprint(g) {&#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &amp;lt;module &#39;builtins&#39; (built-in)&amp;gt;, &#39;__cached__&#39;: None, &#39;__doc__&#39;: None, &#39;__file__&#39;: &#39;d:\\\\Workspace\\\\ETC\\\\PersonalProject\\\\Python\\\\temp\\\\main.py&#39;, &#39;__loader__&#39;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x0000021543B86CD0&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__package__&#39;: None, &#39;__spec__&#39;: None, &#39;g&#39;: &amp;lt;Recursion on dict with id=2290355238272&amp;gt;, &#39;pprint&#39;: &amp;lt;module &#39;pprint&#39; from &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\pprint.py&#39;&amp;gt;} hasattr(object, name) name(str)이 object 속성 중 하나면 true 아니면 falsehash(object) 객체의 hash값. 정수값임. dic조회 중 키를 빨리 비교하는데 사용 같다고 비교되는 숫자 값은 같은 해시값으로 간주.1과 1.0의 경우와 같이 형이 다른 경우에도.help([object]) 내장 대화형 도움말을 호출. 인자가 제공되지 않으면,인터프리터 콘솔에서 대화형 도움말 시작. 인자가 문자열이면,모듈, 함수, 클래스, 메서드, 키워드, 설명서 주제로 조회. 인자가 다른 종류의 객체면, 객체에 대한 도움말 페이지가 만들짐.hex(x) 정수를 0x접두사가 붙은 16진수 문자열로 변환 접두사 수정 할 수 있음. a = &#39;%#x&#39; % 255 b = &#39;%x&#39; % 255 c = &#39;%X&#39; % 255 print(a, b, c, sep=&#39;,&#39;) a = format(255, &#39;#x&#39;) b = format(255, &#39;x&#39;) c = format(255, &#39;X&#39;) print(a, b, c, sep=&#39;,&#39;) a = f&#39;{255:#x}&#39; b = f&#39;{255:x}&#39; c = f&#39;{255:X}&#39; print(a, b, c, sep=&#39;,&#39;) 0xff,ff,FF 0xff,ff,FF 0xff,ff,FF id(object) object의 id id는 object의 수명동안 유일하고 바뀌지 않음단, 수명이 겹치지 않는다면 중복이 가능함 object의 메모리 주소를 의미함. id 인자로 감사 이벤트를 발생시킴..?input([prompt]) 입력에서 한 줄 읽고 문자열로 변환. prompt가 있으면 개행문자 없이 출력. EOF를 읽으면 EOFError를 발생. readline 과,input() 을 함께 사용하여 정교한 줄 편집과 히스토리 기능을 제공. prompt 인자로 감사 이벤트(auditing event) builtins.input 발생. result 인자로 감사 이벤트(auditing event)builtins.input/result발생.int([x]), int(x, base=10) 숫자, 문자열x를 정수로 만들어줌. arg가 없으면 0 x에 정의된 __int__(), __index__(), __trunc__()를 return. base에 대한 셜명이 길게 있는데 뭐라는지 모르겠음.isinstance(object, classinfo) object가 classinfo의 인스턴스인지 판별. 범위는 classinfo의 직접, 간접, 가상의 하위클래스라고하면 좀 애매한데대충 관련된거면 어지간히 맞는듯함. classinfo가 type object의 여러 type의 Union Type이거나튜플(또는 재귀적으로, 다른 튜플)이면객체가 type중 하나의 인스턴스이어도 True를 반환. classinfo가 type또는 type의 튜플 및그러한 튜플이 아닌 경우 TypeError 예외가 발생import randomclass cls: passc = cls()print(isinstance(c, cls))r = random.Random()print(isinstance(r,random.Random))print(isinstance(c, random.Random))print(isinstance(c, object))TrueTrueFalseTrueissubclass(class, classinfo) isinstancefkd 비슷한데 하위클래스를 판별. 자신의 자신의 하위 classimport randomclass cls: passclass cls2(cls): passprint(issubclass(cls, cls2))print(issubclass(cls2, cls))print(issubclass(cls, cls))FalseTrueTrueiter(object[, sentinel]) 반복자 객체 return. 첫 번째 arg는 두 번째 arg에 따라 다르게 해석됨. 두 번째 arg가 없으면객체는 __iter__() 메서드를 지원하는 컬렉션 객체이거나 __getitem__() 메서드를 지원해야 함.이 둘 중 어느것도 지원하지 않으면 TypeError가 발생. 두 번째 arg인 sentinel이 제공되면 object는 호출 가능한 개체여야 함.이 경우 __next__() 메서드에 대한 각 호출에 대해 인수 없이 객체를 호출.반환된 값이 sentinel과 같으면 StopIteration이 발생, 그렇지 않으면 값이 반환. iterable은 이 전에 collection이랑 비슷한 .. 종류로는 str, list, tuple, dict, set, range() 등등. 첫번째 arg만 있는 경우 i = iter(range(0,5)) print(i.__next__()) print(i.__next__()) print(i.__next__()) print(i.__next__()) print(i.__next__()) print(i.__next__()) 0 1 2 3 4 Traceback (most recent call last): File &quot;f:\\W\\Python\\test.py&quot;, line 9, in &amp;lt;module&amp;gt; print(i.__next__()) StopIteration 두 번째 arg까지 있는 경우 import random i = iter(lambda : random.randint(0,5),2) for item in i: print(item, end=&quot; &quot;) print() while True: i = random.randint(0,5) if i == 2: break print(i,end=&quot; &quot;) 4 1 0 5 5 1 0 5 4 0 5 4 대충 넘겼다가 쓰면서 확실히 달라짐을 느꼈는데 arg가 하나일때는 iterable object가 오고 arg가 두개 일때는 호출가능한 객체와 반복을 멈출 조건으로. len(s) 객체의 길이. 시퀀스 (str, bytes, tuple, list, range 등) 또는컬렉션 (dic, set, frozen set 등)이 가능. sys.maxsize보다 긴 길이에서 OverflowError발생.list([iterable]) 새 list 또는 형변환 가변 sequence형.locals() 현재 지역 심볼 테이블을 나타내는 딕셔너리 자유 변수는 함수 블록에서 호출될 때locals()에 의해 반환되지만클래스 블록에서는 반환되지 않음. 모듈 수준에서 locals()와 globals()는 같음.map(function, iterable) iterable에 function 을 적용한 후iterator을 return. 추가 iterable 인자가 전달되면,function 은 그 수 만큼의 인자를 받아들여야 하고모든 이터러블에서 병렬로 제공되는 항목들에 적용. 다중 이터러블의 경우,이터레이터는 가장 짧은 이터러블이 모두 소모되면 정지. 함수 입력이 이미 인자 튜플로 배치된 경우는,itertools.starmap() 참조. 아무튼, console에서 입력받은 str을int로 바꿀 때 쉬웠음. l = &#39;0 1 2 3 4&#39; nl = list(map(int,l.split())) print(nl) [0, 1, 2, 3, 4] max(iterable, *[, key, default]), max(arg1, arg2, * args[, key]) 가장 큰 값의 항목 여러 항목이라면 가장 처음 항목.memoryview(object) 지정된 arg부터 만들어진 memoryview.min(iterable, *[,key, default]), min(arg1, arg2, *args[, key]) 가장 작은 값의 항목 여러 항목이라면 가장 처음 항목.next() iter에서 __next__()를 썼는데 i = iter(range(0,5)) print(next(i)) print(next(i)) print(next(i)) print(next(i)) print(next(i)) print(next(i)) next()가 __next__()를 호출하는거. object() 새로운 객체를 생성. object는 모든 클래스의 기반. 모든 Python 클래스의 인스턴스에 공통적인 메서드를 가짐. object는 __dict__가 없음.따라서 임의의 attribute를 대입할 수 없음.oct() 정수를 0o로 시작하는 8진수 문자열로 변환.결과는 올바른 파이썬 표현식입니다. format로 접두사 수정할 수 있음.open(file, mode=’r’, buffering=- 1, encoding=None, errors=None, newline=None, closefd=True, opener=None) file을 열고 해당 파일 객체 return. 파일을 열 수 없으면, OSError 가 발생.ord(c) 하나의 유니코드 문자를 나타내는 문자열이 주어지면해당 문자의 유니코드를 나타내는 정수를 return. 예를 들어, ord(&#39;a&#39;) 는 정수 97 이고,ord(&#39;€&#39;) (유로 기호)는 8364 chr() 의 반대.pow(base, exp[,mod]) base 의 exp 거듭제곱 mod 가 있는 경우, base 의 exp 거듭제곱의 모듈.이 계산은 pow(base, exp) % mod 보다 더 빠름 pow(base, exp) 는  base**exp랑 동일.print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False) 텍스트 스트림 파일에 개체를 인쇄. sep로 구분되고 뒤에 end로 끝남. sep, end, file, flush(있는 경우)는키워드 인수로 제공되어야 함.property(fget=None, fset=None, fdel=None, doc=None) 프로퍼티 어트리뷰트 return. class C: def __init__(self): self._x = None def getx(self): print(&quot;getx&quot;) return self._x def setx(self, value): print(&quot;setx&quot;) self._x = value def delx(self): print(&quot;delx&quot;) del self._x x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;) ic = C() ic.x = 1 print(ic.x) del ic.x try : print(ic.x) except Exception as e: print(e) ic.x = 2 print(ic.x) setx getx 1 delx getx &#39;C&#39; object has no attribute &#39;_x&#39; setx getx 2 property에 대해 x로 통일된 접근을 할 수 있음. property에 대한 직접적인 접근을 막고 getter, setter같은 효과를 줄 수 있음. @property를 사용하면 더 편함. class C: def __init__(self): self._x = None @property def x(self): &quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot; return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x @property를 사용해 위와 동일하게 쓴것. @property는 get에 대응되고 나머지는 데코레이터에 따름 range(start, stop[, step]) start, step는 생략될 수 있음stop는 단독으로 올 수 있고 필수임. 불변 시퀀스형.repr(object) 객체의 인쇄 가능한 표현을 포함하는 문자열. 많은 유형의 경우 이 함수는eval()에 전달될 때동일한 값을 가진 객체를 생성하는문자열을 반환.다시말해 eval(repr(object))가 됨 그렇지 않으면 개체의 이름과 주소를 포함하는추가 정보와 함께 개체 유형의 이름을 포함하는꺾쇠 괄호로 묶인 문자열. 클래스는 __**repr__**() 메서드를 정의하여이 함수가 인스턴스에 대해 반환하는 것을 제어할 수 있다.sys.displayhook()에 액세스할 수 없는 경우이 함수는 RuntimeError를 발생. str()이 비공식적으로 … repr()이 공식적으로 …하는 설명이 많은데 귀찮.reversed(seq) reversed iteratorround(number[, ndigits]) 반올림 ndigits가 생략되거나 None면 가장 가까운 정수로. x.y에서 .을 index 0 으로 하고y 방향이 양수 x가 음수이고.에서 멀어질수록 절댓값이 커짐ndigit는 이 전 자이에서 이 자리로 반올림. a = 123.456 print(round(a)) print(round(a,1)) print(round(a,2)) print(round(a,3)) print(round(a,4)) print(round(a,-1)) print(round(a,-2)) 123 123.5 123.46 123.456 123.456 120.0 100.0 float에서 round를 쓸때 정확하지 않은것같음.set([iterable]) set객체 생성 선택적으로 iterable에세 가져온 요소를 갖는다.setattr(object, name, value) getarttr()의 반대. 기존 속성유뮤 상관없이 지정할 수 있음 class C: def init(self): self.x = None c = C() setattr(c,&quot;x&quot;, &quot;str&quot;) print(c.x) setattr(c, &quot;y&quot;, &quot;new attr&quot;) print(c.y) str new attr setattr(x, ‘foobar’, 123)은x.foobar = 123과 동일.slice(start, stop[, step]) start, step는 생략가능 stop는 필수 range(start, stop, step)로 지정된인덱스 집합을 나타내는 슬라이스 객체를 return.sorted(iterable, /, *, key=None, reverse=False) iterable을 새로 정렬한 리스트를 return. l = [&#39;eeeeeeee&#39;,&#39;1&#39;,&#39;1111&#39;, &#39;222222&#39;,&#39;3333&#39;, &#39;a&#39;] print(sorted(l, key=len)) print(sorted(l, key=lambda x:ord(x[0]))) print(l) [&#39;1&#39;, &#39;a&#39;, &#39;1111&#39;, &#39;3333&#39;, &#39;222222&#39;, &#39;eeeeeeee&#39;] [&#39;1&#39;, &#39;1111&#39;, &#39;222222&#39;, &#39;3333&#39;, &#39;a&#39;, &#39;eeeeeeee&#39;] [&#39;eeeeeeee&#39;, &#39;1&#39;, &#39;1111&#39;, &#39;222222&#39;, &#39;3333&#39;, &#39;a&#39;] 원본은 바뀌지 않음같은 기능의 sort()는 원본을 변경. 안정적이 보장되는데 같다고 비교되는 요소의상대적 순서를 변경하지 않으면 안정적임.위 경우에 key=len에서 ‘1’,’a’의 상대적 위치가 변하지 않는것.여전히 ‘1’이 앞 ‘a’가 뒤 정렬 기준은 key단, key 이외는 정렬에 영향을 주지 않음. data = [(1,200),(1,100),(2,300), (2,400)] print(sorted(data, key=lambda data:data[0])) apple, airplane을 a로 정렬했을 떄 a다음 글자로 정렬해주는게 없음. staticmethod() 메서드를 정적 메서드로 변환. @staticmethod로 씀. 정적 메서드를 알아야지..str(object=’’), str(object=b’’, encoding=’utf-8’, errors=’strict’) object의 str버전. repr의 반대인듯. 문자열 str이 아님.sum(iterable, /, start=0) start 및 iterable의 항목들을 왼쪽에서 오른쪽으로 합한 결과 iterable는 일반적으로 숫자이고 시작값은 문자불가.라는데 숫자만 되던데? 아무튼 비슷한거로는 &#39;&#39;.join(sequence) : 문자열 sequence 연결 math.fsum() : 부동소수점 값 합 itertools.chain() : iterable 연결 super([type[, object-or-type]]) 메서드 호출을 부모나 형제 클래스 type에위임하는 프락시 객체 return. 클래스에서 재정의된 상속 된 메서드를 액세스할 때 유용. object-or-type은 검색할 메서드 확인 순서를 결정.검색은 유형 바로 뒤에 있는 클래스에서 시작.tuple([iterable]) 새 tuple return 불변 시퀀스형type(object), type(name, bases, dict, **kwds) 인자 하나의 경우 object의 type를 return. return 값은 type형 객체이며 일반적으로 object.__class__와 같음. 객체 type을 검사할 때 isinstance()가 권장되는데 subclass를 고려하기 때문. 인자 세개의 경우 새 type 객체 생성으로 동적인 형태. name은 클래스 이름이고 __name__()어트리뷰트가 됨. bases튜플은 베이스 클래스들을 포함하고 __bases__()어트리뷰트가 됨. 비어 있으면, object dict는 클래스 바디의 어트리뷰트와 메서드 정의. __dict__()어트리뷰트가 되기 전에 복사되거나 감싸질 수 있음. 다음 두 문장은 같은 동작을 함: class X: a = 1 x = X() print(x.a) y = type(&#39;Y&#39;, (), dict(a=1)) print(getattr(y,&#39;a&#39;)) 1 1 같은 X, Y class 를 일반적인방법과 type를 써서 생성할떄 차이. vars([object]) 객체의 __dict__() 속성을 반환. 모듈, 클래스, 인스턴스 등 __dict__() 속성이 있으면 됨 모듈 및 인스턴스와 같은 객체는업데이트 가능한 __dict__() 어트리뷰트를 갖지만다른 객체는 __dict__() 어트리뷰트에 쓰기 제한을 가질 수 있다.예를 들어, 클래스는 직접적인 딕셔너리 갱신을 방지하기 위해types.MappingProxyType 를 사용. 인수가 없으면 vars()는 locals()처럼 작동.locals dic에 대한 업데이트는 무시되므로locals dic은 읽기에만 유용. object에 __dict__() 속성이 없는 경우 TypeError 예: 해당 클래스가 __slots__() 속성을 정의하는 경우 객체 속성볼때 쓰나봄 import pprint class cls: data1=None data2=2 data3=&#39;data&#39; def __init__(self) -&amp;gt; None: pass def temp(): pass pprint.pprint(cls ) print() pprint.pprint(vars(cls)) print() pprint.pprint(vars()) print() pprint.pprint(locals()) &amp;lt;class &#39;__main__.cls&#39;&amp;gt; mappingproxy({&#39;__dict__&#39;: &amp;lt;attribute &#39;__dict__&#39; of &#39;cls&#39; objects&amp;gt;, &#39;__doc__&#39;: None, &#39;__init__&#39;: &amp;lt;function cls.__init__ at 0x000001E27D9D5AF0&amp;gt;, &#39;__module__&#39;: &#39;__main__&#39;, &#39;__weakref__&#39;: &amp;lt;attribute &#39;__weakref__&#39; of &#39;cls&#39; objects&amp;gt;, &#39;data1&#39;: None, &#39;data2&#39;: 2, &#39;data3&#39;: &#39;data&#39;, &#39;temp&#39;: &amp;lt;function cls.temp at 0x000001E27D9E7280&amp;gt;}) {&#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &amp;lt;module &#39;builtins&#39; (built-in)&amp;gt;, &#39;__cached__&#39;: None, &#39;__doc__&#39;: None, &#39;__file__&#39;: &#39;f:\\\\W\\\\Python\\\\test.py&#39;, &#39;__loader__&#39;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x000001E27D26D3A0&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__package__&#39;: None, &#39;__spec__&#39;: None, &#39;cls&#39;: &amp;lt;class &#39;__main__.cls&#39;&amp;gt;, &#39;pprint&#39;: &amp;lt;module &#39;pprint&#39; from &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\pprint.py&#39;&amp;gt;} {&#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &amp;lt;module &#39;builtins&#39; (built-in)&amp;gt;, &#39;__cached__&#39;: None, &#39;__doc__&#39;: None, &#39;__file__&#39;: &#39;f:\\\\W\\\\Python\\\\test.py&#39;, &#39;__loader__&#39;: &amp;lt;_frozen_importlib_external.SourceFileLoader object at 0x000001E27D26D3A0&amp;gt;, &#39;__name__&#39;: &#39;__main__&#39;, &#39;__package__&#39;: None, &#39;__spec__&#39;: None, &#39;cls&#39;: &amp;lt;class &#39;__main__.cls&#39;&amp;gt;, &#39;pprint&#39;: &amp;lt;module &#39;pprint&#39; from &#39;C:\\\\Users\\\\psy02\\\\anaconda3\\\\lib\\\\pprint.py&#39;&amp;gt;} zip(*iterables, strict=False) 여러 iterable을 병렬로각 item의 튜플 생성 같은 위치 item끼리 tuple로 합치고iterable를 return해줌. z = zip([1, 2, 3], [&#39;sugar&#39;, &#39;spice&#39;, &#39;everything nice&#39;]) print(z.__next__()) (1, &#39;sugar&#39;) transpose, 그러니까 전치 행렬 만들때도 쓰임. l = [[1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]] print(l) la = list(zip(*l)) print(la) [[1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)] 그림으로 보면 [1, 2, 3] (1, &#39;a&#39;) [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] (2, &#39;b&#39;) (3, &#39;c&#39;) 이게 sql로 했을 pivot이었나 그런거 쓰고 복잡했는데 쉽게 끝나는듯. lazy 특성이 있음.LINQ처럼 실제 실행 할 때까지 안함. 전달된 iterable의 길이가 다를경우 가장 짧은 길이에 맞추거나 print(list(zip([0,1,2], [&#39;fee&#39;, &#39;fi&#39;, &#39;fo&#39;, &#39;fum&#39;]))) [(0, &#39;fee&#39;), (1, &#39;fi&#39;), (2, &#39;fo&#39;)] 3.10 이상에서 strict=True옵션으로 ValueError을 일으키거나 iteratools를 사용해 동일한 길이로 맞추거나 import itertools as it print(list(it.zip_longest([0,1,2], [&#39;fee&#39;, &#39;fi&#39;, &#39;fo&#39;, &#39;fum&#39;]))) [(0, &#39;fee&#39;), (1, &#39;fi&#39;), (2, &#39;fo&#39;), (None, &#39;fum&#39;)] import() 일반적으로 필요하지 않은 고급 함수. 이 함수는 import 문에 의해 호출. import 문의 의미를 변경하기 위해 대체함.builtins 모듈을 임포트하고 builtins .__ import__ 에 대입. 그러나 그렇게 하지 말 것을 강하게 권고하는데,같은 기능의 임포트 훅([PEP 302])으로 더 간단하고기본 임포트 구현이 사용될 것이라고 가정하는 코드들과문제를 일으키지 않기 때문. __import__() 의 직접 사용 역시 피하고importlib.import_module() 을 권장함." }, { "title": "Virtualization", "url": "/posts/Stub_Virtualization/", "categories": "Grind, Stub", "tags": "virtualization, docker, hypervisor, wsl", "date": "2022-08-31 12:00:00 +0900", "snippet": "init docker를 하면서 궁금했던것들인데같이 쓰기에 좀 애매해서 뺌 찾은데가 많아서 대충 버무림 근데 찾은데를 안적어놓음… 여기 들어가는 내용들은docker, wsl과 관련있음.Virtualization 컴퓨터에서 컴퓨터 리소스의 추상화를 일컫는 광범위한 용어 “물리적인 컴퓨터 리소스의 특징을 다른 시스템, 응용 프로그램, 최종 사용자들이 리소스와 상호 작용하는 방식으로부터 감추는 기술” 이것은 다중 논리 리소스로서의 기능을 하는 것처럼 보이는서버, 운영 체제, 응용 프로그램, 또는 저장 장치와 같은하나의 단일 물리 리소스를 만들어 낸다.아니면 단일 논리 리소스처럼 보이는 저장 장치나 서버와 같은여러 개의 물리적 리소스를 만들어 낼 수 있다. 크게 하드웨어 가상화, os수준 가상화, 데스크톱 가상화, 응용프로그램 가상화, 네트워크 가상화가 있음 이 중 하드웨어 / os 수준 가상화만 씀.Hardware Virtualization (Hypervisor) Hypervisor는 호스트 컴퓨터에서 다수의 운영 체제를동시에 실행하기 위한 논리적 플랫폼을 말한다. Virtualization는 개념적인거 Hypervisor는 구현체정도? 아무튼, HW Virtualization방식에 따라 Hypervisor가 조금씩 다름 크게 Type 1, Type 2, 전가상화, 반가상화로 분류함Type 1| || OS | OS | OS || |+----------------------------+| || HYPERVISOR || |+----------------------------+| || H / W || | Type1 native, 혹은 bare-metal이라고도 부른다. Hypervisor가 하드웨어에서 직접 실행되는데위의 이름이 붙은 이유임. 게스트 운영 체제는하드웨어 위에서 2번째 수준으로 실행된다. 이 방식으로는 Adeos, CP/CMS, 하이퍼-V, KVM,LDoms / 오라클 VM 서버 포 SPAR,CLynxSecure, SIMMON, VM웨어 ESXi,VM웨어 인프라스트럭처, 젠, XtratuM, z/VM HW가상화 Type1에는 가상화 방식에 따라 전가상화 / 반가상화 두 가지 방식이 있다.전가상화(Full-Virtualization) Hypervisor는 os마다 다른 명령체계를 해석하기위해DOM0라는 가상 머신을 실행하고 이 DOM0가 모든 명령에 개입한다. guest os는 DOM0으로 명령을 전달하고DOM0은 명력 해석 후 Hypervisor로 전달,Hypervisor는 하드웨어에 최종 명령을 전달하는식. 이 방식은 하드웨어의 완전한 가상화로guest os의 수정이 필요없지만DOM0가 할일이 많아져 반가상화에 비해 느림. 위 그림에서 보면 os1이 한국어, os2가 일본어, os3이 중국어를 각각 쓴다고 했을때 Hypervisor는 영어를 쓰는 HW로 모든 언어를 영어로 번역하는 역할반가상화(Para-Virtualization) 전가상화의 DOM0의 역할을 각 guest os에서 직접 처리하는방식. Hyper Call이라는 인터페이스를 이용해Hypervisor와 직접 연결. 이때 guest os에는 Hyper Call에 대한 정보가 없으므로geust os에 구현해야함. 따라서, 전가상화보다 성능이 좋지만 guest os의 커널을 직접 수정해야 하는 경우가 생기며 이가 불가능한 os도 있음. 아무튼 ”쉽지않음” 반가상화는 HW, Hypervisor가 여전히 영어를 쓰고있을떄 각각 os가 영어를 배우고 직접 번역.Type 2 일반 프로그램과 같이 호스트 운영 체제에서 실행 VM 내부에서 동작되는 게스트 운영 체제는하드웨어에서 3번째 수준으로 실행된다. | | | OS | OS | | | +------------------+ | | | HYPERVISOR | | | +------------------+ | | | OS | | | +------------------+ | | | H / W | | | Type2 Host형 가상화라고도 함. 일반적으로 쓰는 vm이 이 형태 애초에 os가 먼저 설치되어이것저것 귀찮음이 없어 접근성이 좋다. 다만, 무겁다. VMware Server, VMware Workstation,VMware Fusion, QEMU, 마이크로소프트의 버추얼 PC와 버추얼 서버,Oracle(SUN)의 버추얼박스, SWsoft의 Parallels Workstation과Parallels Desktop이 있다.OS 수준 가상화(operating system level virtualization) 운영 체제의 커널이 하나의 사용자 공간 인스턴스가 아닌,여러 개의 격리된 사용자 공간 인스턴스를갖출 수 있도록 하는 가상화 방식. 이러한 인스턴스들은 container, software container, Virtual Engine, jail(FreeBSD jail, chroot jail)등 으로 부르며소유자와 사용자의 관점에서 실제 서버인 것처럼 보이게 한다. docker는 이 기반으로 만들어졌다. 호스트 OS위의 Application layer 에서개개의 Application 형태로 동작한다.이 개개의 application을 컨테이너라고 하며호스트 OS위에서 동작한다. 프로그래밍 언어에서 볼 수 있는namespace, class instance 같은 느낌.또는 게임에서 보는 서버안에 개별 채널같은? HW Vitualization 이랑 확연히 다른점은application layer에서 동작한다는점으로OS를 통으로 구동하는게 아닌그 환경을 기반으로 구동되는application을 실행한다는점 그래서 이 전에 vm을 쓰던걸 생각해서linux image받고 실행해보면바로 끝나는게 이런 차이때문 application 처럼 실행하기때문에container의 생성, 삭제가 쉽고기능상으로 갈갈이 찢기 좋게된듯 개개의 컨테이너는 OS Kernel을 공유하여동작하기 때문에 호스트 OS와 컨테이너 OS는 같다. 컨테이너 os가 같은게 싫거나 커널공유로 인한 보안상의 이유로 위 type2형 vm위에서 구동하는 경우도 있나봄. 하나의 컨테이너 내에서 환경변수를 설정했을 땐다른 컨테이너에서 동일하게 먹히지 않는다.서로 격리된 환경이기때문에.Docker 컨테이너 기반의 가상화 도구. 가상화 설명으로 서론이 길었던건 위 한줄 이해를 위해.. 그림으로 보면 type2랑 비슷한 모양일것같은데hypervisor가 docker로, 최상층 os가 container로. | | | container | container | | | +-----------------------+ | | | docker | | | +-----------------------+ | | | OS | | | +-----------------------+ | | | H / W | | | docker 이렇지 않을까 싶다. docker for windows를 설치할 떄두가지 설치 가능한방법이 있는데wsl2를 이용한 방법과 Hyper-V를 이용한 방법.wsl2를 추천한다고 써있음.etc 뇌피셜 공간.및 풀리지 않은 의문점들. 시작에 docker, wsl과 연관있다 했는데정확한건 잘 모르겠고 찾을때이렇다더라 한게 있었는데굳이 필요한 내용은 아닌것같음. wsl1 - wsl2 좋은 비유는 아니지만 굳이 해보자면wsl1은 type2같은 형태,wsl2는 type1같은 형태의 구조. 좋은 비유가 아니라고 한건 wsl1로사실은 api 방식이었나 했는데 컷. wsl2에서 아래깔린 hypervisor는hyper-v로 윈도우에서 type1로제공되는 hypervisor라고 한다. 아무튼 wsl, wsl2를 써보면성능은 wsl2가 좋다고 하는데체감상은 vmware쓰다가 이거쓰면그저 신세계임. 다만 확연히 느낄 수 있는점은wsl1에서는 network, file등신경쓸게 딱히 없었는데내 기억속엔 그럼.다시 보기 귀찮으니까 컷wsl2는 network가 내부망처럼 동작하고file을 직접 까볼수 없게된것 등($wsl로 보면 되는데 컷.) 암튼 미묘하게 다른데 wsl2은 커널을 공유하게되는 형태로 되면서이런 구조를 갖게되는경우보안상의 이유로 가상환경과실제 host환경사이 벽이 쳐지는것같음.docker도 그렇고. in windows 윈도우에서 기능 켜기/끄기를 보면관련되어 보이는게 몇개 보임. Hyper-V linux용 windows 하위 시스템 가상 머신 플렛폼 windows 하이퍼바이저 플렛폼 windows 샌드박스 이 중에 사용중인 기능은linux용 windows 하위 시스템,windows 샌드박스, 가상 머신 플렛폼 여기서부터 잘 모르겠는데내가 실제 쓰는건 wsl, win sandbox,win docker가 있음.그러면 hyper-v가 사용중일줄 알았는데막상보니 그렇지 않음.또 가상 머신 플렛폼이 껴있음.. 생각해보면 wsl2설치 과정에서 명령어가 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 이 두개였음 .애초에 hyper-v는 필요 없었나? win sandbox는 어떤걸 쓰는거임? hyper-v : Microsoft의 hypervisor virtual machine platform : hypervisor를 계속 지원하는덜 강력한(?) Hyper-V.VMP는 WSL2에 대한 요구사항.App-V 또는 MSI를위한 MSX 애플리케이션패키지를 생성하는 데 사용될 수 있음. Windows Hypervisor Platform : Windows hypervisor에서가상화 소프트웨어가 실행되도록 설정. 전체 Hyper-V 없이도가상화된 애플리케이션(App-V 같은)을windows에서 실행할 수 있다. 타사 개발자가 Hyper-V를 사용하기 위해사용할 수 있는 API스택. 타사 가상화 스택 및 애플리케이션을 위한확장 사용자 모드 API를 추가하여hypervisor 수준에서파티션을 생성, 관리하고파티션에 대한 메모리 매핑을 구성하며,가상 프로세서의 실행을 생성하고 제어. Oracle VirtualBox, Docker 및QEMU가 이러한 프로젝트의 예. Windows Subsystem For Linux : Windows 내에서 Linux 명령을 실행. 여기저기서 적당히 짜집어다가 적음 관련 문서는 ms 가상화 문서에서. 또 찾다보니까 나오던데hyper-v를 이용해 linux를 돌리면내가 지금 쓰는 wsl이랑 많이 다름.wsl보다 그게 진짜 os통으로 올라가는 느낌? hyper-v를 쓰면 vm류를 못쓴다하던데난 잘 쓰고있음.이 외에도 몇가지 불편한게 있다던데 난 그런게 없는거 보니wsl이 hyper-v에서 쓰던걸vmp로 바꾸고 지금 처럼 된게 아닌가 싶음. 암튼 여긴 정리할건 아니고정리 될것같지도 않고쓴것도 애매한것도 많고다시 볼일이 있겠나 싶음.참고 가상화 문서" }, { "title": "Python 15 - File 2", "url": "/posts/Python_15_File2/", "categories": "Grind, Python", "tags": "python, file, io", "date": "2022-07-13 01:00:00 +0900", "snippet": "intro 전에 그냥 넘어갔는데 file1에서 쓴 내용을 토대로하면 file내용 수정하는 과정이 쉽지 않다. write는 덮어쓴다.이게 제일 불편한데 f = open(&#39;test.txt&#39;, &#39;w+&#39;, encoding=&#39;utf-8&#39;)f.write(&#39;Hello, world!\\n&#39;)f.seek(0)f.write(&#39;new&#39;)f.seek(0)print(f.read()) newlo, world! 이런식. 길이가 안맞으면 어그러짐. 이 때문에 중간 내용을 수정할 수가 없음. name : Anonymousage : 1190address : seoul 이 경우 그냥 age를 25로 바꿀수가 없음. readlines로 읽고 해당 line를 수정하고파일을 다시 쓰는 식이 될듯함. 결국엔 수정을 위해파일을 처음부터 다시쓰게됨.언제나 이런경우 파일이 커지면,수정이 잦으면 문제임. 아무튼 이런경우 fileinput를 쓴다함fileinput 이 모듈은 표준 입력이나파일 목록에 대한 루프를빠르게 작성하기 위해 쓰임 하나의 파일을 읽거나 쓰려면open()을 쓰래.init 찾아보면서 많이 나온건fileinput.input / fileinput.fileinput이렇게 있는데 둘은 같음. def input(files=None, inplace=False, backup=&quot;&quot;, *, mode=&quot;r&quot;, openhook=None, encoding=None, errors=None): class FileInput: def __init__(self, files=None, inplace=False, backup=&quot;&quot;, *, mode=&quot;r&quot;, openhook=None, encoding=None, errors=None): 실제로 fileinfo.input()안에서fileinput을 생성함. 그렇다 치고, parameter가 많은데그리 자주 쓰는것같지 않아 넘어감 기본적으로 import fileinput f = fileinput.FileInput(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;)# f = fileinput.input(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;) 요정도?inplace는 뒤에 다시.backup은 수정이 될 경우원본 저장 정보. method 쓸 수 있는 method는 method disc filename() 현재 읽고 있는 파일의 이름 fileno() 현재 파일의 정수 “파일 기술자” lineno() 방금 읽은 줄의 누적 줄 번호 filelineno() 현재 파일의 줄 번호 isfirstline() 파일의 첫 번째 줄이면 True isstdin() 마지막 줄을 sys.stdin에서 읽었으면 True nextfile() 다음 파일을 읽도록 현재 파일을 닫음 close() 시퀀스를 닫음. 귀찮아서 간추렸기 때문에정확한건 직접. inplace 쓰다보니까 이상해서. 일단, 단순히 읽고 쓰는게 아니기도하고처음에 생각했던거랑 좀 다르기도하고. 암튼 이상한점들은 option에inplace때문인듯함.read read는 단순하게 보면 import fileinputimport sys origin = open(&#39;test.txt&#39;, &#39;w&#39;)origin.write(&quot;subject\\n&quot;)origin.write(&quot;some test file line 1\\n&quot;)origin.write(&quot;some test file line 2\\n&quot;)origin.write(&quot;some test file line 3\\n&quot;)origin.write(&quot;some test file line 4\\n&quot;)origin.write(&quot;some test file line 5\\n&quot;)origin.close()# print(dir(fileinput)) f = fileinput.FileInput(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;) for line in f: pass for을 보면 딱히 한게 없는데test.txt내용을 보면 암껏도 없음. test.txt.bak을 보면 subjectsome test file line 1some test file line 2some test file line 3some test file line 4some test file line 5 fileinput은 읽으면서해당 line를 지우는듯하다.이건 inplace가 True라서 그렇다함. 암튼 inplace=True의 경우세 가지 효과가 있는데 print출력이 console에서해당 파일로 고정되고 파일을 읽음과 동시애 해당 line를 지우고 수정이 가능해진다. False일 경우 subjectsome test file line 1some test file line 2some test file line 3some test file line 4some test file line 5 결과는 당연히 아무일도 안일어남. write 쓰기는 print 또는 sys.stdout.write로 가능하다. inplace=False는 수정이 불가능하니 생략한다. for안에서 pass 대신 import fileinputimport sys origin = open(&#39;test.txt&#39;, &#39;w&#39;)origin.write(&quot;subject\\n&quot;)origin.write(&quot;some test file line 1\\n&quot;)origin.write(&quot;some test file line 2\\n&quot;)origin.write(&quot;some test file line 3\\n&quot;)origin.write(&quot;some test file line 4\\n&quot;)origin.write(&quot;some test file line 5\\n&quot;)origin.close()# print(dir(fileinput)) f = fileinput.FileInput(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;) for line in f: print(line, end = &#39;&#39;) sys.stdout.write(line) 주의할점은 write는 그대로 써주는데sys를 import해야함. print는 end 를 신경써야함.보통 line끝은 \\n으로 끝나고print도 \\n을 자동으로 붙여줘서빈줄 하나씩 생성됨. subjectsubjectsome test file line 1some test file line 1some test file line 2some test file line 2some test file line 3some test file line 3some test file line 4some test file line 4some test file line 5some test file line 5 암튼 결과는 이렇게됨. method도 출력을 해보면 import fileinputimport sys origin = open(&#39;test.txt&#39;, &#39;w&#39;)origin.write(&quot;subject\\n&quot;)origin.write(&quot;some test file line 1\\n&quot;)origin.write(&quot;some test file line 2\\n&quot;)origin.write(&quot;some test file line 3\\n&quot;)origin.write(&quot;some test file line 4\\n&quot;)origin.write(&quot;some test file line 5\\n&quot;)origin.close() f = fileinput.FileInput(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;)# f = fileinput.input(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;)print(f&#39;filename : {f.filename()}&#39;)print(f&#39;fileno : {f.fileno()}&#39;)print(f&#39;lineno : {f.lineno()}&#39;)print(f&#39;filelineno : {f.filelineno()}&#39;)print(f&#39;isfirstline : {f.isfirstline()}&#39;)print(f&#39;isstdin : {f.isstdin()}&#39;)print(f&#39;nextfile : {f.nextfile()}&#39;) for line in f: print(line , end=&#39;&#39;) print(f&#39;filename : {f.filename()}&#39;) print(f&#39;fileno : {f.fileno()}&#39;) print(f&#39;lineno : {f.lineno()}&#39;) print(f&#39;filelineno : {f.filelineno()}&#39;) print(f&#39;isfirstline : {f.isfirstline()}&#39;) print(f&#39;isstdin : {f.isstdin()}&#39;) print() # print(f&#39;nextfile : {f.nextfile()}&#39;) # in consolefilename : Nonefileno : -1lineno : 0filelineno : 0isfirstline : Falseisstdin : Falsenextfile : None # in test.txtsubjectfilename : test.txtfileno : 3lineno : 1filelineno : 1isfirstline : Trueisstdin : False some test file line 1filename : test.txtfileno : 3lineno : 2filelineno : 2isfirstline : Falseisstdin : False some test file line 2filename : test.txtfileno : 3lineno : 3filelineno : 3isfirstline : Falseisstdin : False some test file line 3filename : test.txtfileno : 3lineno : 4filelineno : 4isfirstline : Falseisstdin : False some test file line 4filename : test.txtfileno : 3lineno : 5filelineno : 5isfirstline : Falseisstdin : False some test file line 5filename : test.txtfileno : 3lineno : 6filelineno : 6isfirstline : Falseisstdin : False print의 출력이 달라지는걸 볼수있고,파일을 읽기 전에는 별 다른 값이 없음.파일을 읽은 다음부터는line마다 각 method return값이 달라짐. example 물론 위에서도파일을 수정한거긴하지만. 조건에 따라 하려면 import fileinputimport sys origin = open(&#39;test.txt&#39;, &#39;w&#39;)origin.write(&quot;subject\\n&quot;)origin.write(&quot;some test file line 1\\n&quot;)origin.write(&quot;some test file line 2\\n&quot;)origin.write(&quot;some test file line 3\\n&quot;)origin.write(&quot;some test file line 4\\n&quot;)origin.write(&quot;some test file line 5\\n&quot;)origin.close()# print(dir(fileinput)) f = fileinput.FileInput(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;)# f = fileinput.input(&quot;test.txt&quot;, inplace=True, backup=&quot;.bak&quot;) for line in f: # sys.stdout.write(line) if line.__contains__(&#39;3&#39;): print(line.replace(line, &#39;new line 3&#39;)) # break else: print(line, end=&#39;&#39;) subjectsome test file line 1some test file line 2new line 3some test file line 4some test file line 5 훠—–ㄹ씬 간단해 졌는데break로 빠져나오면 뒷 내용이 다 날아감.끝까지 loop도는건 무조건인듯. 참고fileinput" }, { "title": "Python 14 - File 1", "url": "/posts/Python_14_File1/", "categories": "Grind, Python", "tags": "python, file, io", "date": "2022-06-23 01:00:00 +0900", "snippet": "File I/O 전에 I/O에서 짧게 썼었는데찾아보니까 좀 많이 나와서전반적으로 다시 써봄open / closeopen open자체는 많은데 open(file: _OpenFile, mode: OpenTextMode = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; TextIOWrapperopen(file: _OpenFile, mode: OpenBinaryMode, buffering: Literal[0], encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; FileIOopen(file: _OpenFile, mode: OpenBinaryModeUpdating, buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; BufferedRandomopen(file: _OpenFile, mode: OpenBinaryModeWriting, buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; BufferedWriteropen(file: _OpenFile, mode: OpenBinaryModeReading, buffering: Literal[-1, 1] = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; BufferedReaderopen(file: _OpenFile, mode: OpenBinaryMode, buffering: int = ..., encoding: None = ..., errors: None = ..., newline: None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; BinaryIOopen(file: _OpenFile, mode: str, buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: _Opener | None = ...) -&amp;gt; IO 다 볼것같진 않고.. f = open(&#39;test.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) 보통은 이렇게 씀. 맨 먼저 파일 위치. 다음은 OpenTextMode를 명시하는데 Character Meaning ‘r’ 읽기(기본값) ‘w’ 쓰기. 파일 무조건 새로생성 ‘x’ 생성. 이미 존재하는 경우 exception ‘a’ 쓰기. 존재하는 경우 파일 끝에 추가 ‘b’ 바이너리 모드 ‘t’ 텍스트 모드(기본값) ’+’ 읽기, 쓰기 모드중 하나 선택하고 +는 선택 기본은 명시 안하면 자동임.따라서 open(filepass)만 하면text로 read만. 다음은 인코딩을 쓴다.closef.close() 끝나면 꼭 닫도록하자.r(read) 읽기. &#39;r&#39;로 연다. 읽는 방법으로read(), readline(), readlines()가 있다.read() 파일 전체를 str로 읽는다. print(f.read()) 11111111112222222222333333333344444444445555555555 읽어올 size를 지정할 수 있다. print(f.read(15)) 11111111112222 주의할점은 \\n도 포함된 숫자임. 따라서 각 줄 끝에있는 \\n을 생각해야함. 읽어서 나온 str의 길이라한글도 한글자는 1로 쳐줌.이 방식이 아마 b모드에서는 다를것같은데일단 넘어감. 읽은 후 다시 읽을 때이 전 읽은 위치부터 시작 print(f.read(15))print(f.read(15)) 1111111111222222222233333333 read자체는 그리 어려울게 없어보이는데위에 쓴 몇가지 이유들때문에주의할필요가 있어보임. readline() 파일 한줄을 읽어 str로 반환 print(f.readline()) 1111111111 역시 size를 지정할 수 있음 print(f.readline(3)) 111 해당 line에서의 size인데line size보다 큰 수가 들어가는경우그냥 다 읽어오고이후 readline에는 영향이 없음. readline는 해당 line를 다 읽어오고받아볼 buffer크기를 지정한다고 하면이해가 빠를듯 역시 읽은 후 다시 읽을 때이 전 위치부터 시작. 한줄만 읽기때문에 전체를 읽을라면 while True: line = f.readline() if not line: break print(line, end=&#39;&#39;) 이렇게 해야함. readlines() 파일을 line별로 읽어str list로 반환 print(f.readlines()) [&#39;1111111111\\n&#39;, &#39;2222222222\\n&#39;, &#39;3333333333\\n&#39;, &#39;4444444444\\n&#39;, &#39;5555555555&#39;] 해서, 제일 좋은방법아닐까싶음. for line in f.readlines(): print(line, end=&#39;&#39;) print(line[1:3]) 111111111111222222222222333333333333444444444444555555555555 Note 1 read하는 방법 3가지 모두한번 읽으면 다음은 그 뒤부터 읽는다. 쉽게, header같은게 위치를 갖고 돌다다니면서그 위치를 읽는다고 보면 됨. 따라서 파일을 한번 끝까지 읽으면다시 처음으로 가서 읽을 수 없다. 아직까진.w(write) w로 연다. 단순히 r로 열면 쓰기가 안된다. 파일이 없으면 새로 만드는데 주의할점은 이미 파일이 있어도해당 파일 이름으로 새로 만든다.write()f = open(&#39;test.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)f.write(&#39;Hello, world!\\n&#39;)slist = [&#39;1\\n&#39;, &#39;2\\n&#39;, &#39;3\\n&#39;, &#39;4\\n&#39;]for s in slist: f.write(s)test.txt에는Hello, world!1234일단, w로만 생성한다고 하고,한번 열린(생성한) 파일에서는write는 append로 동작하는것처럼 보임.그러니까 open에서 새 파일이 만들어지고이후 write는 append처럼 보이는데쓰는 위치는 무조건 마지막에 쓴 위치기 때문.이게 open직후에는 그냥 처음으로.위에서 for을 보면.writelines() readlines를 반대로str list를 file에 써준다. f = open(&#39;test.txt&#39;, &#39;w&#39;)line = &#39;string\\n&#39;lines = [&#39;string1\\n&#39;, &#39;string2\\n&#39;, &#39;string3\\n&#39;] f.write(line) f.writelines(lines) stringstring1string2string3 Node 2 read와 마찬가지로 header가 있다고 하고,동작때마다 header의 위치에 적고 뒤로 밀려난다. append로 동작하는건 아니지만 일단여기에서 그렇게 보이는건 이런이유때문. 따라서 파일을 읽고 쓰는 모든 작업은header가 움직이면서 그 자리에 작업하고그만큼 뒤로 밀려나는식이라고 보여진다. 이 특성은 모든 read/write에 적용되기때문에이걸 염두해야 좀 보기 편할거임.a(append) a로 연다. 파일이 없음면 새로 만드는데w랑 다른점은이미 파일이 있으면 생성하지 않는다. 쓰는 방법도 write()이고,쓰는 위치도 똑같다…는 같은함수니까… f = open(&#39;test.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Hello, world!\\n&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) slist = [&#39;1\\n&#39;, &#39;2\\n&#39;, &#39;3\\n&#39;, &#39;4\\n&#39;] f.writelines(slist) test.txt에는 Hello, world!1234Hello, world!1234 이렇게 남음. x(Exclusive Creation) x로 연다. write mode인데파일이 없는경우 생성하고쓰기모드가 가능. 파일이 이미 있는경우 exception. 이미 파일이 있는경우 체크하기위해? append면 안됨?+ 기능을 추가한다. 이러나 저러나 OpenTextMode가 뭐가 오건read 또는 write였다. 앞에 썼던 기능에 +를 하면반대기능이 생긴다. 다시말해 read랑 write가 가능해진다. 다만 처음 썼던 동작에 의해파일을 생성하거나, 그대로 두거나 한다.r+ read하고 쓰기모드인데read로 file을 열면header위치는 파일내용과 상관없이맨 앞으로 된다. 따라서 단순히 read는문제가 안된다. f = open(&#39;test.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Hello, world!\\n&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;r+&#39;, encoding=&#39;utf-8&#39;) print(f.read()) Hello World! 조금 다르게 해보자. f = open(&#39;test.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Hello, world!\\n&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;r+&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Good!&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;r+&#39;, encoding=&#39;utf-8&#39;) print(f.read()) Good! World! 내용은 바뀔수 있다. 특이한건 open하고 별다른 조작없이write를 했는데 앞에부터 바뀜 이건 위에 썼던 열고난직후파일 header의 위치에 관한 문제인데r+는 open후 파일 header가파일의 맨 앞에 위치함.이상태에서 write를 하니그 위에 덮어쓰게됨. 이걸보면 write는 애초에header위치에 그냥 덮어쓰는거였음. 또 위에 코드에서close()를 안하고 바로 read()를 하면 World! 가 나와서 Note2에서 쓴게 맞음. 다르게, r+상태에서read()를 하고 write()를 하면 Hello World!Good! 가 되었을 것이다. w+ 이 경우 r+보다알아보기 쉬운데w는 파일을 새로 만들기때문. f = open(&#39;test.txt&#39;, &#39;w+&#39;) f.write(&#39;Good!&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;r&#39;) print(f.read()) Good! 그래서 원래 파일에 뭐가 있었건위 코드 결과는 무조건 저 하나만 나온다. a+ 기본적으로 파일 생성 기준은 w와 같은데파일 header는 open()이후 파일의 맨 끝에 있다. 그래서 특이한점은a+는 읽기가 안된다. 정확히는 안되는것처럼 보인다.open()직후부터 header은 맨 뒤로가있고write()도 header을 뒤로 보내므로read()할 내용이 없기때문이다. difference + 붙은 옵션에 따라 동작이 다르긴 했는데결국엔 header같은게 돌아다니면서해당 위치의 데이터를 읽어오는걸볼 수 있었다. 최종적으로는 read, write이지만 세부적으로header의 위치에 따라 조금씩 차이나는점,read(), write()는 header의 위치를계속해서 뒤로 밀어낸다는점이주의할점으로 보인다. header의 위치에 관해 조금더 보자.tell 현재 header 위치를 알려준다. f = open(&#39;test.txt&#39;, &#39;w&#39;)slist = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;,&#39;\\n&#39;] print(f.tell()) for s in slist: f.write(s) print(f.tell()) 01235 예생했던것처럼시작은 0에서 write때마다쓰는만큼 늘어난다.read도 같을것이다. 좀 특이한건 \\n인데보이지도 않으면서 2개를 먹음쓸때 2글자긴하잖?근데 읽을때는 1개로침?seek header을 움직인다. 설명엔 (method) seek: (__cookie: int, __whence: int = ..., /) -&amp;gt; int 이러는데 __whence는 binary에서만 된다 아무튼 header을 옮기고그 위치부터 작업할 수 있다. f = open(&#39;test.txt&#39;, &#39;w+&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Hello, world!\\n&#39;) print(f.tell()) print(f.read()) f.seek(0) print(f.tell()) print(f.read()) 15 0Hello, world! open-write 까지하면 당연히 read할 내용이 없음seek로 header를 옮기고 다시 읽을 수 있음. 다만, 이게 a일때 좀 특이한데 f = open(&#39;test.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) f.write(&#39;Hello, world!\\n&#39;) f.close() f = open(&#39;test.txt&#39;, &#39;a+&#39;, encoding=&#39;utf-8&#39;) print(f.tell()) f.seek(0) print(f.tell()) f.write(&#39;Good!&#39;) f.seek(0) print(f.read()) 150Hello, world!Good! 위에서보면 seek로 header를처음으로 돌려놓고 write를 했는데끝지점부터 쓰는걸 보면append는 write할 때header를 맨 끝으로 강제이동한다.다만, read는 seek 위치부터. " }, { "title": "Python 13 - Class 2", "url": "/posts/Python_13_Class2/", "categories": "Grind, Python", "tags": "python, class, inheritance, abstract", "date": "2022-06-12 01:00:00 +0900", "snippet": "Inheritance 부모자식의 시작. 목적이야뭐.. 기존 class 확장. 새 field를 추가 method 다시 정의또는 새로 추가 등등. 이건 oop 관련다시 정리하면 좋을듯. Basic 기본적으로 쓰는건 class parent1: a = None b = None def __init__(self): self.a = 1 self.b = 2 print(&quot;parent1&quot;) def mtd(self): print(&quot;parent1 mtd&quot;) class parent2: c = None d = None def __init__(self, c, d): self.c = c self.d = d print(&quot;parent2&quot;) class child(parent1, parent2): e = None f = None def __init__(self): parent1.__init__(self) parent2.__init__(self, 3, 4) self.e = 5 self.f = 6 print(&quot;child&quot;) def ps(self): print(self.a, self.b, self.c, self.d, self.e, self.f) def mtd(self): print(&quot;now child mtd&quot;) parent1.mtd(self)ch = child()ch.ps() ch.mtd() 이걸 기본으로 쓰겠음.출력은 parent1 parent2 child 1 2 3 4 5 6 now child mtdparent1 mtd 기본 class는 className:로 끝났다면이름뒤에 (parentClass, ...) 를 붙임. multi inheritance도 된다.parent.init 상속 관계에서 child에는parent의 field의 값이 들어오지 않음 parent1에서 a, b에 값을 넣어도원래는 상속받은 child에 그 값이 전달되지 않음그러니까 위에서 parent1.__init__(self)parent2.__init__(self, 3, 4) 이게 빠지면 출력이 childNone None None None 5 6 이렇게 됨 다만, parent.__init__()가 빠져도property나 method가 안들어오는건 아님다시말해 상속은 됐는데parent의 init에서 설정한 값들만 안들어옴. 이걸 child입장에서 보면, parent에서 설정한 값들이 필요 없으면parent.__init__를 할 필요 없어지고 parent에서 설정한 값들을 쓰고싶으면parent.__init__ 를 쓰면됨.이 경우 child에서 값을 또 입력하는수고를 덜게됨 아무튼 상황에 따라 골라쓸 수 있음. Overriding 위의 경우에서 상속만 받았다면 ch.mtd() 의 결과는 parent1 mtd 이건뭐.. overriding도 간단한데 child에서 처럼 def mtd(self): print(&quot;now child mtd&quot;) parent1.mtd(self) 이렇게 추가만 하면 됨.이게 추가되서 결과적으로 now child mtdparent1 mtd 이런 출력이 나옴. 여기에 parent1.mtd(self)를 더 써놨는데이건 사실 필요없고parent의 원래 mtd불러올때 이런식으로 하면 됨. Multi Inheritance 이거에 관련된 설명을 좀 봐서 써봄 일단은 Multi Inheritance를cpp는 허용인데 java, c#은 아님.해서 사실 이 문제를 접할 상황이 없긴 했음. 아무튼 multi가 된다고는하고,이 키워드랑 가장 관련있게 나오는게The diamond problem인데 - parent1 - / \\grandparent - - child \\ / - parent2 - 이런 구조일때를 말함. 보통 말하는건 grandparent에 있던 method는child에서 어떻게 보일까에 대한 문제로 이름이 같은 method가상속관계 전반에 걸쳐있을 때모호함에 대한걸 말하는것같다. 실제 저런 구조로 class gparent: gp = None def __init__(self): pass def gmtd(self): print(&quot;gparent&quot;) class parent1(gparent): a = None b = None def __init__(self): self.a = 1 self.b = 2 self.gp = &#39;from parent1&#39; print(&quot;parent1&quot;) def mtd(self): print(&quot;parent1 mtd&quot;) def gmtd(self): print(&quot;parent1 gmtd&quot;) class parent2(gparent): c = None d = None def __init__(self, c, d): self.c = c self.d = d self.gp = &#39;from parent2&#39; print(&quot;parent2&quot;) def gmtd(self): print(&quot;parent2 gmtd&quot;) class child(parent1, parent2): e = None f = None def __init__(self): parent1.__init__(self) parent2.__init__(self, 3, 4) self.e = 5 self.f = 6 print(&quot;child&quot;) def ps(self): # print(self.a, self.b, self.c, self.d, self.e, self.f) print(self.gp) def mtd(self): print(&quot;now child mtd&quot;) parent1.mtd(self) 이떄 ch.gmtd() 에 대한 출력은 parent1 gmtd parent1, parent2모두를 상속받았으나1을 참조하는것처럼 보인다. method resolution order python은 이런 상속관계에서method 참조 순서를 보여준다. class.mro()를 하면 볼 수 있다. print(child.mro()) 를 하면 [&amp;lt;class &#39;__main__.child&#39;&amp;gt;, &amp;lt;class &#39;__main__.parent1&#39;&amp;gt;, &amp;lt;class &#39;__main__.parent2&#39;&amp;gt;, &amp;lt;class &#39;__main__.gparent&#39;&amp;gt;, &amp;lt;class &#39;object&#39;&amp;gt;] 이렇게 나오는데child에서 method를 참조하는 순서를 보여준다. 순서상 먼저 써있는 class의 method를 참조하는데child.gmtd()를 호출하면 child에서 먼저gmtd()를 찾는데 위의 경우 child에 없다. 그 다음 순서인 parent1의 gmtd()를 불러온것.parent1의 gmtd()를 지운다면gparent에서 불러온다. 상속…이 복잡할 떄 method호출 관련애매하면 이걸 보는 방법이 있다고 하드라..여기서 뭘 바꾸거나 할수 있는건 아닌것같다.super 아까 상속에서 parent의 init를 쓸때paren1.__init__ , parent2.__init__를직접 명시했는데 super()을 넣어도 됨 이렇게 쓸 경우 두 parent중 첫번째로 쓴 parent를 호출함. parent를 하나쓸때는 상관 없어보이는데2개 이상일때는 직접 명시하는게 좋아보인다.Abstract class 일단 python에는 interface나 abstract이딱히 없는것같다. 지금까지 찾은바로는.in C# 비교해보면 interface IMyInterface{ void MyMethodInterface();} public abstract class MyBaseClass{ int i; public abstract void MyMethodAbstract(); public virtual void MyMethodAbstract2() { Console.WriteLine(&quot;MyBaseClass.MyMethod&quot;); }} public class MyClass : MyBaseClass, IMyInterface{ public override void MyMethodAbstract() { throw new NotImplementedException(); } public override void MyMethodAbstract2() { base.MyMethodAbstract2(); } public void MyMethodInterface() { throw new System.NotImplementedException(); }} 근데 interface나 abstract등등을관련되서 쓰는걸 보면 먼저 틀만 잡아놓고,상속받고, 구현하는게 비슷하긴함다만 조금씩 재약이 다르고좀 디테일하게 쓰는 방법이 다른정도? 그렇게보면 이런 구별 없이 쓰는게좀 나은건가 싶기도 하고…어차피 상속-구현이 중점이니까. 아무튼 중요한점은 interface, abstract를상속받는 class에서 method의 구현을강제할수 있냐없냐가 중요한듯하다. C#에서 interface는 무조건 구현을 강제하지만abstract는 virtual, abstract로 구별해선택적으로 가능해진다.pass method를 구현 안하고비워둘수 있는 키워드 class parent: def method1(self): 이렇게 쓸 수 없음. class parent: def method1(self): pass 구현 안하고 넘어가는 method에 쓰면됨. in python python에서는 class parent: def method_1(self): pass class child(parent): def method_2(self): print(&quot;child method2&quot;) c = child() 이렇게 해도 아무 문제 없다. override가 키워드 제약없이 쉬워보였는데상속받는 clss에 강제하는 방법도 없어보임. 조금 바꿔서 class parent: def method_1(self): raise NotImplementedError() class child(parent): def method_2(self): print(&quot;child method2&quot;) c = child()c.method_1() 이런식으로 exception을 발생시켜이후에 구현을 유도할수도 있지만… 문제는 NotImplementedError()가포함된 method를 호출하기 전까지아무 문제없이 실행된다는점이다. 위에서 c.method_1()가 없으면아무 문제없이 넘어갈수도 있게됨. 간단한 예시만 보면그냥 알잘딱깔센 하면 되지 않을까 싶은데이게 언제나 점점 덩치가 불어나면 문제가 된다.ABC(Abstract Base Class) python에서 이런 문제를 해결하기위해 쓴다. parent를 상속받는 child에서구현을 강제한다. abc를 써보면 import abc class parent(metaclass=abc.ABCMeta): @abc.abstractmethod def method_1(self): pass def method_2(self): pass metaclass=abc.ABCMeta와@abc.abstractmethod가 생겼다. metaclass=abc.ABCMeta는abstract class라고 알리는것 같은데이 키워드가 붙으면 해당 class로는 더아상instance를 만들 수 없다. c1 = parent() 를 하면 TypeError: Can&#39;t instantiate abstract class parent with abstract method method_1 라고 한다. 암튼 안됨. @abc.abstractmethod는상속 받는 child class에서강제로 구현을 하도록 하는데 이 전에 썼던NotImplementedError()와 다른점은NotImplementedError()은 exception시점이해당 method가 호풀될 때 이지만@abc.abstractmethod를 쓰면 런타임때 걸림. TypeError: Can&#39;t instantiate abstract class child with abstract method method_1 …근데 내용은 같네… 아무튼 결과적으로 import abc class parent(metaclass=abc.ABCMeta): @abc.abstractmethod def method_1(self): pass def method_2(self): pass class child(parent): def method_ch(self): print(&quot;child method&quot;) def method_1(self): print(&quot;child method 1&quot;) c = child() 이런 형태가됨. @abc.abstractmethod가 안붙은 method는이후 구현을 같제하지 않음. 하던말던.vs C# C#이랑좀 비교해보면 요정도 C# virtualchild class에서 구현 ‘가능’ abstractchild class에서 구현 ‘강제’ 두 키워드 없는 일반적인 경우child class에서 구현 ‘불가’ python @abc.abstractmethodchild class에서 구현 ‘강제’ 키워드 없는 일반적인 경우child class에서 구현 ‘가능’ " }, { "title": "Python 12 - Class 1", "url": "/posts/Python_12_Class1/", "categories": "Grind, Python", "tags": "python, class", "date": "2022-06-09 01:00:00 +0900", "snippet": "Class 그 클래스.붕어빵틀 이면서자동차 설계도 등. 아무튼 속성이랑 메서드를포함하는 전체.python classbasic includes 기본적으로 만들면포함하고있는 것들이 있는데 class temp: a = None print(dir(temp)) [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;a&#39;] a는 직접 쓴거니까 제외하고 저런게 있음. 위는 오다가다 볼 내용들이니 넘기고기본적인 명세와 사용은 이렇다. class Unit: name = &quot;&quot; hp = 0 def __init__(self, name, hp): self.name = name self.hp = hp def print_info(self): print(&quot;Name:&quot;, self.name) print(&quot;HP:&quot;, self.hp) unit1 = Unit(&quot;marine&quot;, &quot;120&quot;)unit1.print_info() new instance 인스턴스 생성은var = ClassName(args) new 키워드가 안붙음.self 자신 class를 말하고instance화 했을 떄자기 자신의 주소를 갖는다고? 하면 this랑 비슷한듯. class안 method의첫번째 parameter로 항상 들어옴.써주기만하고 실제로 전달받지는 않음. 다만, method에서 field로접근이 필요없다면self는 parameter에서 생략 가능.위 같은 경우def print_info(self):에서 self를 뻈을 때 name, hp로 접근이 안됨 아무튼 그렇다는데 자주보이니아직 확실치는 않아도익숙해지것지.Constructor 생성자. 위에도 씀. __init__ 로 예약됨. 없어도 상관없긴함.원래 알던 비슷한 이유일듯. 좀 특이한점이 있는데overload가 안됨. class asdf: a = &#39;&#39; b = &#39;&#39; c = &#39;&#39; def __init__(self): self.a = 1 self.b = 2 self.c = 3 def __init__(self, a, b, c): self.a = a self.b = b self.c = c def __init__(self, a, b, c, d): self.a = a self.b = b self.c = c self.d = d a2 = asdf()a1 = asdf(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) print() 이 경우 문제가 되는데 TypeError: __init__() missing 4 required positional arguments: &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, and &#39;d&#39; 라고 한다. __init__는 마지막에 쓴거만 쓰나봄. Member variable 위에 쓴 name, hp를 말함. class에 속한 변수들.무친기능 1 위에는 name, hp를명시했는데 없어도 됨 class Unit: def __init__(self, name, hp): self.name = name self.hp = hp def print_info(self): print(&quot;Name:&quot;, self.name) print(&quot;HP:&quot;, self.hp) unit1 = Unit(&quot;marine&quot;, &quot;120&quot;)unit1.print_info() 똑같은 동작을 하는데 print(dir(unit1)) [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;hp&#39;, &#39;name&#39;, &#39;print_info&#39;] dir을 보면 쓰지 않았던 hp, name을 갖고 있다. init에 써줘서 알아서 해주나봄.근데 init에서 해주는것보다 그 전에 명시해주는게 보기 좋지 않을까? 아무튼. 무친기능 2 위 예제에 이걸 더한다. unit2 = Unit(&quot;firebat&quot;, &quot;120&quot;)unit2.print_info() unit1.range = 30 print (&quot;unit1 Range:&quot;, unit1.range)print (&quot;unit2 Range:&quot;, unit2.range) unti1에 range라는 속성이 하나 더 생김.unit2에는 안생김. 세상에 Member variable share 같은 class끼리멤버공유가 가능한데Unit class를 예로들어 class Unit: def __init__(self, name, hp): self.name = name Unit.hp = hp def print_info(self): print(&quot;Name:&quot;, self.name) print(&quot;HP:&quot;, self.hp) u1 = Unit(&quot;전사&quot;, 100)u1.print_info()u2 = Unit(&quot;마법사&quot;, 200)u1.print_info()u2.print_info() Name: 전사HP: 100Name: 전사HP: 200Name: 마법사HP: 200 전사hp의 경우 마법사에서 바꾼 hp를 따라감. class.member로 써서 나타냄. 일반적으로 쓰는걸 instance variable,공유가능한걸 class variable 라고 함. class variable에 접근시classname.variabe를 권장하는데 self를 해도 상관없는것같긴하다.Method 기능담당. 위에 쓰는것처럼. 이 전에 따로 썼으니 패스" }, { "title": "Python 11 - Collection 2", "url": "/posts/Python_11_Collection2/", "categories": "Grind, Python", "tags": "python, collection", "date": "2022-06-04 01:00:00 +0900", "snippet": "Intro collection1에서는내장인 범용 컨테이너였음. 여긴 collections에 있는특수 컨테이너. 를 할 계획이었는데정리가 잘 안되서필요한게 보일때마다추가하기로함. 종류로는 name discription namedtuple 이름 붙은 필드를 갖는 튜플 서브 클래스를 만들기 위한 팩토리 함수 deque 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너 ChainMap 여러 매핑의 단일 뷰를 만드는 딕셔너리류 클래스 Counter 해시 가능한 객체를 세는 데 사용하는 딕셔너리 서브 클래스 OrderedDict 항목이 추가된 순서를 기억하는 딕셔너리 서브 클래스 defaultdict 누락된 값을 제공하기 위해 팩토리 함수를 호출하는 딕셔너리 서브 클래스 UserDict 더 쉬운 딕셔너리 서브 클래싱을 위해 딕셔너리 객체를 감싸는 래퍼 UserList 더 쉬운 리스트 서브 클래싱을 위해 리스트 객체를 감싸는 래퍼 UserString 더 쉬운 문자열 서브 클래싱을 위해 문자열 객체를 감싸는 래퍼 namedtuple tuple의 각 item에이름을 쓸 수 있다. 이거 비슷한게 있었는데 앞에 다시 보던가.structure 원형은 (function) namedtuple: (typename: str, field_names: str | Iterable[str], *, rename: bool = ..., module: str | None = ..., defaults: Iterable | None = ...) -&amp;gt; Type[tuple] 이런 모습이고 Returns a new subclass of tuple with named fields. &amp;gt;&amp;gt;&amp;gt; Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])&amp;gt;&amp;gt;&amp;gt; Point.__doc__ # docstring for the new class&#39;Point(x, y)&#39;&amp;gt;&amp;gt;&amp;gt; p = Point(11, y=22) # instantiate with positional args or keywords&amp;gt;&amp;gt;&amp;gt; p[0] + p[1] # indexable like a plain tuple33&amp;gt;&amp;gt;&amp;gt; x, y = p # unpack like a regular tuple&amp;gt;&amp;gt;&amp;gt; x, y(11, 22)&amp;gt;&amp;gt;&amp;gt; p.x + p.y # fields also accessible by name33&amp;gt;&amp;gt;&amp;gt; d = p._asdict() # convert to a dictionary&amp;gt;&amp;gt;&amp;gt; d[&#39;x&#39;]11&amp;gt;&amp;gt;&amp;gt; Point(**d) # convert from a dictionaryPoint(x=11, y=22)&amp;gt;&amp;gt;&amp;gt; p._replace(x=100) # _replace() is like str.replace() but targets named fieldsPoint(x=100, y=22) 대충 이런 설명이 나옴 parameter typename : 앞으로 쓰일 이름. field_names : item name - 여기까지 필수 abc = namedtuple(&#39;test&#39;, &#39;a b c&#39;)t = abc(c=3, b=2, a=1)print(t)# test(a=1, b=2, c=3) print하면 test로 나옴.처음에 typename로 했던. 정해진 field_name으로직접 넣을 수 있고(위의 경우)위처럼 지정하지 않으면자리에 맞춰들어감. field_name은&#39;a b c&#39; 또는&#39;a,b,c&#39; 또는[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]다 가능. dict랑 비슷해지는데위의 경우 t.a로1을 불러올 수 있음 rename : true일떄,유효하지 않은 필드명 자동 대체. abc = namedtuple(&#39;test&#39;, &#39;a def c a&#39;)a = abc(1, 2, 3, 4) 이 경우 a는 중복, def는 예약어로원래 쓸 수 없음 rename=True를 쓰면’a _1 c _3’으로 자동 치환됨. default : 기본값 abc = namedtuple(&#39;test&#39;, &#39;a b c&#39;, rename=True, defaults=(2, 3))a = abc(0)print(a)# test(a=0, b=2, c=3) 필드 기본값을 설정. 인덱스상 뒤부터 채워주고정하지 않은 필드는 필수값이됨 module는 __module__값을 설정하는데왜쓰는지는 모름…method 시작은 abc = namedtuple(&#39;test&#39;, &#39;a b c&#39;) 이것부터. _make temp = [1, 2, 3]t = abc._make(temp)print(t) 새 인스턴스 생성 _asdict() d = t._asdict()print(d) dict로 형변환… 반대로dick → namedtuple t1 =abc(**d)print(t1) _replace t = t1._replace(a=4)print(t)print(t1) 해당 값을 바꾼 새 instance반환 원본은 안바뀜 _fields print(t1._fields) read field dequedouble-ended queue python에는 queue, stack가 딱히 없었다. 그나마 list에 pop(index)와append(item), insert(index)등잘 조합하면 됐을거다. insert(0), pop()를 하면queue가 만들어지는데이 경우 성능이 안좋아짐 deque는스택과 큐를 일반화 한 것으로스레드 안전하고 메모리 양쪽 끝에서append, pop을 거의 같은 O(1)의성능을 냄 근데 또 중간에 끼워넣는건 비슷하다네..method     append 끝에 붙임 appendleft 앞에 붙임 clear clear copy 앝은 복사 count count extend 끝에 추가 extendleft 앞에 추가 index item 위치 insert 위치에 추가 maxlen 최대 크기 제한 pop 끝에 반환/제거 popleft 앞에 반환/제거 remove item 제거 reverse 역정렬 rotate 오른쪽으로 회전 대부분 list를 기본으로 같음. 특화된점으로는 xxxleft가 있는데index상 0쪽에 붙이는 경우 씀. 아무튼 비슷하기 때문에 패스. maxlen l = [1, 2, 3, 4, 5]dl = deque(l, maxlen=3)print(dl) # deque([3, 4, 5], maxlen=3) 최대 길이고이런경우 namedtuple처럼뒤에만 취급. rotate l = [1, 2, 3, 4, 5]dl = deque(l)print(dl)dl.rotate(2)print(dl) # deque([1, 2, 3, 4, 5])# deque([4, 5, 1, 2, 3]) 기본 방향은 오른쪽. index에 숫자를 더한다고 생각하면됨. 결과로 위에서 2를 넣어서idx=0이었던 1이idx=2가됨. circular queue식으로 회전. ChainMapCounterOrderedDictdefaultdictUserDictUserListUserString" }, { "title": "Python 10 - List Comprehension", "url": "/posts/Python_10_LC/", "categories": "Grind, Python", "tags": "python, list", "date": "2022-05-15 00:00:00 +0900", "snippet": "intro lambda할때 비슷한 형태가 나오긴했는데lambda는 익명함수가 메인이었으면이건 좀 다름. LC는 for문을 간결하게 쓰는게 목적임. 먼저 일반적인 경우를 생각했을 때 l = []for i in range(10): if i % 2 == 0: l.append(i * i) print(l) 이 뭉탱이가 nl = [i*i for i in range(10) if i % 2 == 0]print(nl) 이렇게 써도 같은 결과를 얻는다. structure 기본 구성은 다음과같다. somelist = [ expression(i) for i in data if condition(i)] 결과는 somelist로 list. 식을 보면 [ ]으로 묶는데 그래서 결과도 list인듯. 또, list가 제일 쉬움 몸체는 for문 data랑 item 나열 condition에 true로 걸리는애들이 1차 결과. 필터라고 생각하면 됨 1차로 걸리진 애들을 expression으로 계산 list에 들어갈 최종 item. 딱히 계산이 없어도 var은 있어야함 조건, 계산만 잘 써먹으면이것저것 다 쓸 수 있을것 같음. s = &quot;a dog is a good dog&quot;.split()l = [i[0] for i in s if len(i) &amp;gt; 2] print(l) # [&#39;d&#39;, &#39;g&#39;, &#39;d&#39;] for 중첩 - 1 for문 중첩을 이용할 수 있음 cafelist = [&#39;twosome&#39;, &#39;starbucks&#39;]coffeelist = [&#39;cappuccino&#39;, &#39;latte&#39;] l = [(cf, cfe) for cfe in coffeelist for cf in cafelist]print(l) #[(&#39;twosome&#39;, &#39;cappuccino&#39;), # (&#39;starbucks&#39;, &#39;cappuccino&#39;), # (&#39;twosome&#39;, &#39;latte&#39;), # (&#39;starbucks&#39;, &#39;latte&#39;)] for 중첩으로 쓸 수 있는데사실 이 경우 중첩보다는결과 뽑아낼때 형태때문에… for 중첩 - 2 직접 for이랑 비교해보면 l = [[1,2,3],[4,5,6],[7,8,9]]nl = [y for x in l for y in x]print(nl) l1 = [[1,2,3],[4,5,6],[7,8,9]]nl = []for x in l1: for y in x: nl.append(y)print(nl) 둘은 같은 결과로 [1, 2, 3, 4, 5, 6, 7, 8, 9] 이게 나옴 한단계 더 해서 l2 = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]nl = [z for x in l2 for y in x for z in y]print(nl) nl = []for x in l2: for y in x: for z in y: nl.append(z)print(nl) 둘은 같은 결과로 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 대충 나온것같다. for가 중첩되는경우,안쪽블록으로 들어갈 for문이LC에서는 오른쪽에 배치하면되고결과 item은 가장 왼쪽.for 중첩 - 3 다음으로위 예제는 sublist가 다 꺠진다2차 list에서 1차list가 된다. 이 형태를 깨지 않으려면? l = [[1,2,3],[4,5,6],[7,8,9]] nl = [] for x in l: sl = [] for y in x: sl.append(y*y) nl.append(sl) print(nl) 결과는 [[1, 4, 9], [16, 25, 36], [49, 64, 81]] 지금까지 내용으로 LC로 바꾸면 nl = [y*y for x in l for y in x] print(nl) 이것밖에 안됨. 구조가 깨짐. 원하는 결과를 얻으려면 nl = [[x*x for x in y] for y in l]print(nl) 이게 원하던 결과인 [[1, 4, 9], [16, 25, 36], [49, 64, 81]] 가 나온다 이 결과는 혼자였으면 절대 몰랐을듯.. 근데 [x*x for x in y]를X로 치환하면X for in l로 얼추 비슷해지는데X또한 list로 반환한다는점을 보면이해가 좀 되는것같기도하고.. 지금도 충분히 복잡하니까 3중은 넘어가자..if 중첩 여기도 중첩이 되는데 l = list(range(50)) l1 = [i for i in l if i % 2 == 0 and i % 3 == 0] l2 = [i for i in l if i % 2 == 0 or i % 3 == 0] l3 = [i for i in l if i % 2 == 0 if i % 3 == 0] # [0, 6, 12, 18, 24, 30, 36, 42, 48] 딱 이것 ’ 만 ’ 된다 이거 외에 다른식으로 쓰는건 전부 안됨 귀찮아서 안쓰겠음. 통일성있게if는 터음에 한번만 쓰고 뒤에는 and, or붙이는게 좋을것같음.outro 약간 linq같은 느낌인데 문제는for건, if건 중첩이 되면애가 좀 망가짐 다른 언어도 마찬가지로한 블록안에 들여쓰기가 많아지면애가 좀 안이뻐지는데python 은 { }도 없어서약간 불편한것도 있음.이런걸로 간편히 써서이쁘게 잘 쓰는게 좋을듯. 단순하게 표현해주는건 맞는데간단한 경우에만 써는느낌.. 복잡한 경우 map, filter등의다른 방법도 있다하니더 알게되면 잘 쓰겠지뭐.." }, { "title": "Python 9 - DataType Extra", "url": "/posts/Python_9_DataTypeEx/", "categories": "Grind, Python", "tags": "python, datatype, collection, sequence", "date": "2022-05-14 00:00:00 +0900", "snippet": "extra? 약간 뒤죽박죽이긴한데이 앞에 collection까지 해서data type이 끝난다. collection이 적합한가를 떠나일단 썼던건 set, mepping등다른 type도 섞여 있어서였는데아직도 다른 표현은 못찾겠음 아무튼, data type, collection에서빼먹은?것들. 일단 전체적으로 보자면 DataType | | --- | | - Null -------------| - None | | - Numeric --------- | | | - int | | - float | | - complex | | - Sequence -------- | | | - list (mutable) | | - tuple (immutable) | | - range (mutable) | | - Text Sequence ---| - str(immutable) | | - Binary Sequence - | | | - bytes(immutable) | | - bytearray(mutable) | | - memoryview | | - Set ------------- | | | - set(mutable) | | - frozenset(immutable) | | - Mapping ----------| - dict(mutable) type   Null None Numeric int   float   complex Sequence list(mutable)   tuple(immutable)   range(mutable) Text Sequence str(immutable) Binary Sequence bytes(immutable)   bytearray(mutable)   memoryview Set set   frozenset(immutable) Mapping dict(mutable) 이 내용은 Built-in Types 를 참조하는데잘보면 내용이 조금 다른 부분이 있긴함 다만, 내가 한 정리는 대충 한거니까저 문서를 항상 참조해야함. 이 다음 내용들도 간략하게 쓰고자세히는 위 docs를 봐야함.sequence형 여기 속한 type는list, tuple, range만 써있는데이름에 sequence를 쓰는다른 type들도 포함할 수 있는지는정확치 않음 아래 쓴 내용들은 원래해당 sequence type에서는있을수도 있고 없을수도 있는데없는건 여기에 쓸걸 염두해둔것.공통 sequence 연산 mutable, immutable상관없이 지원 연산 결과 x in s s에 x 가 있으면 True x not in s s에 x가 없으면 True s + t s 와 t연결 s * n 또는 n * s s를 n번 copy s[i] i 번째 s[i:j] i &amp;lt;= item &amp;lt; j s[i:j:k] i &amp;lt;= item &amp;lt; j, k step len(s) 길이 min(s) 가장 작은 항목 max(s) 가장 큰 항목 s.index(x[, i[, j]]) item index s.count(x) s 등장하는 x 의 총수 가변 sequence 연산 연산 결과 s[i] = x s 의 항목 i 를 x 로 s[i:j] = t 조건의 영역이 이터러블 t 로 대체 del s[i:j] 조건 영역 삭제 s[i:j:k] = t 조건의 영역이 이터러블 t 로 대체 del s[i:j:k] 리스트에서 조건의 항목 제거 s.append(x) s 뒤에 x를 추가 s.clear() 모든 항목을 제거 s.copy() 얕은 복사 s.extend(t) 또는 s += t s 뒤로 t 붙임 s *= n n 번 반복되도록 s 를 갱신 s.insert(i, x) i에 x 삽입합니다 s.pop() or s.pop(i) i 항목을 꺼내고 s 에서 제거 s.remove(x) x가 첫 번째로 나타나는 항목 제거 s.reverse() 역정렬 str modify str은 immutable임. s = &quot;asdfa&quot;s[0] = &quot;z&quot; Traceback (most recent call last): File , line 2, in &amp;lt;module&amp;gt; s[0] = &quot;z&quot;TypeError: &#39;str&#39; object does not support item assignment 수정하는 방법으로replace, translate가 있는데 s = &quot;asdfa&quot; s1 = s.replace(&quot;a&quot;, &quot;z&quot;) print(s1) s2 = s.translate(s.maketrans(&quot;a&quot;, &quot;z&quot;)) 문제는 이 경우 같은 글자는 다바뀜. 어떤 특정 위치값을 수정못함. list 사용s = &quot;asdfa&quot;l = list(s)l[0] = &quot;z&quot;s = &quot;&quot;.join(l)print(s)bytearray 사용s = &quot;asdfa&quot;ba = bytearray(s, &quot;utf-8&quot;)ba[0] = 0x00print(ba)ba[0] = ord(&#39;X&#39;)print(ba)ba[0:3] = b&quot;XYZ&quot;print(ba)s1 = ba.decode(&quot;utf-8&quot;)print(s1) 한글자 바꿀 때 ord(’X’)를 썼는데b&#39;X&#39;쓰면 exceptionslicing사용s = &quot;asdfa&quot;s1 = s[1:4]print(s1)print(type(s1))new_s = &#39;new&#39;+s1+&#39;end&#39;print(new_s) 이 때 slicing 결과를 str인데원본 type를 따라감. list slicing 하면 list. " }, { "title": "Python 8 - Collection", "url": "/posts/Python_8_Collection/", "categories": "Grind, Python", "tags": "python, list, dictionary, tuple, set, frozenset, bytes, bytearray, memoryview", "date": "2022-05-10 00:00:00 +0900", "snippet": " 일단, collection이이번 제목에 적합한지 잘 모르겠으나,익숙한 표현이 이거라 일단 씀.list 선언은 [ ]안에 자료 형식에 상관없이 다 넣을 수 있음. name discription append 확장 copy 복사된 새 객체) clear clear count 해당 요소 갯수 extend 확장 index 해당 요소 위치 insert 위치에 insert pop(pop) 위치의 요소 꺼내옴 pop(res) 꺼내면 사라짐 remove 삭제(안꺼내옴) reverse 정렬 반대로 sort 정렬 append / extendpop / remove는 약간씩 차이가 있음.data1 = [0, 1, 2, 3, 4]data2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]data3 = data1.copy()data4 = data2.copy()data3.append(data4)print(&quot;{0:10} : {1}&quot;.format( list.append.__name__ , data3))data3 = data1.copy()data4 = data2.copy()data4 = data1.copy()print(&quot;{0:10} : {1}&quot;.format( list.copy.__name__ , data4))data4 = data2.copy()data4.clear()print(&quot;{0:10} : {1}&quot;.format( list.clear.__name__ , data4))data4 = data2.copy()print(&quot;{0:10} : {1}&quot;.format( list.count.__name__ , data4.count(&quot;d&quot;)))data3 = data1.copy()data4 = data2.copy()data3.extend(data4)print(&quot;{0:10} : {1}&quot;.format( list.extend.__name__ , data3))data4 = data2.copy()print(&quot;{0:10} : {1}&quot;.format( list.index.__name__ , data4.index(&quot;d&quot;)))data3 = data1.copy()data3.insert(3, data4)print(&quot;{0:10} : {1}&quot;.format( list.insert.__name__ , data3))data4 = data2.copy()print(&quot;{0:10} : {1}&quot;.format( list.pop.__name__+&quot;(pop)&quot; , data4.pop(2)))print(&quot;{0:10} : {1}&quot;.format( list.pop.__name__+&quot;(res)&quot; , data4))data4 = data2.copy()data4.remove(&quot;d&quot;)print(&quot;{0:10} : {1}&quot;.format( list.remove.__name__ , data4))data4 = data2.copy()data4.reverse()print(&quot;{0:10} : {1}&quot;.format( list.reverse.__name__ , data4))data4.sort()print(&quot;{0:10} : {1}&quot;.format( list.sort.__name__ , data4))append : [0, 1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]]copy : [0, 1, 2, 3, 4]clear : []count : 1extend : [0, 1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]index : 3insert : [0, 1, 2, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], 3, 4]pop(pop) : cpop(res) : [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;]remove : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;]reverse : [&#39;e&#39;, &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]sort : [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]dictionary { }로 선언. {key : value} 쌍의 Item으로 구성 name discription fromkeys 새 dict생성 get get items key,value get keys key get pop value 꺼냄 popitem value 꺼냄 setdefault get or create update update value or create fromkeys는 create. pop은 key에 대한 value를 뽑아옴popitem은 맨 오른쪽 item을 뽑아옴둘 다 해당 item은 dict에서 사라짐앞으로 pop는 이런식으로 이해하면될듯. setdefault는 key,value를 주고key가 있으면 get,없으면 key,value로 생성 update는 {key : value} 를 주고있으면 value update,없으면 새로 생성data = {1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;}print(&quot;{0:10} : {1}&quot;.format(dict.fromkeys.__name__ , data.fromkeys(&quot;new&quot;, &quot;default&quot;)))data = {1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;}print(&quot;{0:10} : {1}&quot;.format(dict.get.__name__ , data.get(1)))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.keys.__name__ , data.keys()))print(&quot;{0:10} : {1}&quot;.format(dict.pop.__name__ , data.pop(2,&quot;err&quot;)))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.pop.__name__ , data.pop(2,&quot;err&quot;)))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))data = {1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;}print(&quot;{0:10} : {1}&quot;.format(dict.popitem.__name__ , data.popitem()))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.setdefault.__name__ , data.setdefault(1, &quot;default&quot;)))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.setdefault.__name__ , data.setdefault(3, &quot;default&quot;)))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.update.__name__ , data.update({1: &quot;newvalue1&quot;})))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))print(&quot;{0:10} : {1}&quot;.format(dict.update.__name__ , data.update({4: &quot;newvalue4&quot;})))print(&quot;{0:10} : {1}&quot;.format(dict.items.__name__ , data.items()))fromkeys : {&#39;n&#39;: &#39;default&#39;, &#39;e&#39;: &#39;default&#39;, &#39;w&#39;: &#39;default&#39;}get : value1items : dict_items([(1, &#39;value1&#39;), (2, &#39;value2&#39;), (3, &#39;value3&#39;)])keys : dict_keys([1, 2, 3])pop : value2items : dict_items([(1, &#39;value1&#39;), (3, &#39;value3&#39;)])pop : erritems : dict_items([(1, &#39;value1&#39;), (3, &#39;value3&#39;)])popitem : (3, &#39;value3&#39;)items : dict_items([(1, &#39;value1&#39;), (2, &#39;value2&#39;)])setdefault : value1items : dict_items([(1, &#39;value1&#39;), (2, &#39;value2&#39;)])setdefault : defaultitems : dict_items([(1, &#39;value1&#39;), (2, &#39;value2&#39;), (3, &#39;default&#39;)])update : Noneitems : dict_items([(1, &#39;newvalue1&#39;), (2, &#39;value2&#39;), (3, &#39;default&#39;)])update : Noneitems : dict_items([(1, &#39;newvalue1&#39;), (2, &#39;value2&#39;), (3, &#39;default&#39;), (4, &#39;newvalue4&#39;)]) 참고로 from pprint import pprint data = {1: (&quot;value1&quot;, &quot;string&quot;), 2: (&quot;value2&quot;, &quot;string&quot;), 3: (&quot;value3&quot;, &quot;string&quot;), 4: (&quot;value4&quot;, &quot;string&quot;), 5: (&quot;value5&quot;, &quot;string&quot;), 6: (&quot;value6&quot;, &quot;string&quot;) }print(1 in data) try: print(data[10])except KeyError: print(&quot;KeyError: 10&quot;) print(data)pprint(data) TrueKeyError: 10{1: (&#39;value1&#39;, &#39;string&#39;), 2: (&#39;value2&#39;, &#39;string&#39;), 3: (&#39;value3&#39;, &#39;string&#39;), 4: (&#39;value4&#39;, &#39;string&#39;), 5: (&#39;value5&#39;, &#39;string&#39;), 6: (&#39;value6&#39;, &#39;string&#39;)}{1: (&#39;value1&#39;, &#39;string&#39;), 2: (&#39;value2&#39;, &#39;string&#39;), 3: (&#39;value3&#39;, &#39;string&#39;), 4: (&#39;value4&#39;, &#39;string&#39;), 5: (&#39;value5&#39;, &#39;string&#39;), 6: (&#39;value6&#39;, &#39;string&#39;)} in을 사용해 key가 사용중인지 확인할 수 있음 dic.get(key), dic[key]를 사용해value를 찾을 수 있는데dic[key]는 key가 없는경우 exception,dic.get(key)는 None로 알려주는데 이 경우default값을 지정해 줄 수 있음 dict구조가 좀 복잡해지면pprint로 출력하면 좀 정리해줌 tuple update, insert가 안되는 list ( )로 선언 슬라이싱 조회가능 list 보다 빠르다함 name discription count 해당 elmt 개수 index 해당 elmt 위치 data = (1, 2, 3, 4, 5, 6, 7, 8, 9, 9)print(data)print(&quot;{0:10} : {1}&quot;.format(tuple.count.__name__, data.count(9)))print(&quot;{0:10} : {1}&quot;.format(tuple.index.__name__, data.index(9)))print(data[1:5])set 중복안됨, 순서없음 set랑 dict랑 뜯어보면 다르겠지만 둘 다 순서가 없고 중복이 없는게 같음. { }로 선언. 좀 특이한점은 집합처럼 연산이 가능인줄알았는데 애초에 이 목적인듯함. name discription add   copy   difference 차집합 difference_update 차집합으로 update discard 삭제 intersection 교집합 intersection_update 교집합으로 update isdisjoint 교집합의 여집합 여부 issubset 하위집합 issuperset 상위집합 remove 삭제 symmetric_difference 교집합의 여집합 symmetric_difference_update 교집합의 여집합으로 update union 합집합 update 합집합으로 update data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(data1, data2)print(&quot;{0:30} : {1}&quot;.format(set.difference.__name__, data1.difference(data2)))print(&quot;{0:30} : {1}&quot;.format(set.difference_update.__name__, data1.difference_update(data2)))data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.discard.__name__, data1.discard(1)))print(data1, data2)data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.intersection.__name__, data1.intersection(data2)))print(&quot;{0:30} : {1}&quot;.format(set.intersection_update.__name__, data1.intersection_update(data2)))print(data1, data2)data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.isdisjoint.__name__, data1.isdisjoint(data2)))print(data1, data2)data1 = {1, 2, 3, 4, 5}data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.issubset.__name__, data2.issubset(data1)))print(&quot;{0:30} : {1}&quot;.format(set.issuperset.__name__, data1.issuperset(data2)))data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.symmetric_difference.__name__, data1.symmetric_difference(data2)))print(&quot;{0:30} : {1}&quot;.format(set.symmetric_difference_update.__name__, data1.symmetric_difference_update(data2)))data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.union.__name__, data1.union(data2)))print(data1, data2)data1 = {1, 1, 2, 2, 3, 3, }data2 = {3, 4, 5}print(&quot;{0:30} : {1}&quot;.format(set.update.__name__, data1.update(data2)))print(data1, data2){1, 2, 3} {3, 4, 5}difference : {1, 2}difference_update : Nonediscard : None{2, 3} {3, 4, 5}intersection : {3}intersection_update : None{3} {3, 4, 5}isdisjoint : False{1, 2, 3} {3, 4, 5}issubset : Trueissuperset : Truesymmetric_difference : {1, 2, 4, 5}symmetric_difference_update : Noneunion : {1, 2, 3, 4, 5}{1, 2, 3} {3, 4, 5}update : None{1, 2, 3, 4, 5} {3, 4, 5}frozenset frozenset은 immutableset은 mutable 다시말해, frozenset는 수정이 안됨. 이 차이 외에는 set이랑 같음bytes binary를 조작하기위해 사용. 0x00부터 0xff까지 사용 이 class안에 method는 string랑 같은게 대다수라 생략함.그 외 특징적인것만.생성from pprint import pprint# byte(dec sequence)b = bytes([72, 101, 108, 108, 111])print(b)# byte(hex sequence)b = bytes([0x48, 0x65, 0x6c, 0x6c, 0x6f])print(b)# byte(string sequence)b = bytes(&quot;Hello&quot;, encoding=&quot;utf-8&quot;)print(b)# byte(len)# 이 경우 0x00으로b = bytes(5)print(b)# byte(range)b = bytes(range(0, 256))pprint(b)# byte.fromhex(hexstring)b = bytes.fromhex(&#39;2Ef0 F120f2 &#39;)print(b)b&#39;Hello&#39;b&#39;Hello&#39;b&#39;Hello&#39;b&#39;\\x00\\x00\\x00\\x00\\x00&#39;(b&#39;\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13&#39; b&#39;\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !&quot;#$%&amp;amp;\\&#39;()*+,-./01234567&#39; b&#39;89:;&amp;lt;=&amp;gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f&#39; b&#39;\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f&#39; b&#39;\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f&#39; b&#39;\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf&#39; b&#39;\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf&#39; b&#39;\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf&#39; b&#39;\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf&#39; b&#39;\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef&#39; b&#39;\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff&#39;)b&#39;.\\xf0\\xf1 \\xf2&#39; ascii에서 맞는게 있으면 그걸로 보임 fromhex는 str로 된 byte형식을bytes로 반환.&#39; &#39;는 무시됨.hex그대로 출력 ascii로 변환 안할 때(str) # byte(range)b = bytes(range(0, 256))pprint(b.hex(&#39;-&#39;)) &#39;00-01-02-03-04-05-06-07-08-09-0a-0b-0c-0d-0e-0f-10-11-12-13-14-15-16-17-18-19-1a-1b-1c-1d-1e-1f-20-21-22-23-24-25-26-27-28-29-2a-2b-2c-2d-2e-2f-30-31-32-33-34-35-36-37-38-39-3a-3b-3c-3d-3e-3f-40-41-42-43-44-45-46-47-48-49-4a-4b-4c-4d-4e-4f-50-51-52-53-54-55-56-57-58-59-5a-5b-5c-5d-5e-5f-60-61-62-63-64-65-66-67-68-69-6a-6b-6c-6d-6e-6f-70-71-72-73-74-75-76-77-78-79-7a-7b-7c-7d-7e-7f-80-81-82-83-84-85-86-87-88-89-8a-8b-8c-8d-8e-8f-90-91-92-93-94-95-96-97-98-99-9a-9b-9c-9d-9e-9f-a0-a1-a2-a3-a4-a5-a6-a7-a8-a9-aa-ab-ac-ad-ae-af-b0-b1-b2-b3-b4-b5-b6-b7-b8-b9-ba-bb-bc-bd-be-bf-c0-c1-c2-c3-c4-c5-c6-c7-c8-c9-ca-cb-cc-cd-ce-cf-d0-d1-d2-d3-d4-d5-d6-d7-d8-d9-da-db-dc-dd-de-df-e0-e1-e2-e3-e4-e5-e6-e7-e8-e9-ea-eb-ec-ed-ee-ef-f0-f1-f2-f3-f4-f5-f6-f7-f8-f9-fa-fb-fc-fd-fe-ff&#39; hex()안에sep를 선택적으로 넣을 수 있다.단, 한글자. string 변환# 1str_original = &#39;Hello&#39;bytes_encoded = str_original.encode(encoding=&#39;utf-8&#39;)print(type(bytes_encoded))str_decoded = bytes_encoded.decode()print(type(str_decoded))print(&#39;Encoded bytes =&#39;, bytes_encoded)print(&#39;Decoded String =&#39;, str_decoded)print(&#39;str_original equals str_decoded =&#39;, str_original == str_decoded)# 2print(str(bytes_encoded, encoding=&#39;utf-8&#39;))&amp;lt;class &#39;bytes&#39;&amp;gt;&amp;lt;class &#39;str&#39;&amp;gt;Encoded bytes = b&#39;Hello&#39;Decoded String = Hellostr_original equals str_decoded = TrueHello string랑 변환할 떄. str로 표현 안되는건 exception으로 끝남 1처럼 decode / encode 또는2처럼 형변환. 변환 기본은 utf-8bytearray 위랑 같음 차이점은 bytes는 변경 불가 bytearray는 변경가능 예를들면 # 1 b = bytearray(5) print(b) b[1] = 0xff print(b) # 2 b = bytes(5) print(b) b[1] = 0xff print(b) bytearray(b&#39;\\x00\\x00\\x00\\x00\\x00&#39;) bytearray(b&#39;\\x00\\xff\\x00\\x00\\x00&#39;) b&#39;\\x00\\x00\\x00\\x00\\x00&#39; Traceback (most recent call last): File , line 11, in &amp;lt;module&amp;gt; b[1] = 0xff TypeError: &#39;bytes&#39; object does not support item assignment memoryview 일단 설명은memoryview 객체는 파이썬 코드가버퍼 프로토콜을 지원하는 객체의내부 데이터에 복사 없이 접근할 수 있게 합니다. 설명만 보면, 이걸 쓸 수 있는상황은버퍼 프로토콜을 지원하는 개체에서만 이고,쓰는 이유는 ‘복사없이’를 보면속도때문으로 보임. 버퍼 프로토콜을 지원하는 내장 객체에는bytes 와 bytearray 가 있다. indexing, slicing가능. v = memoryview(b&#39;abcefg&#39;) print(v) print(v[1]) print(v[-1]) print(v[1:4]) print(v.readonly) 98 103 &amp;lt;memory at 0x0172B9E8&amp;gt; True 위 경우 readonly = true때문에수정은 못하는데 b = bytearray(b&#39;abcefg&#39;) v = memoryview(b) print(v.readonly) v[0] = ord(&#39;X&#39;) print(b) False bytearray(b&#39;Xbcefg&#39;) 이 경우가 되는거보면 위에는 bytes로 일단 만들어진듯. 자료구조의 변경temp = {1,2,3}print(temp, type(temp))temp = list(temp)print(temp, type(temp))temp = tuple(temp)print(temp, type(temp))temp = dict.fromkeys(temp)print(temp, type(temp))temp = set(temp)print(temp, type(temp))temp = frozenset(temp)print(temp, type(temp))temp = bytes(temp)print(temp, type(temp))temp = bytearray(temp)print(temp, type(temp))# temp = memoryview(temp)# print(temp, type(temp))# temp = str(temp)# print(temp, type(temp))temp = list(temp)print(temp, type(temp)){1, 2, 3} &amp;lt;class &#39;set&#39;&amp;gt;[1, 2, 3] &amp;lt;class &#39;list&#39;&amp;gt;(1, 2, 3) &amp;lt;class &#39;tuple&#39;&amp;gt;{1: None, 2: None, 3: None} &amp;lt;class &#39;dict&#39;&amp;gt;{1, 2, 3} &amp;lt;class &#39;set&#39;&amp;gt;frozenset({1, 2, 3}) &amp;lt;class &#39;frozenset&#39;&amp;gt;b&#39;\\x01\\x02\\x03&#39; &amp;lt;class &#39;bytes&#39;&amp;gt;bytearray(b&#39;\\x01\\x02\\x03&#39;) &amp;lt;class &#39;bytearray&#39;&amp;gt;[1, 2, 3] &amp;lt;class &#39;list&#39;&amp;gt; 호환도 됨 주석부분 끼면 암튼 달라져서 일단 뺌Call by list를 보면, .copy()를 써서 전달헀는데보통 넘기는 방식들은 value가 넘어가는데여기 쓴애들은 reference가 넘어가는것같다." }, { "title": "WSL", "url": "/posts/Stub_WSL/", "categories": "Grind, Stub", "tags": "wsl, linux, zsh", "date": "2022-05-04 12:00:00 +0900", "snippet": "Windows Subsystem for Linux 무친기능. window에서 linux를 쓸수 있게됨 1,2가 있는데 2로. gui까지 가능하다는데그것까진 ㄴㄴ 개같은 vm안써도됨. docker에 대충 설명됨 Install Linux용 Windows 하위 시스템 사용 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart window update 20H1? 이상인가?암튼 업데이트 풀매수 Virtual Machine 기능 사용 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart Linux 커널 업데이트 패키지 다운로드 이 단계는 linux 설치 이후에 해야될수도 있음 아래 둘 중 하나 하면됨 같은거임. x64 머신용 최신 WSL2 Linux 커널 업데이트 패키지(DL) 이전 버전 WSL의 수동 설치 단계(설명서) 4단계에 있음. wsl 기본 버전 설정(아래 명령으로) ms store에서 linux 설치 여기 종류 많음. 알아서. 여기서 설치가 끝난게 아니라 이상태로 한번 linux를 실행해야 실제로 설치가 시작됨. 참고 순서가 1-2-3-4-5-6 1-2-3-6-4-5 이 둘 중 하나또는 상관없거나. 뭐가 안된다 싶으면 reboot window terminal 쓰면 편함 이것도 ms store에 wsl 명령 wsl --set-default-version 2 기본 버전 설정 wsl -l -v 리스트, 버전 wsl --set-version Ubuntu-xx.xx 2 버전 1로 뜨는거 2로 바꿀 때 wsl -t Ubuntu-xx.xx 종료 wsl --shutdown 전체 재시작 linux ubuntu 기준으로함.걍 넘겼다가 나중에 찾게되는것들 sudo passwd su pwsswd일껄? sudo apt update sudo apt upgrade sudo apt install gcc gdb make cmake ninja(-build) build-essential zsh(아래)필요할때만 autoconf arm cross compiler $ sudo apt update$ sudo apt upgrade$ sudo apt install libc6-armel-cross libc6-dev-armel-cross$ sudo apt install binutils-arm-linux-gnueabi$ sudo apt install libncurses5-dev $ sudo apt install gcc-arm-linux-gnueabihf$ sudo apt install g++-arm-linux-gnueabihf https://rottk.tistory.com/entry/CC-개발환경-설정-Xubuntu-1804 zsh 이쁘다. 기본shell은 안이쁘다 git를 쓸때 이거 없으면 특히 불편함. 오타나 대소문 구분좀 유연하게 도와주는듯? 삶의 질이 달라진다. 설치 sudo apt install zsh 암꺼나 선택(맨아래?) sh -c &quot;$(wget [https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh](https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh) -O -)&quot; sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 전에는 설치하면 기본 shell을 바꿔줘야되던걸로 기억하는데언젠가부터 알아서 함. 테마 ~/.zshrc에 ZSH_THEME=”robbyrussell” 변경 themes jonathan 이거씀. 이쁘고, 명령 구분좋고 " }, { "title": "Python 7 - Method", "url": "/posts/Python_7_Method/", "categories": "Grind, Python", "tags": "python, method, function", "date": "2022-05-04 00:00:00 +0900", "snippet": " 이거 전에 Concept 참고.Method python에서는method, function둘 다 사용.# def name(params):# statement# return ...def temp(param1, param2): print(param1, param2) return param1 + param2, param1 - param2, [param1, param2]plus, minus, listnum = temp(1, 2)print(temp(1, 2))1 21 2(3, -1, [1, 2]) return은 함수 원형에 적지 않음.내부에서 return으로 퉁침. return은 다수가 될 수 있음.각각은 ,로 구분함. print는 항상 알아서 다 해주는듯. default value는 param=value로 해주면 됨 위에서는def temp(param1, param2=17):이런식. parameter 전달 시 이름을 써줄 수 있는데이렇게 하면 순서가 상관 없어짐 예를들어,temp(param2=1, param1=2)를 하면1,2가 순서가 아닌 맞는 param으로 들어감.출력하면 (3, 1, [2, 1])로.Variadic Args 변수 타입을 정하지 않는다는건 def temp1(param): # for i in param: print(&quot;{0}&quot;, param) if type(param) == &#39;int&#39;: print(&#39;int&#39;) else: print(&#39;other&#39;) temp1(1)temp1([1,2,3]) 1other[1, 2, 3]other 이런식으로 뭐가 들어가도 상관없긴함 다만 안에 for문이 들어가면그때부터 param은 collection으로 무조건쓰인다. parameter를 가변으로 하려면*을 써서 표시한다. def temp(*params): for i in params: print(i, end=&#39; &#39;) print() temp(1, 2, 3, 4, 5) temp(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) temp(1) &amp;lt;class &#39;tuple&#39;&amp;gt; 1 2 3 4 5 &amp;lt;class &#39;tuple&#39;&amp;gt; a b c &amp;lt;class &#39;tuple&#39;&amp;gt; 1 나열해서 전달한 args는 함수 내부에서 tuple로 바뀜 이건 args가 하나일때도 동일 섞어서도 쓸 수 있는데 이때 가변 args은 생략 가능 def temp(default, *params): print(type(default), type(params)) for i in params: print(&quot;{0} : {1}&quot;.format(default,i)) temp(1, 2, 3, 4, 5)temp(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)temp(1) &amp;lt;class &#39;int&#39;&amp;gt; &amp;lt;class &#39;tuple&#39;&amp;gt;1 : 21 : 31 : 41 : 5&amp;lt;class &#39;str&#39;&amp;gt; &amp;lt;class &#39;tuple&#39;&amp;gt;a : ba : c&amp;lt;class &#39;int&#39;&amp;gt; &amp;lt;class &#39;tuple&#39;&amp;gt; Keyword Args 위경우 *args로 들어온 값들은tuple형식으로 받을 수 있었다. 이 경우는 dict로.def temp(**kwargs): return kwargsd = temp(a=1, b=2)print(type(d))print(d)&amp;lt;class &#39;dict&#39;&amp;gt;{&#39;a&#39;: 1, &#39;b&#39;: 2} *args랑 **kwargs가같이 쓸만한데가 뭐가있나 싶었는데대충 이런식으로 쓰지 않을까 싶다 def customPrint(*args, **kwargs): sep = &#39; &#39; end = &#39;\\n&#39; res = &quot;&quot; if &quot;sep&quot; in kwargs: sep = kwargs.get(&quot;sep&quot;) if &quot;end&quot; in kwargs: end = kwargs.get(&quot;end&quot;) for i in args: res += str(i) + sep if len(args) &amp;gt; 0: l = list(res) l.pop() res = &quot;&quot;.join(l) res += end return res print(customPrint(1, 2, 3, sep=&#39;-&#39;, end=&#39;^^&#39;)) print(customPrint(1, 2, 3)) 1-2-3^^1 2 3 variable scope 여기도 여전히 전역변수, 지역변수 구분var = 1def temp(arg): global var var = 2 return varvar2 = temp(var)print(var)print(var2)22 이런식으로 global을 사용해전역변수처럼 만들수도 있음 위경우 외부에 있는 var로 맞췄는데그건 딱히 상관없는것같음. 다시말해 함수안에 global로 선언된 변수는함수 밖에서도 호출 가능.lambda lambda를 사용해 무명함수를 만들 수 있음# lambda [input] : [return]a = (lambda x : x**x)(3)print(a)f = lambda x : x**xprint(f(2)) input는 상관없는데 return 은 하나만 된다함. 아무튼. 여기도 이벤트나일회성으로 쓸떄 쓰는가봄. 같은 input로 여러 연산을 할 경우 l = [ lambda x: x ** x, lambda x: x * 100, lambda x: str(x) + &quot;!&quot; ] for i in l: print(i(3)) 273003! 라던가, 특정 method는 별개의 method가 필요한데 sorted target = [ &#39;baa &#39;,&#39;a&#39;, &#39; asdf &#39;, &#39; ba&#39;]print(sorted(target, key=lambda x : len(x.strip()))) [&#39;a&#39;, &#39; ba&#39;, &#39;baa &#39;, &#39; asdf &#39;] target의 각 item을 lambda로 새로 계산하고결과를 기준으로 새로 정렬됨. filter a = filter(lambda x: x % 2, range(10))print(list(a))# def mtd(x):# if x % 2 == 0:# return False# else:# return True# a = filter(mtd, range(10))# print(list(a)) [1, 3, 5, 7, 9] lambda 안쓰는경우 주석처럼됨. function에 true인 item만 return map a = [1, 2, 3, 4, 5]f = lambda x : x*2res = map(f,a)print(list(res)) [2,4,6,8,10] 각 item에 function 적용 후 return " }, { "title": "Concept", "url": "/posts/Stub_Concept/", "categories": "Grind, Stub", "tags": "method, function, argument, parameter, statement, expression", "date": "2022-05-03 00:00:00 +0900", "snippet": " python 쓰다가 갑자기 궁금해서 찾았는데거기쓰긴 좀더 넓은 의미로 알아뒀음해서 옮김Method / Function name discription Function 실행 가능한 코드 조각 Method class안에 있는 function Argument / Parameter name discription Parameter 함수에 정의된 입력 변수명 Argument Parameter에 넘긴 실제 값 def test(number, string):에서number, string가 parameter res = test(1, &quot;start&quot;)에서1, “start”가 argumentStatement / Expression name discription Expression 특정 값으로 표현될 수 있는 코드 Statement 실행 가능한 독립적인 코드조각 Statement ≥ Expression 요런관계# Expressiona = 3 * 6 # Expression 이면서 Statementb = a # Statementwhile True: passif True: passdef b() : pass 그래도 좀 애매한데값에대한 평가가 들어가면 expression으로 하고그걸 포함한 실행가능한 코드면 statement로? …" }, { "title": "Python 6 - Control Flow", "url": "/posts/Python_6_ControlFlow/", "categories": "Grind, Python", "tags": "python, control flow", "date": "2022-04-28 00:00:00 +0900", "snippet": "if 조건문 근본# if [condition] :# statement # elif [condition] :# statement# else :# statementsomeCondition = 1024if someCondition == 0: print(&quot;0&quot;)elif someCondition &amp;gt; 0 and someCondition &amp;lt;= 1024: print(&quot; &amp;lt; 1k&quot;)elif someCondition &amp;gt; 1024 and someCondition &amp;lt;= 2048: print(&quot; &amp;lt; 2k&quot;)else : print(&quot;over 2k&quot;) python에는 switch가 없다고 한다.for# for [item] in [Collection]:# statementfor temp in range(0,101,10): print(&quot;temp =&quot;, temp) collection요소를 item으로. foreach(type item in collection)이랑 비슷한듯.하긴 type 적을 필요가 없으니그렇게 생각하면 똑같음. 근데 따지면 모든 item을다 검색하는 방법밖에 없는거아님?oldIndex = range(1, 10)def temp(x): return x*xnewIndex = [temp(i) for i in oldIndex]print(newIndex)result = [num * 3 for num in oldIndex if num % 2 == 0]print(result) 이렇게 쓰는것도 됨… ㅁ7..while# while [Condition]:# statementindex = 10while index &amp;gt; 0: print(index) index -= 1index = 0while True: index += 1 if index % 2 != 0: continue print(index) if index == 10: break continue , break, if 등등.. 막상 { }가 없으니까 좀…" }, { "title": "Python 5 - IO", "url": "/posts/Python_5_IO/", "categories": "Grind, Python", "tags": "python, io", "date": "2022-04-27 00:00:00 +0900", "snippet": "Input input() 으로 해결data = input()print(data)data = input(&quot;only numeric\\n&quot;)print(type(data))print(data)asdfasdfonly numeric1234&amp;lt;class &#39;str&#39;&amp;gt;1234 input으로 받는데input에 필요한 문구를 넣을 수 있음 input에 뭐가 들어가던string로 받을 수 있음Output 출력은 print()로 한다. 지금까지 뭘 하던 결과볼때 쓰던건데안에 출력하고 싶은걸 쓰는데출력은 생각보다 알아서 잘 해준다. 예를들어 List&amp;lt;int&amp;gt; numbers = new List&amp;lt;int&amp;gt; { 1, 2, 3, 4, 5 };Console.WriteLine(numbers); // System.Collections.Generic.List`1[System.Int32] numbers = [1, 2, 3, 4, 5]print(numbers) # [1, 2, 3, 4, 5] 이런경우 특히.이거 외에도 저런 구조회된 데이터를 볼 때별다른 작업 없이도 알아서 해준것같음. 출력할 parameter가 둘 이상인 경우몇가지 방법이 있는데, , +, 이어붙이기 정도 b = &quot;str&quot;c = 2 print(b + &quot;문자, 수&quot; + str(c))print(b, &quot;문자, 수&quot;, c)print(&quot;basdf&quot;&quot;text&quot;) str문자, 수2str 문자, 수 2basdftext +의 경우string만 됨. ,의 경우그냥 나열하는 느낌?type는 상관없음. &quot; &quot;를 나열하는 경우는&quot; &quot;끼리만 됨 sep, end, … 지금까지 출력할 때 쓴 print는 ,로 나열한 경우실제 출력에서 &#39; &#39;(whitespace)가하나씩 붙어있는게 보인다. 또, print는 무조건 한줄을 사용한다.C#은 Console.WriteLine();과Console.Write();이 다른데 출력라인 끝에 \\n의 유뮤 차이. print에서 sep, end를 명시해이런 출력을 다르게 할 수 있음 print(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;)print(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;, sep=&quot; ! &quot;) print(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;, end=&quot;&quot;)print(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;, end=&quot;^^&quot;) str1 str2 str3str1 ! str2 ! str3str1 str2 str3str1 str2 str3^^ sep는 string끼리 연결 관련,end는 print 끝 관련. stdxxx import sysprint(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;, file=sys.stderr)print(&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;, file=sys.stdout) str1 str2 str3str1 str2 str3 몰?루 stdout는 걍 출력, stderr은 에러. 정확치는 않은데 log level같은 개념인것같음. 아무튼, 이게 들어는 위치가 file=하고 쓰는데여기는 파일 출력할때 씀.이건 뒤에서. print 툴팁을 다시 보면print(value, ..., sep=&#39; &#39;, end=&#39;\\n&#39;, file=sys.stdout, flush=False) 이런걸 볼 수 있는데sep, end, file, flush로 어지간한 출력은 다 끝내는듯하다. 출력포맷# 10개 자릿수, 빈공간, 오른정렬print(&quot;{0: &amp;gt;10}&quot;.format(50000000000000))print(&quot;{0: &amp;gt;10}&quot;.format(500))# 10개 자릿수, 빈공간에 문자, 왼정렬print(&quot;{0:*&amp;lt;10}&quot;.format(500))# 음,양 표시print(&quot;{0: &amp;gt;+10}&quot;.format(500))print(&quot;{0: &amp;gt;-10}&quot;.format(-500))# 소수점 자리수print(&quot;{0: &amp;gt;10.2f}&quot;.format(500.486260))50000000000000 500500******* +500 -500 500.49 전 포스팅에서 string - format 내용 중{}.format()에 변경하는 방식인데{[arg]:[empty str][sort][+-][num len][num format]} 위부터 내려오면서 보면 알겠지만,하나하나 조합하면 계속 더 복잡하게 만들 수 있음.&quot;{0:-&amp;lt;+20.4f,}&quot; 이런식으로.. 소수점은 다음 자리에서 반올림.위 같은 경우 3자리서 반올림. 글자 자릿수같은 경우 넘으면 그냥 출력해주고자릿수를 충족하지 못하는경우의 조건인듯하다.파일 입출력test = open(&quot;test.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)test.write(&quot;Hello World&quot;)test.close()test = open(&quot;test.txt&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;)test.write(&quot;\\\\nHello python&quot;)test.close()test = open(&quot;test.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)print(test.read())test.close()test = open(&quot;test.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;)for line in test.readlines(): print(line)test.close() 뭔가 간편해보임……. w,a,r 사용방법. w : write. 생성. 이미 있는경우에도 새로 생성하는듯. a : append. 아래 이어서 써줌. 파일이 없으면 생성. r : read. 읽음. 읽는 방법은 크게 3가지 read() : 파일 전체를 str로 읽어옴. readLine() : 한 줄 읽어옴while로 파일 끝까지 읽을 수 있음. readLines() : 파일 전체를list[str]로 읽어옴. 위 세개 방법에 또 세부 옵션이 있음.몇줄 읽기 등등. pickle 데이터를 파일형태로 다루기 위해 사용정도로 알고있었는데 객체 구조의 직렬화와 역 직렬화를 위한 바이너리 프로토콜을 구현합니다.를 시작으로 설명이 좀 길게 나옴 다 빼고 간단하게 쓰는데나머지는 필요하면 나중에 추가.Writeimport picklepickle_test1 = open(&#39;test.pkl&#39;, &#39;wb&#39;)tempData1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]pickle.dump(tempData1, pickle_test1)pickle_test1.close() 동작에(wb) b가 꼭 붙어야함 binary래. 쓰는건 dump.Readpickle_test2 = open(&#39;test.pkl&#39;, &#39;rb&#39;)tempData2 = pickle.load(pickle_test2)print(tempData2)pickle_test2.close() 위에서 쓴 pickle파일을 읽는방법. 여기도 동작에 b를 꼭 붙인다함. load로 읽어옴.withwith open(&#39;test.pkl&#39;, &#39;wb&#39;) as pickle_test3: tempData3 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] pickle.dump(tempData3, pickle_test3)with open(&#39;test.pkl&#39;, &#39;rb&#39;) as pickle_test4: tempData4 = pickle.load(pickle_test4) print(tempData4) pickle에 쓴 예문을 with과 함께 다시 쓴것. using(~~)랑 비슷한듯. with 문단이 끝나면 close가 자동으로 된다함이건 pickle가 아닌 일반 파일에도 적용됨." }, { "title": "dict", "url": "/posts/Python_dict/", "categories": "Grind, Python", "tags": "python, data type, dict", "date": "2022-04-26 00:00:00 +0900", "snippet": "Init mapping - mutablemapping 계통으로하위 type으로 dict가 유일함. key, value, item으로 구성되며 {key : value} 쌍이 기본 구조이고이 쌍을 item이라 함. 변경가능한 hash table 구조이며 hash가능하지 않은값으로mutable은 key로 사용할 수 없음. 괄호는 { } __init__은__init__(self, **kwargs)__init__(self, map, **kwargs)__init__(self, iterable, **kwargs)이렇게 있다.해서 dict를 만들수 있는 방법은 기본적으로 a = dict()b = {} 이렇게 빈 dict를 만들 수 있음.그 외 방법으로는 a = dict(one=1, two=2, three=3)b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})f = dict({&#39;one&#39;: 1, &#39;three&#39;: 3}, two=2) 이 때a == b == c == d == e == f는 True. dict의 동등비교(==)는내부 순서가 상관없음 &amp;lt;, &amp;lt;=, &amp;gt;=, &amp;gt;등의 비교는 TypeError insert는 순서상 가장 뒤에 추가되며3.7이상에서 이 순서를 보장함.value에 대한 update는순서에 영향 없음. reversed는 3.8이상.Method     list(dict)[^footnote1] dict.items()[^footnote] len(dict)[^footnote] dict.keys()[^footnote] dict[key][^footnote] dict.pop(key[, default])[^footnote] dict[key]=value[^footnote] dict.popitem()[^footnote] del dict[key] reversed(dict)[^footnote] key (not) in dict[^footnote] dict.setdefauilt(key[, default])[^footnote] iter(dict)[^footnote] dict.update([other])[^footnote] dict.clear()[^footnote] dict.values()[^footnote] dict.copy()[^footnote] dict | other[^footnote] fromkeys(iterable, [, value])[^footnote] dict |= oather[^footnote] dict.get(key[, default])[^footnote]   list(dict) list로 type cast된 새 list반환. key만 반영됨data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})test = list(data)print(test)[1,2,3]len(dict) dict의 item의 수data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})print(len(data))3dict[key] key에 해당하는 value를 반환. key가 없으면 KeyErrordata = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})print(data[1])print(data[4])KeyError: 4value1 dict를 상속받고__missing__를 정의하면KeyError 문제를 해결할 수 있음.dict[key] = value dict[key] 를 value 로 설정 이미 key가 있으면 update,없으면 insertdata = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})data[1] = Truedata[4] = &quot;new value&quot;print(data){1: True, 2: &#39;value2&#39;, 3: &#39;value3&#39;, 4: &#39;new value&#39;}del dict[key] key에 해당하는 item삭제key가 없으면 KeyErrordata = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})del data[1]print(data){2: &#39;value2&#39;, 3: &#39;value3&#39;}key (not) in dict dict에 key가 있으면 True(False)없으면 False(True).iter(dict) key에 대한 iterator 반환, same as iter(d.keys())dict.clear() dict의 모든 item삭제dict.copy() dict의 얕은복사fromkeys(iterable, [, value]) iterable을 key로 하고 value를 갖는 새 dict를 반환.k = [1, 2, 3]v = [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;]ndata = dict.fromkeys(k,v)print(ndata)ndata[3] = 3print(ndata){1: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 2: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 3: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;]}{1: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 2: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 3: 3} value를 지정하지 않을수있음그럴경우 None parameter로 전달한 value는단일 instance로 취급하고 새 dict의 모든 value가 됨.위의 결과가{1: &#39;v1&#39;, 2: &#39;v2&#39;, 3: &#39;v3&#39;]}이아닌것처럼. 또한 parameter로 전달한value를dict 생성 이후에 수정하면해당 value참조가 전부 바뀜 k = [1, 2, 3]v = [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;]ndata = dict.fromkeys(k,v)print(ndata)v[2] = 123print(ndata) {1: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 2: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;], 3: [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;]}{1: [&#39;v1&#39;, &#39;v2&#39;, 123], 2: [&#39;v1&#39;, &#39;v2&#39;, 123], 3: [&#39;v1&#39;, &#39;v2&#39;, 123]} 이런 비슷한 문제는type inheritance에 쓴적있음. dict.get(key [, default]) key에 해당하는 value반환.data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})print(data.get(3))print(data.get(4, &quot;empty value&quot;))value3empty value key가 없을 경우 None를 반환이 경우에 대한 반환값은 변경 가능. dict[key]와 다르게 KeyError가 없음.dict.items() dict의 item view를 반환.data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})print(data.items())dict_items([(1, &#39;value1&#39;), (2, &#39;value2&#39;), (3, &#39;value3&#39;)]) for에서 자주씀.for item in dict:가 안되서for k, v in data.items():dict.keys() dict의 key view를 반환.dict.pop(key [, default]) key에 해당하는 value반환.print(data.pop(4, None))None key가 없으면 KeyError인데default를 지정하면KeyError없이 지정된 default를 반환dict.popitem() 위 기능을 LIFO로 실행함.LIFO순서 보장은 3.7이상 dict가 비어있으면 KeyErrorreversed(dict) key에 대해 reversed iterator 반환. same as reversed(d.keys()) iter의 반대dict.setdefault(key [, default]) key가 있으면 해당 value반환 없으면 key insert하고해당 value를 default로 설정후default를 반환. default를 지정하지 않을수 있고그럴경우 None.data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})print(data.setdefault(3, 3))print(data.setdefault(4, &quot;val 4&quot;))print(data)value3val 4{1: &#39;value1&#39;, 2: &#39;value2&#39;, 3: &#39;value3&#39;, 4: &#39;val 4&#39;}dict.update([other]) other의 key/value쌍으로 update. 기존 key를 덮어쓰며 None를 반환. other에 들어갈 형식은dict생성방법과 동일해야함. key가 있으면 update,key가 없으면 insertdata = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})data.update({1:&quot;updated&quot;, 4:&quot;new 4&quot;})print(data){1: &#39;updated&#39;, 2: &#39;value2&#39;, 3: &#39;value3&#39;, 4: &#39;new 4&#39;}dict.values() dict의 value view반환. view끼리 eq비교는 항상 False print(data.values() == data.values()) False dict | other dict와 other을 합친 새 dict반환. dict, other은 dict type이어야함. 둘 다 같은키를 갖는다면other의 value를 사용.data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})other = dict({3:3, &quot;value 4&quot;: 4, &quot;value 5&quot;: 5})print(data | other)data = dict({1: &quot;value1&quot;, 2: &quot;value2&quot;, 3: &quot;value3&quot;})other = dict({3:3, &quot;value 4&quot;: 4, &quot;value 5&quot;: 5})print(data | other)dict |= other other을 이용해dict를 update함위는 새 dict반환이면이건 dict update. other은 key/value쌍의 mapping 또는 iterable일 수 있음.Dictionary view objects 위에 한번씩 나왔지만dict.keys(), dict.values(),dict.items()는각각의 view object를 반환함. 이 new object들은 동적으로dict의 변경이 항상 반영됨. 지원하는 method로는len, iter, in, reversed,dictview.mapping이 있음.dict의 method에서이름이 같으면 같은기능. dictview.mapping의 경우view의 원본 dict를 감싸는types.MappingProxyType을 반환.3.10이상 지원. key view는 항목이 고유하고hash가능하기 때문에 set과 유사. 모든 value가 hash 가능하여(key, value) 쌍이 고유하다면item view도 set과 유사. value view는 일반적으로항목이 고유하지 않으므로set과 유사하게 취급되지 않음. 집합형 뷰의 경우collections.abc.Set에 대해 정의된모든 연산을 사용 가능.예를들어 ==, &amp;lt;, ^ view 사용 예 dishes = {&#39;eggs&#39;: 2, &#39;sausage&#39;: 1, &#39;bacon&#39;: 1, &#39;spam&#39;: 500}keys = dishes.keys()values = dishes.values() # iterationn = 0for val in values: n += valprint(n) # keys and values are iterated over in the same order (insertion order)print(list(keys)) print(list(values)) # view objects are dynamic and reflect dict changesdel dishes[&#39;eggs&#39;]del dishes[&#39;sausage&#39;]print(list(keys)) # set operationsprint(keys &amp;amp; {&#39;eggs&#39;, &#39;bacon&#39;, &#39;salad&#39;}) print(keys ^ {&#39;sausage&#39;, &#39;juice&#39;}) # # get back a read-only proxy for the original dictionary# values.mapping## values.mapping[&#39;spam&#39;] 504[&#39;eggs&#39;, &#39;sausage&#39;, &#39;bacon&#39;, &#39;spam&#39;][2, 1, 1, 500][&#39;bacon&#39;, &#39;spam&#39;]{&#39;bacon&#39;}{&#39;spam&#39;, &#39;bacon&#39;, &#39;sausage&#39;, &#39;juice&#39;} " }, { "title": "Type Inheritance", "url": "/posts/Python_Type_Inheritance/", "categories": "Grind, Python", "tags": "python, data type", "date": "2022-04-25 00:00:00 +0900", "snippet": "Init 여기 쓸 내용이 정확한지,쓸만한 내용인지 모르겠음.. int, float, complex, None은 상속관계가 없다. bool은 int의 subclass. 그 외 나머지 type인dict, str, memoryview,tuple, list, bytes,bytearray, set, frozenset은Iterable에서 파생한다. ─ Iterable └─ Collection ├─ Mapping │ └─ MutableMapping │ └─ dict ├─ Sequence │ ├─ str │ ├─ memoryview │ ├─ tuple │ ├─ MutableSequence │ │ └─ list │ ├─ ByteString │ │ └─ bytes │ └─ MutableSequence, ByteString │ └─ bytearray └─ AbstractSet ├─ frozenset └─ MutableSet └─ set 예를들어 list의 경우parent class를 따라가면MutableSequence, Sequence,Collection, Iterable이 있는데이 class 들은 typing.pyi에 있다.이 module은 type hint를 위해 쓰이고이 type들이 실제 정의된곳은typing.pyi가 참조하는 collections.abc 아무튼 parent로 갈수록추상화라 쓸게 있긴한가 싶지만공통된걸 정리하면 좋을것같기도하고 collections.abc에 다른게 있긴한데일단은 여기 직접 관련된것만.더 필요하면 나중에 하겠지.Iterable 이 계통 최상위. 보통 자주 보이는 설명에반복 가능한 객체 라고하는데이 의미를 잘 모르겠음. 말고 다른 설명으로 갖고고있는 item을return할 수 있는 객체라고함.이건 대충 알겠고. 막상 Iterable 에는__iter__하나만 있는데 이게 있어야하나봄.Collection iterable, container,size의 subclass. container에서 __contains__,size에서 __len__으로item 소유 판별 및 개수 관련인듯.Mapping Collection의 subclass key - value의 hash구조 사용. __getitem__,get,items,__eq__, keys, values,__contains__가 있음.MutableMapping Mapping의 subclass로변경 가능한 Mapping 이 뒤로 계속 그렇지만Mutable이 오면 변경가능. 변경가능은 item을 바꾼다거나item의 변경으로인한전체 길이가 변경으로add, update정도. __setitem__, __delitem__,clear, pop, popitem,setdefault, update가 있는데update, pop등변경가능한 method가 보임. dict가 이 class의 하위.Sequence Collection의 subclass로Collection에서 순서가 생김. __getitem__, index, count,__contains__, __iter__,__reversed__등. mutable이 따로있는거보면기본적으로는 변경 불가능인듯.read-only sequence라고 써있기도 하고. 사이에 다른 class를 끼고 있다해도 대부분이 최종적으로는 여기 속하는데str, memoryview,tuple,list, bytes,bytearray가 있음.Common Sequence Operations sequence에서 공통으로 가능한 연산 얼핏 건너뛰는경우가 있어서길더라도 보는게 좋아보임. 이 외에는 class별로 따로 구현된것. 우선순위는 위부터 오름차순으로s, t는 sequence, n,i,j,k는 정수,x는 sequence에서 요구하는형과 값제한을 만족하는 임의의 객체 일때 Operation Result Notes x in s True if s have x (1) x not in s False if s have x (1) s + t concat s with t (6)(7) s * n or n * s concat n times of s (2)(7) s[i] item at index ‘i’ (3) s[i:j] slice of s from i to j (3)(4) s[i:j:k] slice of s from i to j with step k (3)(5) len(s) length of s   min(s) smallest item of s   max(s) largest item of s   s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after index i and before index j) (8) s.count(x) total number of occurrences of x in s   in은 일반적으로Membership Operator로 쓰이지만str, bytes, bytearray등은sub sequence도 찾을 수 있음. &quot;gg&quot; in &quot;eggs&quot; True n은 seq의 앞이나 뒤에곱하는 위치는 상관없음.n이 0보다 작으면 0으로 처리.이 방법으로 배열복사할 경우값이 아닌 참조가 복사됨. lists = [[]] * 3 print(lists) lists[0].append(3) print(lists) [[], [], []] [[3], [3], [3]] 결과적으로 한 항목을 수정해도 해당 항목과 동일한 참조는 다 영향이 감. 이 점이 혼동을 적지않게 주나봄. 권장하는 방법은 for를 사용. lists = [[] for i in range(3)] i, j가 음수일때seq의 끝을 기준으로len(seq)+i로 치환됨.-0은 0. i에서 j까지의 s slice는인덱스가 k인 항목의시퀀스로 정의되어 i &amp;lt;= k &amp;lt; j.i 또는 j가 len(s)보다 크면 len(s).i가 생략되었거나 None이면 0.j가 생략되었거나 None이면 len(s).i가 j보다 크거나 같으면 빈 slice. step k 가 있는  i 에서 j 까지의 slice는0 &amp;lt;= n &amp;lt; (j-i)/k 인x = i + nk 의 항목.i, i+k, i+2k, i+3*k 등이며j에 도달할 때 멈추지만j를 포함하지 않음.i 또는 j 가 생략되거나 None 이면,해당 “끝” 값이 되는데“끝”은 k 의 부호에 따름. k 는 0일 수 없고 None 이면 1로 취급. immutable sequence를 이어 붙이면항상 새로운 객체를 생성하는데이것은 반복적으로 이어붙이기를 해서시퀀스를 만들 때 실행 시간이시퀀스의 총 길이의 제곱에 비례.선형 실행 시간 비용을 얻으려면아래 대안 중 하나로 전환해야 한다. str : list로 만들고 str.join()을 사용하거나 io.StringIO 를 사용하는 방법. bytes : bytes.join() 또는 io.BytesIO를 사용하거나, bytearray 객체를 사용. bytearray 객체는 가변이고 overallocation 메커니즘을 갖고 있음. tuple : list로 사용. 다른 type의 경우 관련 문서에서. range등의 일부 sequence는 특정 패턴을 따르는 항목만 지원하기 때문에이어붙이기나 반복을 지원하지 않음. 모든 구현이i와 j 전달을 지원하진 않지만sequence의 하위 섹션검색을 효율적이게함.추가 인수를 전달하는 것은데이터를 복사하지 않고반환된 인덱스가 슬라이스의 시작이 아닌시퀀스의 시작에 상대적이라는 점만 제외하면s[i:j].index(x)를 사용하는 것과 거의 동일. Immutable Sequence Types hash()가 지원됨.mutable sequence에서는 TypeError. t = (1,2)print(hash(t)) t = list(t)print(hash(t)) -3550055125485641917Traceback (most recent call last): File &quot;F:\\W\\Python\\test.py&quot;, line 52, in &amp;lt;module&amp;gt; print(hash(t))TypeError: unhashable type: &#39;list&#39; hash()의 지원으로tuple같은 immutable sequence를dict 키로 사용하고set 및 frozenset에 저장할 수 있음. Mutable Sequence Types s mutablesequence,t는 임의의 iterable,x는 s가 요구하는 type, 값 제한을충족하는 임의의 객체일때 Operation Result Notes s[i] = x item i of s is replaced by x   s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t   del s[i:j] same as s[i:j] = []   s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list   s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x])   s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t)   s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x])   s.pop() or s.pop(i) retrieves the item at i and also removes it from s (2) s.remove(x) remove the first item from s where s[i] is equal to x (3) s.reverse() reverses the items of s in place (4) t는 대체하는 slice와 길이가 같아야함. i는 default값이 -1.기본적으로 마지막값을 제거/반환 x가 없으면 ValueError 큰 sequence에서 공간 절약을 위해제자리에서 수정함.return이 None이고, 원본을 변경. slice 연산을 지원하지 않는dic및 set등의 가변 컨테이너와의인터페이스 일관성을 위해clear() 및 copy()가 추가됨.copy()는 MutableSequence의일부가 아니지만, 대부분의 구체적인MutableSequence class에서 제공됨. 값 n은 정수이거나__index__()를 구현하는 객체.n의 0 및 음수 값은 sequence를 삭제함.sequence의 항목은 복사되지 않고일반 시퀀스 연산에서s * n과 동일하게 동작. Bytestring Sequence의 subclass. 일단 아무것도 없음.AbstractSet Collection의 subclass이고따로 있는게 아니라 Set을 이름바꿔 씀. Set이랑 set을 구별하려고 그런듯.Set는 Collection의 subclass,set는 MutableSet의 subclass 유한하고 이터러블한 컨테이너. __contains__, __iter__, __len__을 제외하고 구현이 되어있음. 비교 연산을 재 정의하려면__le__, __ge__만 하면 됨. 집합관련. __contains__, __iter__, __len__,__le__, __lt__, __eq__,__ne__, __gt__, __ge__,__and__, __or__, __sub__,__xor__, isdisjoint, _hashMutableSet AbstractSet의 subclass 유한하고 이터러블한 컨테이너. __contains__, __iter__, __len__,add(), discard()를 제외하고 구현. 비교를 재정의하려면__le__만 하면 됨. __contains__, __iter__, __len__,add, discard, clear,pop, remove, __ior__, __iand__, __ixor__, __isub__ set이 여기 하위." }, { "title": "Operators", "url": "/posts/Python_Operators/", "categories": "Grind, Python", "tags": "python, operator", "date": "2022-04-24 00:00:00 +0900", "snippet": "Init python에서는 7개 그룹의 연산자가 있음 Arithmetic operators Assignment operators Comparison operators Logical operators Identity operators Membership operators Bitwise operators Arithmetic Operators 산술 연산. Operator Name Example + Addition 2 + 3 = 5 - Subtraction 3 - 2 = 1 * Multiplication 2 * 3 = 6 / Division 5 / 2 = 2.5 % Modulus 7 % 2 = 1 ** Exponentiation 2 ** 3 = 8 // Floor division 10 // 3 = 3 Comparison Operators 비교연산 Operator Name Example == Equal to 2 == 2 != Not equal to 2 != 3 &amp;lt; Less than 2 &amp;lt; 3 &amp;gt; Greater than 3 &amp;gt; 2 &amp;lt;= Less than or equal to 2 &amp;lt;= 3 &amp;gt;= Greater than or equal to 3 &amp;gt;= 2 Logical Operators 논리 연산 Operator Name Example and Logical AND x &amp;gt; 5 and x &amp;lt; 10 or Logical OR x &amp;lt; 5 or x &amp;gt; 10 not Logical NOT not(x &amp;gt; 5 and x &amp;lt; 10) Assignment Operators 할당연산 Operator Example Same as = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3 //= x //= 3 x = x // 3 **= x **= 3 x = x ** 3 &amp;amp;= x &amp;amp;= 3 x = x &amp;amp; 3 |= x |= 3 x = x | 3 ^= x ^= 3 x = x ^ 3 »= x »= 3 x = x » 3 «= x «= 3 x = x « 3 Identity Operators 항등연산 object 비교. 같은 object가 아닌같은 memory에 있는object인지 비교. Operator Example Result is x is y Returns True if the same object is not x is not y Returns True if not the same object Membership Operators 멤버쉡 연산 object에 시퀀스가 존재하는지 테스트. Operator Example Name in x in y Returns True if y have x not in x not in y Returns True if y have not x 아무튼 좀 애매한부분을 더 봤는데 l2 = [1, 2, 3]l3 = [1, 2]item = 3 print(&quot;l1 in l2 ?&quot;, (l1 in l2)) print(&quot;item in l1 ?&quot;, (item in l1)) print(&quot;l3 in l1 ?&quot;, (l3 in l1)) l1 in l2 ? Falseitem in l1 ? Truel3 in l1 ? False 해서, 집합기호로 따지면 ∈ 관계.부분집합이 아닌 원소. Bitwise Operators 비트연산 Operator Name Example &amp;amp; AND x &amp;amp; y | OR x | y ^ XOR x ^ y ~ NOT ~x « Zero fill left shift x « y » Signed right shift x » y Operator Precedence 앞서 썼던 연산자 포함 연산자 우선순위.나머지는 앞으로 오며가며 볼꺼니까. 위쪽으로 우선순위가 높고 같은 상자안에서는 순서상관없이 같음. 구문이 명시적이지 않으면연산자는 binary Operator Description (expressions…),[expressions…], {key: value…}, {expressions…} Binding, parenthesized expression, list display, dictionary display, set display x[index], x[index:index], x(arguments…), x.attribute Subscription, slicing, call, attribute reference await x Await expression ** Exponentiation +x, -x, ~x Positive, negative, bitwise NOT *, @, /, //, % Multiplication, matrix multiplication, division, floor division, remainder +, - Addition and subtraction «, » Shifts &amp;amp; Bitwise AND ^ Bitwise XOR | Bitwise OR in, not in, is, is not, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, == Comparisons, membership , identity not x Boolean NOT and Boolean AND or Boolean OR if – else Conditional expression lambda Lambda expression := Assignment expression " }, { "title": "Python 4 - Variable &amp; Data Type 2", "url": "/posts/Python_4_Var_Type/", "categories": "Grind, Python", "tags": "python, variable, data type", "date": "2022-04-24 00:00:00 +0900", "snippet": "string 문자열 처리가 다른 언어보다 간단하고 직관적 문자 표시로 &quot; &quot;나 &#39; &#39;나 상관없는듯.단, 짝은 맞게.. 이 관련은 앞에 pep8에도 있음. 블록 전체를 string으로 하려면&#39;&#39;&#39; &#39;&#39;&#39;하면 되는데 이게 docstring아닌지? 문자 * 숫자로 문자 반복을 할 수 있음 print(“0” * 3) 하면 000 str = &quot;asdf&quot;print(str)str2 = &#39;asdf&#39;print(str2)str3 = &quot;&quot;&quot;asdfaregdtuykj&quot;&quot;&quot;print(str3)string - indexing, slicingIndexing string를 배열처럼 처리하는거 다른 언어랑 같음. 특이한점은(-)로 indexing이 가능한데뒤에서부터 시작해서거꾸로 검색해준다.이건 slicing에서 더. 배열처럼 취급은 같음Slicing []안에 : 로 조건을 줄 수 있음 [start : end : step] start 시작 index 0인경우 생략 가능 뒤에서셀경우 (-) end 끝 + 1 index 실제 끝나는곳은 이 앞 index. 끝을 나타낼 때 생략 가능 뒤에서 셀 경우 (-) step 위 두 조건안에서 수를 세는 방법 for문으로 칠 때 i++역할 (-)가 붙으면 뒤에서 앞방향으로. start ≤ index &amp;lt; end 인듯. for(int i = start; i &amp;lt; end; i+=step){} ex) str = &quot;0123456789&quot; print(1,str[0:5])print(2,str[3:8])print(3,str[0:])print(4,str[:5])print(4,str[:-6])print(5,str[:])print(6,str[::2])print(7,str[::-1])print(8,str[::-2])print(9,str[-1::-2])print(10,str[-1::])print(11,str[-1::-1])print(12,str[-1::-2])print(13,str[-1::-3])print(14,str[-1::-4])print(15,str[-1::-5]) 1 012342 345673 01234567894 012344 01235 01234567896 024687 98765432108 975319 9753110 911 987654321012 9753113 963014 95115 94 string - method 다양한 함수들의 향연.. 이름, 쓰는거 간략히 하고만약 쓰게된다면 세부 옵션은그때 찾는게 나을듯. name   capitalize 첫글자’만’ 대문자로 casefold 전체 소문자( &amp;gt; lower) center 중앙 정렬 count 해당 글자 수 encode 인코딩 endswith 끝문자 확인 expandtabs 탭 공간 수 조정 find 문자 시작 index format 포맷팅 format_map foramt비슷 index 문자 시작 index isalnum alph &amp;amp; num isalpha only alph isdecimal 숫자 isdigit 숫자 isidentifier 유효한 이름 검사 islower 소문자인지 검사 isnumeric 숫자 isprintable 출력 가능한지 isspace 빈공간 istitle title형식인지 isupper 대문자만 있는지 join 구분자 문자열로 결합 ljust 왼쪽정렬 lower 소문자로 lstrip 왼쪽 공백 제거 maketrans 대체 문자로 변환 partition 기준 문자로 분할 replace 대체 문자열 removeprefix 시작문자 제거 removesuffix 끝문자 제거 rfind 문자열 마지막 위치 rindex 문자열 마지막 위치 rjust 오른정렬 rpartition 뒤에서 기준 문자로 분할 rsplit 뒤부터 문자열 분할 rstrip 오른쪽 공백 제거 split 문자열 분할 splitlines 줄바꿈기준 분할 startswith 시작문자 확인 strip 앞뒤 공백 제거 swapcase 대소문자 변경 title 제목 형식 translate maketrans를 str로 upper 대문자로 zfill 빈공간 0으로 isdecimal() ≤ isdigit() ≤ isnumeric() find랑 index는 문자(열)을 찾아주는데차이점은 만약 찾는 문자열이 없는 경우find는 -1반환, index는 exception string = &quot;The quick brown fox jumps over the lazy dog&quot;print(&quot;{0:12} : {1}&quot;.format( str.capitalize.__name__ , string.capitalize()))print(&quot;{0:12} : {1}&quot;.format( str.casefold.__name__ , string.casefold()))print(&quot;{0:12} : {1}&quot;.format( str.center.__name__ , string.center(50, &quot;*&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.count.__name__ , string.count(&quot;o&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.encode.__name__ , string.encode()))print(&quot;{0:12} : {1}&quot;.format( str.endswith.__name__ , string.endswith(&quot;dog&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.expandtabs.__name__ , string.expandtabs(40)))print(&quot;{0:12} : {1}&quot;.format( str.find.__name__ , string.find(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.format.__name__ , string.format()))print(&quot;{0:12} : {1}&quot;.format( str.format_map.__name__ , string.format_map({&quot;name&quot;: &quot;John&quot;})))print(&quot;{0:12} : {1}&quot;.format( str.index.__name__ , string.index(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.isalnum.__name__ , string.isalnum()))print(&quot;{0:12} : {1}&quot;.format( str.isalpha.__name__ , string.isalpha()))print(&quot;{0:12} : {1}&quot;.format( str.isdecimal.__name__ , string.isdecimal()))print(&quot;{0:12} : {1}&quot;.format( str.isdigit.__name__ , string.isdigit()))print(&quot;{0:12} : {1}&quot;.format( str.isidentifier.__name__ , string.isidentifier()))print(&quot;{0:12} : {1}&quot;.format( str.islower.__name__ , string.islower()))print(&quot;{0:12} : {1}&quot;.format( str.isnumeric.__name__ , string.isnumeric()))print(&quot;{0:12} : {1}&quot;.format( str.isprintable.__name__ , string.isprintable()))print(&quot;{0:12} : {1}&quot;.format( str.isspace.__name__ , string.isspace()))print(&quot;{0:12} : {1}&quot;.format( str.istitle.__name__ , string.istitle()))print(&quot;{0:12} : {1}&quot;.format( str.isupper.__name__ , string.isupper()))print(&quot;{0:12} : {1}&quot;.format( str.join.__name__ , string.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])))print(&quot;{0:12} : {1}&quot;.format( str.ljust.__name__ , string.ljust(50, &quot;*&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.lower.__name__ , string.lower()))print(&quot;{0:12} : {1}&quot;.format( str.lstrip.__name__ , string.lstrip(&quot;The&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.maketrans.__name__ , string.maketrans(&quot;abc&quot;, &quot;xyz&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.partition.__name__ , string.partition(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.replace.__name__ , string.replace(&quot;fox&quot;, &quot;cat&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.removeprefix.__name__ , string.removeprefix(&quot;The&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.removesuffix.__name__ , string.removesuffix(&quot;dog&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rfind.__name__ , string.rfind(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rindex.__name__ , string.rindex(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rjust.__name__ , string.rjust(50, &quot;*&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rpartition.__name__ , string.rpartition(&quot;fox&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rsplit.__name__ , string.rsplit(&quot; &quot;)))print(&quot;{0:12} : {1}&quot;.format( str.rstrip.__name__ , string.rstrip(&quot;dog&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.split.__name__ , string.split(&quot; &quot;)))print(&quot;{0:12} : {1}&quot;.format( str.splitlines.__name__ , string.splitlines()))print(&quot;{0:12} : {1}&quot;.format( str.startswith.__name__ , string.startswith(&quot;The&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.strip.__name__ , string.strip(&quot;The&quot;)))print(&quot;{0:12} : {1}&quot;.format( str.swapcase.__name__ , string.swapcase()))print(&quot;{0:12} : {1}&quot;.format( str.title.__name__ , string.title()))print(&quot;{0:12} : {1}&quot;.format( str.translate.__name__ , string.translate(string.maketrans(&quot;abc&quot;, &quot;xyz&quot;))))print(&quot;{0:12} : {1}&quot;.format( str.upper.__name__ , string.upper()))print(&quot;{0:12} : {1}&quot;.format( str.zfill.__name__ , string.zfill(50)))capitalize : The quick brown fox jumps over the lazy dogcasefold : the quick brown fox jumps over the lazy dogcenter : ***The quick brown fox jumps over the lazy dog****count : 4encode : b&#39;The quick brown fox jumps over the lazy dog&#39;endswith : Trueexpandtabs : The quick brown fox jumps over the lazy dogfind : 16format : The quick brown fox jumps over the lazy dogformat_map : The quick brown fox jumps over the lazy dogindex : 16isalnum : Falseisalpha : Falseisdecimal : Falseisdigit : Falseisidentifier : Falseislower : Falseisnumeric : Falseisprintable : Trueisspace : Falseistitle : Falseisupper : Falsejoin : aThe quick brown fox jumps over the lazy dogbThe quick brown fox jumps over the lazy dogcljust : The quick brown fox jumps over the lazy dog*******lower : the quick brown fox jumps over the lazy doglstrip : quick brown fox jumps over the lazy dogmaketrans : {97: 120, 98: 121, 99: 122}partition : (&#39;The quick brown &#39;, &#39;fox&#39;, &#39; jumps over the lazy dog&#39;)replace : The quick brown cat jumps over the lazy dogremoveprefix : quick brown fox jumps over the lazy dogremovesuffix : The quick brown fox jumps over the lazyrfind : 16rindex : 16rjust : *******The quick brown fox jumps over the lazy dogrpartition : (&#39;The quick brown &#39;, &#39;fox&#39;, &#39; jumps over the lazy dog&#39;)rsplit : [&#39;The&#39;, &#39;quick&#39;, &#39;brown&#39;, &#39;fox&#39;, &#39;jumps&#39;, &#39;over&#39;, &#39;the&#39;, &#39;lazy&#39;, &#39;dog&#39;]rstrip : The quick brown fox jumps over the lazysplit : [&#39;The&#39;, &#39;quick&#39;, &#39;brown&#39;, &#39;fox&#39;, &#39;jumps&#39;, &#39;over&#39;, &#39;the&#39;, &#39;lazy&#39;, &#39;dog&#39;]splitlines : [&#39;The quick brown fox jumps over the lazy dog&#39;]startswith : Truestrip : quick brown fox jumps over the lazy dogswapcase : tHE QUICK BROWN FOX JUMPS OVER THE LAZY DOGtitle : The Quick Brown Fox Jumps Over The Lazy Dogtranslate : The quizk yrown fox jumps over the lxzy dogupper : THE QUICK BROWN FOX JUMPS OVER THE LAZY DOGzfill : 0000000The quick brown fox jumps over the lazy dogstring - format 이쪽은 나중에 입출력할때 자주씀.% c처럼? 하는방식 문자열에 %?로 표시하고문자열 끝에 % ? 로 값을 넣는데여러개일 경우 % (,) 로 표현 d는 정수 f는 실수 s는 string 대충 %s에 때려박아도 됨 ex) print(&quot;some arguments: one, two, three&quot;)print(&quot;some arguments: %d, two, three&quot; % 1)print(&quot;some arguments: %d, %f, three&quot; % (1, 1.1))print(&quot;some arguments: %d, %f, %s&quot; % (1, 1.1, &quot;three&quot;))print(&quot;some arguments: %s, %s, %s&quot; % (1, 1.1, &quot;three&quot;)) {}.format C# 비슷한거 문자열에 {}로 표시해놓고문자열 끝에 .format()를 붙이고그 안에 값을 넣음 {}가 하나 이상일 경우.format 인자의 index를{}안에 명시해서 쓸 수 있음 ex) print(&quot;some arguments: one, two, three&quot;)print(&quot;some arguments: {}, two, three&quot;.format(1))print(&quot;some arguments: {0}, {1}, three&quot;.format(1, 1.1))print(&quot;some arguments: {2}, {0}, {1}&quot;.format(1, 1.1, &quot;three&quot;)) 변수화.format안에서 변수처럼 명시하면{}안에 그 이름을 쓸 수 있음 print(&quot;some arguments: one, two, three&quot;)print(&quot;some arguments: {arg3}, {arg2}, {arg1}&quot;.format(arg1=1, arg2=1.1, arg3=&quot;three&quot;)) 외부 변수 사용python 3.6이상 지원 arg1 = 1arg2 = 1.1arg3 = &quot;three&quot;print(&quot;some arguments: one, two, three&quot;)print(f&quot;some arguments: {arg3}, {arg2}, {arg1}&quot;) Excape sequence \\랑 엮여서 예약된거 Escape Character explain \\ 백슬래시, \\ &#39; 작은따옴표, Single quote, ‘ &quot; 큰따옴표, Double quote, “ \\a 벨, ASCII Bell, BEL \\b 백스페이스, ASCII Backspace, BS \\f 폼피드, ASCII Formfeed, FF \\n 새 줄, 개행 문자, ASCII Linefeed, LF \\r 캐리지 리턴, ASCII Carriage Return, CR \\t 탭 문자, ASCII Horizontal Tab, TAB \\v 수직 탭, ASCII Vertical Tab, VT \\ooo \\ 뒤에 8진수 숫자를 지정하여 ASCII 코드의 문자 표현   예) ‘\\141’은 ‘a’를 표현 \\xhh \\ 뒤에 16진수 숫자를 지정하여 ASCII 코드의 문자 표현   예) ‘\\x61’은 ‘a’를 표현   ASCII 코드는 다음 URL 참조   - Ascii Table   https://www.asciitable.com \\N{name} { } 안에 문자 이름을 지정하여 유니코드의 문자 표현(파이썬 3.3이상)   예) ‘\\N{LINE FEED}’는 ‘\\n’을 표현   문자 이름은 다음 URL 참조   - formal name aliases for Unicode characters   http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt \\uxxxx \\ 뒤에 16비트 16진수 숫자를 지정하여 유니코드의 문자 표현   예) ‘\\u0061’은 ‘a’를 표현   유니코드는 다음 URL 참조   - List of Unicode characters(유니코드 문자 목록)   https://en.wikipedia.org/wiki/List_of_Unicode_characters   - Hangul Syllables(한글 음절)   https://en.wikipedia.org/wiki/Hangul_Syllables \\Uxxxxxxxx \\ 뒤에 32비트 16진수 숫자를 지정하여 유니코드의 문자 표현   예) ‘\\U00000061’은 ‘a’를 표현   유니코드는 위 URL과 동일 앞에 r을 붙여 무효화 가능 print(&quot;c:\\program\\files\\test.txt&quot;)print(r&quot;c:\\program\\files\\test.txt&quot;)c:\\program iles est.txtc:\\program\\files\\test.txt자료형 변경 앞에 바꾸고 싶은 자료형 붙이면 됨a = 45 b = 1.23c = &quot;10.231&quot;print(float(a))print(int(b))print(float(c))# 45.0# 1# 10.231" }, { "title": "Numeric, Bool, None", "url": "/posts/Python_Numeric_Bool_None/", "categories": "Grind, Python", "tags": "python, numeric, bool, none", "date": "2022-04-23 00:00:00 +0900", "snippet": "Numeric 대충 숫자 관련. int, float, complex가 있음. bool은 int하위.inta = 0print(&quot;a =&quot;,a)print(&quot;a type =&quot;,type(a))c = 9999999999999999999999999999999999print(&quot;c =&quot;,c)print(&quot;c type =&quot;,type(c))d = g*g*g*g*g*g*g*g*g*g# print(&quot;d =&quot;,d)print(&quot;d type =&quot;,type(d))a = 0a type = &amp;lt;class &#39;int&#39;&amp;gt;c = 9999999999999999999999999999999999c type = &amp;lt;class &#39;int&#39;&amp;gt;d type = &amp;lt;class &#39;int&#39;&amp;gt; int()생성자로 생성 가능.0으로 생성됨. 정수형 정밀도가 무제한임.다시말해 길이가 무제한 이거 때문에 큰수 계산이 편함.floatb = 3.15print(&quot;b =&quot;,b)print(&quot;b type =&quot;,type(b))f = 1.1e-2print(&quot;f =&quot;,f)print(&quot;f type =&quot;,type(f))b = 3.15b type = &amp;lt;class &#39;float&#39;&amp;gt;f = 0.011f type = &amp;lt;class &#39;float&#39;&amp;gt; float()로 생성 가능. 0.0으로 생성됨. float은 C에서의 double로 구현됨. 지수표현으로 쓰면 기본이 float float 의 정밀도 및내부 표현에 대한 정보는sys.float_info로 볼 수 있음. 이게 HW특성에따라 달라지는가봄. float는 항상 정확도와근사값계산관련 문제가 있는데나중에 필요하면 여기.complexe = 4+3jprint(&quot;e =&quot;,e)print(&quot;e type =&quot;,type(e))print(&quot;e real =&quot;, e.real)print(&quot;e image =&quot;, e.imag)e = (4+3j)e type = &amp;lt;class &#39;complex&#39;&amp;gt;e real = 4.0e image = 3.0 complex()로 생성됨.0j로 생성됨. 복소수 부분은j, J, i를 쓰면됨.boolean int 하위에 있음. True, False not은 반대. print(not True) =&amp;gt; False 모든 object는if, while에서 사용하기 위해, and, or의 연산을 위해truth value가 판별됨. object는 기본적으로 True으로 간주. 단, 다음의 경우는 False class의 __bool__()이 False를 return. class의 __len__()이 0을 return. built-in objects중에 false인것들 false로 정의된 상수 : None, False 숫자 0 : 0, 0.0, 0j, Decimal(0), Fraction(0, 1) 비어있는 sequences, collections : ‘’, (), [], {}, set(), range(0) None Null 대신에None 사용 return이 없는 method가 return함. 특별한건 없음." }, { "title": "Variable &amp; Data Type", "url": "/posts/Python_Var_Type/", "categories": "Grind, Python", "tags": "python, variable, data type", "date": "2022-04-22 00:00:00 +0900", "snippet": "Variable 변수. 값을 저장하는 공간. 다른 언어에 비해 역시 편하다. c int a = 10;char * str = &quot;test&quot;;//이건 배열로 쓰는등 아무튼. c# int a = 10;string str = &quot;c#&quot;; python a = 10s = &quot;python&quot; highly object-oriented language 위 예시에서 차이점을 보면자료형을 명시해주지 않는다. 따라서 a = 10a = &quot;python&quot; 이게 가능해진다. 이유는 python에서는모든것이 객체로 처리되기 때문.이런 특성을 순수 객체지향이라 한다. 변수 자체에 값이 할당되는것이 아니라값이 저장된 객체를 가리키기 때문.c에서 포인터같은 느낌인듯. 모든것을 object로 취급한다는것과 class, method또한object로 취급할 수 있다는것은 사용할 때 자유도가 커짐. def func(): return &quot;Hello&quot; a = func print(a()) 예를들어 이런식의delegate같은 형태 등.다만, custom class가 자료형으로 돌아다닐 때조금 헷갈리는 경향이 있음. Variable Names 당연하지만, 예약어가 있어서그것만 피하고 만들면 됨.help(&quot;keywords&quot;)로예약어를 볼 수 있음. 명명규칙은 앞에 썼던거에 있음Python Data Type data type에는int, bool, float, complex, dict, str, memoryview, tuple, list, bytes, bytearray, set, frozenset정도로 보통 정리하는것같음. 아무튼, 이 type 분류가설명마다 조금씩 달라서class별 구분으로 보면나중에 공통적으로뭔가 있지 않을까해서 정리해봄 ─ int └─ bool─ float─ complex─ Iterable └─ Collection ├─ Mapping │ └─ MutableMapping │ └─ dict ├─ Sequence │ ├─ str │ ├─ memoryview │ ├─ tuple │ ├─ MutableSequence │ │ └─ list │ ├─ ByteString │ │ └─ bytes │ └─ MutableSequence, ByteString │ └─ bytearray └─ AbstractSet ├─ frozenset └─ MutableSet └─ set 해당 type함수로 초기화할수도 있고,직접 할당해도 상관없고. 이건 차차. type cast는변경하고 싶은 type으로 명시하면됨 x = set(list([1,2])) print(x)print(type(x)) list를 set로 cast한 경우.casting이 되는경우 해줌. " }, { "title": "Intro 2", "url": "/posts/Python_Intro_2/", "categories": "Grind, Python", "tags": "python", "date": "2022-04-19 00:00:00 +0900", "snippet": "PEP 8 – Style Guide for Python Code 코드 쓰는방법까지만 얼추 알면본격젹으로 시작해도 될거라 생각해서여기까지 쓰는거로.Introduction 규칙의 추가, 언어자체가 변함에 따라이 지침도 변할 수 있음. 프로젝트에서 말하는 지침이 있으면그걸 먼저 적용함.A Foolish Consistency is the Hobgoblin of Little Minds 어리석은 일관성은 하남자 특이다. 코드는 쓰는것보다 읽는횟수가 더 많다. 중요하게 생각하는것은 코드의 일관성.궁극적인 목적은 PEP 20 - 7의 가독성.이 둘이 문서의 중점. 이 문서를 무시해도 되는 상황이 있는데 이 지침을 따르면 코드가 더 어려워질때 다른 코드와의 일관성을 해칠때 이전 가이드에 따라 적성되었거나,권장하는 기능을 지원하지 않는이전 버전과 호환을 유지해야하는 경우 Code lay-out 들여쓰기 레벨당 4 공백. 이게 얼마전에 본건데,탭도 4공백, 스페이스 4번도 4공백인데가끔 둘이 달라지는 경우가 있다함.그래서 4공백으로 박아넣은듯. 내용을 연결된 줄로 작성할 때 4 space는 선택사항이지만연속된 줄을 알 수 있도록 들여써야 하며내용으로 인한 들여쓰기 레벨보다더 들여써야함. # Correct:# Aligned with opening delimiter.foo = long_function_name(var_one, var_two, var_three, var_four)# Add 4 spaces (an extra level of indentation) # to distinguish arguments from the rest.def long_function_name( var_one, var_two, var_three, var_four): print(var_one)# Hanging indents should add a level.foo = long_function_name( var_one, var_two, var_three, var_four) # Wrong:# Arguments on first line forbidden # when not using vertical alignment.foo = long_function_name(var_one, var_two, var_three, var_four)# Further indentation required # as indentation is not distinguishable.def long_function_name( var_one, var_two, var_three, var_four): print(var_one) if의 경우 if (로 인해4space가 만들어지며조건이 길어져 내려쓸 때본문 블록과 겹쳐 애매해지는데주석을 넣거나 더 들여쓴다. # No extra indentation.# 추가 들여쓰기가 없다.if (this_is_one_thing and that_is_another_thing): do_something()# Add a comment, # which will provide some distinction in editors# supporting syntax highlighting.# 문법 강조를 지원하는 에디터에서 # 어느 정도 구별이 되도록 코멘트를 넣는다.if (this_is_one_thing and that_is_another_thing): # Since both conditions are true, we can frobnicate. do_something()# Add some extra indentation # on the conditional continuation line.# 조건문의 연속된 줄에 추가 들여쓰기를 한다.if (this_is_one_thing and that_is_another_thing): do_something() 닫는기호 ] , ) , } 등은첫번째 요소라인에 두거나 암튼 대충 두셈 my_list = [ 1, 2, 3, 4, 5, 6, ]result = some_function_that_takes_arguments( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, )my_list = [ 1, 2, 3, 4, 5, 6,]result = some_function_that_takes_arguments( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,) 닫을 때 한줄 아래가 중점인가? Tabs or Spaces space를 기본으로 한다. 2는 혼용가능이었던것같은데3은 space만 되나봄. 2도 space로 통일을 권장함. Maximum Line Length 라인당 최대 79자로 한다. 구조적 제약이 적은독스트링 또는 주석등의긴 텍스트 블록의 경우는 72자. 위에 쓴 암시적 줄 바꿈을 잘 쓰던가\\를 쓰던가. 이 판단은 적절한거로 알아서. Should a line break before or after a binary operator? # No: operators sit far away from their operandsincome = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest)# Yes: easy to match operators with operandsincome = (gross_wages + taxable_interest + (dividends - qualified_dividends) - ira_deduction - student_loan_interest) 보통 위처럼 썼는데 이게 가독성을 해침.연산자가 오른쪽 끝에서들쭉날쭉한게 이유인듯함. 이 전에 쓰여진 코드와 일관성을 따르되새로 쓴다면 이걸 권장함. Blank Lines 최상위함수, 클래스 정의는 두 개 클래스 내의 메서드는 한 개 관련 기능의 그룹을 구분하기 위해빈 줄을 드물게 쓸 수 있음. (e.g. a set of dummy implementations) 논리적 섹션을 나타내기 위해함수 안에서 드물게 사용함 Python accepts the control-L문단 뭔소린지 몰라 넘김. Source File Encoding 핵심 Python 배포판의 코드는 항상UTF-8을 사용하고 인코딩 선언은 안함. 표준 라이브러리에서UTF-8이 아닌 인코딩은테스트 목적으로만 사용. ASCII가 아닌 문자는 가능하면장소와 사람 이름만 사용.ASCII가 아닌 문자를데이터로 사용하는 경우z̯̯͡a̧͎̺l̡͓̫g̹̲o̡̼̘ 및 바이트 순서 표시와 같은지저분한거 사용금지. 표준 라이브러리의 모든 식별자는ASCII전용 식별자를 사용하고가능한한 영어를 사용한다. Imports 한줄에 쓰기 금지 Yes:import osimport sys No:import sys, os 이건 가능 from subprocess import Popen, PIPE 항상 파일 상단,모듈주석 및 독스트링 바로 뒤,모듈 전역 및 상수 앞에 배치. 다음 순서로 그룹화해서 정리함 표준 lib import 관련 third party import 로컬 app/lib 특정 import 위 각 그룹마다 빈 줄로 구분. Absolute imports are recommended 일반적으로 읽기 쉽다. import 시스템이 잘못 구성되어 있어도최소한 오류메시지라도 더 잘 제공함. 단, 명료한 상대적 import는절대적 import의 대안으로허용될 수 있다.(절대경로 지정이 더 길어질 경우 등.) 표준 라이브러리 코드는복잡한 패키지 레이아웃을 피하고Absolute imports 사용. Module level dunder names 몰라 여긴. String Quotes &quot;&quot; 나 &#39;&#39; 나 상관없음 근데 문자열 중간에 포함할때안쓴 나머지 문자를 쓰는걸 권장. a = &quot;some sample text&quot;b = &quot;some &#39;sample&#39; text&quot;c = &quot;some \\&quot;sample\\&quot; text&quot;print(a)print(b)print(c) Whitespace in Expressions and Statements Pet Peeves(짜증나는거) 쓸데없는 공백을 싫어함. 괄호 안쪽 쉼표 근처 콜론, 세미콜론 근처 # Correct:spam(ham[1], {eggs: 2})# Wrong:spam( ham[ 1 ], { eggs: 2 } ) # Correct:foo = (0,)# Wrong:bar = (0, ) # Correct:if x == 4: print(x, y); x, y = y, x# Wrong:if x == 4 : print(x , y) ; x , y = y , x 널널하게 쓰는게 좋담서… 슬라이스에서 콜론은이항 연산자처럼 작동하며양쪽에 동일한 양을 쓴다.(가장 낮은 우선 순위의 연산자로 처리).확장 슬라이스에서는두 콜론에 동일한 간격을 쓴다.예외: 슬라이스 매개변수가 생략되면공백 생략. # Correct:ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]ham[lower:upper], ham[lower:upper:], ham[lower::step]ham[lower+offset : upper+offset]ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]ham[lower + offset : upper + offset] # Wrong:ham[lower + offset:upper + offset]ham[1: 9], ham[1 :9], ham[1:9 :3]ham[lower : : upper]ham[ : upper] 함수 / 인덱싱 / 슬라이싱과 괄호 사이 # Correct:spam(1)# Wrong:spam (1)# Correct:dct[&#39;key&#39;] = lst[index]# Wrong:dct [&#39;key&#39;] = lst [index] 할당 할 때 변수이름 자리맞춤 # Correct:x = 1y = 2long_variable = 3# Wrong:x = 1y = 2long_variable = 3 이부분은 항상 고민이긴함 Other Recommendations 뒤에 공백을 쓰지 않는다.잘 보이지도 않고 안좋음. 다음의 이항 연산자들은항상 단일 공백을 쓴다. 할당( = ), 증강 할당( += , -= 등), 비교( == , &amp;lt; , &amp;gt; , != ,&amp;lt;&amp;gt; , &amp;lt;= ,&amp;gt;= , in, not in ,is , is not ), 논리( and , or , not). 우선 순위가 다른 연산자를 사용하는 경우 우선 순위가 가장 낮은 연산자 주위에공백을 쓰면 좋음. 단, 두 개 이상의 공백을 사용하지 말고이항 연산자의 양쪽에항상 같은 양의 공백을 사용. # Correct:i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)# Wrong:i=i+1submitted +=1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b) 여기 위로 자잘한게 더 있는데 복잡. When to use trailing commas 후행 쉼표는한 요소의 튜플을 만들 때 필수,그 외 일반적으로 선택적.명확성을 위해 후자를(기술적으로 중복되는)괄호로 묶는 것이 좋음. # Correct:FILES = (&#39;setup.cfg&#39;,)# Wrong:FILES = &#39;setup.cfg&#39;, 후행 쉼표는 값 목록, 인수, 가져온 항목이추후 확장 가능성이 있는 경우 종종 유용.각각을 한 줄에 단독으로 넣고항상 후행 쉼표를 추가하고다음 줄에 닫는 괄호/대괄호/중괄호를 추가.그러나 닫는 구분 기호와 동일한 줄에후행 쉼표를 사용하는 것은 의미가 없다.단일 톤 튜플의 경우 제외. # Correct:FILES = [ &#39;setup.cfg&#39;, &#39;tox.ini&#39;, ]initialize(FILES, error=True, )# Wrong:FILES = [&#39;setup.cfg&#39;, &#39;tox.ini&#39;,]initialize(FILES, error=True,) Comments 코드와 모순되는 주석은주석이 없는 것보다 나쁘다.코드가 변경될 때 항상주석을 최신 상태로 유지해야함. 주석은 완전한 문장으로 한다.소문자로 시작하는 식별자가 아닌 경우첫 번째 단어는 대문자로 한다.식별자의 대소문자는 변경하면 안됨. 블록 주석은 일반적으로완전한 문장으로 구성된하나 이상의 단락으로 구성되며각 문장끝은 마침표로. 여러 문장으로 된 주석에서는마지막 문장을 제외하고문장 끝 마침표 뒤에 두 개의 공백을 둔다. 다른 사용자가명확하고 쉽게 이해할 수 있어야 함. 비영어권 국가의 경우에도 가급적 영어로. Block Comments Inline Comments Documentation Strings “docstrings”의좋은 작성 규칙은 PEP 257로. 모든 공개 모듈, 함수,클래스, 메서드에 docstrings 작성. 비공개 메서드에는 선택이지만메서드를 설명하는 주석은 필요. 이 주석은 def 줄 뒤에 씀 . docstrings이 끝날때는&quot;&quot;&quot;가 단독으로 와야 한다. &quot;&quot;&quot;Return a foobangOptional plotz says to frobnicate the bizbaz first.&quot;&quot;&quot; 한 라인에 전부 쓰는 경우는 제외. &quot;&quot;&quot;Return an ex-parrot.&quot;&quot;&quot; Naming Conventions python lib도 지금 엉망이라함. 다만 이후 작성은 이 방법을 따르는기로. Overriding Principle API에서 public으로 보이는 이름은구현보다는 사용법을 반영한다. Descriptive: Naming Styles 일반적으로 쓰이는거 다 상관없음 b(단일 소문자) B(단일 대문자) lowercase lower_case_with_underscores UPPERCASE UPPER_CASE_WITH_UNDERSCORES CapitalizedWords(CapWords / CamelCase / StudlyCaps) 이 때 두문자어는모든 문자를 대문자로 힌디. ex) HTTPServerError와HttpServerError중 전자. mixedCase(CapitalizedWords와 다름) Capitalized_Words_With_Underscores(혼종) 이 뒤 내용은 …아마 나중에 필요하면.. Prescriptive: Naming Convention Names to Avoid 단일변수로 비추 글꼴에 따라 다른 문자와구별이 힘들어지는 문자들 ex)‘l’(소문자 el) -&amp;gt; 1 ‘O’(대문자 oh) -&amp;gt; 0 ‘I’(대문자 eye)등 -&amp;gt;l ASCII Compatibility 표준 lib에서 사용되는 식별자는PEP 3131에 따라 ASCII와 호환되어야 함. Package and Module Names 모듈은 모두 소문자로 된짧은 이름으로한다.가독성을 위해모듈 이름에 밑줄을 쓸 수 있다. 패키지또한 소문자로 된짧은 이름으로 한다.여기는 밑줄 사용은 권장되지 않는다. C 또는 C++로 작성된 확장 모듈이더 높은 수준(예: 더 많은 객체 지향)의인터페이스를 제공하는파이썬 모듈을 동반하는 경우,C/C++ 모듈은선행 밑줄(예: _socket)을 갖는다. Class Names 일반적으로 CapWords를 따름. 인터페이스가 문서화되고주로 호출가능으로 사용되는 경우에는함수와 같은 규칙이 사용될 수 있다. 내장함수에는 별도 규칙을 적용. 단일 또는 두 단어. CapWords는 예외 이름 및기본 제공 상수에만 사용. Type Variable Names 자료형 변수(PEP484에 도입)의 이름은일반적으로 CapWords를 사용ex)T, AnyStr, Num. 공변 / 반공변 동작을선언하는데 사용되는 변수에는_co나 _contra접미사를추가하는 것이 좋다. from typing import TypeVarVT_co = TypeVar(&#39;VT_co&#39;, covariant=True)KT_contra = TypeVar(&#39;KT_contra&#39;, contravariant=True) Exception Names 예외는 클래스가 될 수 있기 때문에클래스 규칙이 적용된다.하지만, 접미사 “Error”를 붙인다. Global Variable Names 이 변수들은 하나의 모듈 내에서만사용되기를 바란다는데 그렇게 쓰라는건지그런 상황에 대한 묘사인건지전자로 생각함. 함수랑 규칙이 거의 같음. from M import *을 통해사용하도록 설계된 모듈은__all__메커니즘을 사용하여전역을 내보내는 것을 방지하거나이러한 전역에 밑줄을 접두사를 쓴다.(이런 글로벌이 “비공개 모듈”임을나타내기 위해 쓸 수 있음)(which you might want to doto indicate these globalsare “module non-public”). Function and Variable Names 소문자로 씀 가독성을 위해 밑줄로 단어 구분 변수는 함수랑 동일한 규칙 mixCase는이전 버전에서 이미 널리 쓰인 경우호환성을 유지하기 위해 허용됨. Function and Method Arguments instance method 항상 첫 arg에 self를 사용. class method 항상 첫 arg에 cls 사용 함수 인수의 이름이예약어와 충돌하는 경우일반적으로 약어나맞춤법 손상을 하는 것보다후행 밑줄을 추가하는 것이 좋음.동의어를 사용이 더 좋고. Method Names and Instance Variables function과 같음. 비공개 메서드 또는인스턴스 변수에 대해서만선행 밑줄을 사용. 서브클래스와의 이름 충돌을 피하려면두 개의 선행 밑줄을 사용해Python의 Name Mangling 규칙을 호출. Name Mangling 프로그램에서함수나 변수를 선언했을 때,선언시 사용했던 이름을컴파일러가 컴파일 단계에서일정한 규칙을 가지고 변형하는 것 예시로는Java에서 Overloading으로오버로딩 시 같은 함수명을컴파일러가 구분할 수 있는 이유는인자의 형식과 갯수가 다를 경우네임 맹글링을 통해함수나 변수명 뒤에추가 정보가 붙어 구별이 되기 때문. C/C++을 혼합해서 쓸 때extern “C”도 이런거. Python은 이러한 이름을클래스 이름으로 Mangling함.Foo 클래스에 __a라는 속성이 있으면Foo.__a에서 액세스할 수 없다.(집요한 사용자는Foo._Foo__a를 호출하여액세스 권한을 얻을 수 있음.)일반적으로 이중 선행 밑줄은하위 클래스로 설계된 클래스의속성과 이름 충돌을피하기 위해서만 사용. Constants 상수는 일반적으로모듈 수준에서 정의되며단어를 구분하는밑줄과 대문자로만 작성.ex) MAX_OVERFLOW , TOTAL. Designing for Inheritance 항상 클래스의 메소드와인스턴스 변수(“속성”)가공개 또는 비공개여야 하는지 결정.애매하면 비공개.public 속성을non-public으로 만드는 것보다그 역이 더 쉬움. 공개 속성은이 전 버전과의 호환성을 유지하면서클래스의 관련 없는 클라이언트가사용할 것으로 예상되는 속성. 비공개 속성은제3자가 사용하도록의도되지 않은 속성.비공개 속성이 변경되거나제거되지 않는다는 보장은 없다. 파이썬에서 일반적으로불필요한 양의 작업 없이어떤 속성도 비공개가 아니기 때문에 “비공개(private)”라는 용어를피하도록 한다. 속성의 또 다른 범주는“서브클래스 API” (“protected” 였던.)의일부인 속성이다.일부 클래스는클래스 동작의 측면을확장하거나 수정하기 위해상속되도록 설계했다.이러한 클래스를 디자인할 때어떤 속성이 공개인지,하위 클래스 API의 일부인지,기본 클래스에서만 사용해야 하는지명시적으로 결정한다. 다음은 이를 염두한 Pythonic 지침. 공용 속성에는선행 밑줄이 없어야 한다. 공개 속성 이름이예약된 키워드와 충돌하는 경우 속성 이름에 단일 후행 밑줄을 추가.이것은 약어나잘못된 맞춤법보다 좋다. 그러나 이 규칙에도 불구하고‘cls’는 클래스로 알려진모든 변수나 인수,특히 클래스 메서드의첫 번째 인수에 대해선호되는 철자이다. 참고 1클래스 메서드에 대해서는위의 인수 이름 권장 사항 참조. 단순한 공개 데이터 속성의 경우 복잡한 접근자/변이자 메서드 없이속성 이름만노출하는 것이 가장 좋음. 단순한 데이터 속성이기능적 동작을 확장해야 하는 경우Python은 향후 향상을 위한손쉬운 경로를 제공한다.이 경우 속성을 사용하여간단한 데이터 속성액세스 구문 뒤에기능 구현을 숨긴다. 참고 1캐싱과 같은 부작용은일반적으로 괜찮지만기능적 동작 부작용이 없도록 유지. 참고 2계산 비용이 많이 드는 작업의 경우속성을 사용하지 않는다.속성 표기법은 호출자는 액세스가상대적으로 저렴하다고 믿게 만든다. 클래스가 서브클래싱되도록되어 있고 서브클래스에서사용하지 않으려는 속성이 있는 경우 두 개의 선행 밑줄로이름을 지정하고후행 밑줄은사용하지 않는 것이 좋다.이것은 클래스의 이름이속성 이름으로 맹글링되는이름 맹글링 알고리즘을 호출한다.이렇게 하면 서브클래스에같은 이름의 속성이실수로 포함되는 경우속성 이름 충돌을 방지하는 데 좋다. 참고 1맹글링된 이름에는단순 클래스 이름만 사용되므로하위 클래스가 동일한 클래스의이름과 속성 이름을 모두 선택하면여전히 이름 충돌이 발생한다. 참고 2이름 맹글링은 디버깅 및__getattr__()과 같은특정 용도를 불편하게 만들 수 있다.그러나 이름 맹글링 알고리즘은문서화되어 있으며수동으로 수행하기 쉽다. 참고 3: 모든 사람이 이름 맹글링을좋아하는 것은 아니며실수로 이름이 충돌하지 않도록해야 하는 필요성과고급 발신자가사용할 수 있는 가능성사이에서 균형을 맞춰야함. Public and Internal Interfaces 이전 버전과의 호환성 보장은공용 인터페이스에만 적용됨.따라서 사용자는공용 인터페이스와 내부 인터페이스를명확하게 구분할 수 있어야 함. 문서에서 일반적인하위 호환성 보장에서 면제되는임시 또는 내부 인터페이스로명시적으로 선언하지 않는 한문서화된 인터페이스는 공용으로 간주한다.문서화되지 않은 모든 인터페이스는내부로 간주한다. 내성을 더 잘 지원하기 위해모듈은 __all__ 속성을 사용하여공개 API에서 이름을 명시적으로 선언한다.__all__을 빈 목록으로 설정하면모듈에 공개 API가 없음을 뜻한다. __all__이적절하게 설정된 경우에도내부 인터페이스(패키지, 모듈, 클래스,함수, 속성 또는 기타 이름)는여전히 단일 선행 밑줄 접두사로 시작한다. 포함하는 네임스페이스(패키지, 모듈 또는 클래스)가내부로 간주되는 경우인터페이스도 내부로 간주한다. 가져온 이름은 항상구현 세부 사항으로 간주한다.다른 모듈은 os.path 또는하위 모듈의 기능을 노출하는 패키지의__init__ 모듈과 같이포함하는 모듈 API의명시적으로 문서화된 부분이 아닌 한이러한 가져온 이름에 대한간접 액세스에 의존해서는 안 된다. Programming Recommendations 코드는 Python의 다른 구현인PyPy, Jython, IronPython,Cython, Psyco 등에불이익을 주지 않는 방식으로 작성한다. 라이브러리의 성능에 민감한 부분에서는&#39;&#39;.join() 형식을 대신 사용한다.이렇게 하면 다양한 구현에서선형 시간에 연결이 발생할것을 보장한다. None과 같은 싱글톤과의 비교는항상 is 또는 is not으로 하며절대 평등 연산자가 아님. 또한 “if x가 None이 아닌 경우”일 때“if x”를 쓰는 것에 주의한다.기본값이 None인 변수 또는 인수가다른 값으로 설정되었는지 테스트할 때.다른 값은 bool 컨텍스트에서거짓일 수 있는 유형(예: 컨테이너)을가질 수 있다. not ... is가 아닌is not ... 연산자 사용.두 식은 기능적으로 동일하지만is not ...이 읽기 쉽다. # Correct:if foo is not None: # Wrong:if not foo is None: 풍부한 비교를 통해순서 지정 작업을 구현할 때다른 코드에 의존해 특정 비교만 하지 않고__eq__, __ne__,__lt__, __le__,__gt__, __ge__의6가지 모두 구현하는 것이 가장 좋음. 관련된 노력을 최소화하기 위해functools.total_ordering()데코레이터는 누락된 비교 메서드를생성하는 도구를 제공. “PEP 207”은 반사 규칙이Python에 의해 가정됨을 나타냄.따라서 인터프리터는y &amp;gt; x를 x &amp;lt; y로,y &amp;gt;= x를 x &amp;lt;= y로 바꾸고,x == y와 x != y의인수를 바꿀 수 있다.sort() 및 min() 연산은&amp;lt; 연산자를,max() 함수는&amp;gt; 연산자 사용을 보장.그러나 다른 컨텍스트에서혼동이 발생하지 않도록6가지를 모두 구현하는 것이 가장 좋다. 람다 식을 식별자에 직접 바인딩하는할당 문 대신 항상 def 문을 사용. # Correct: def f(x): return 2*x # Wrong:f = lambda x: 2*x 첫 번째 형식은 결과 함수 객체의 이름이일반 &amp;lt;lambda&amp;gt; 대신구체적으로 ‘f’라는 것을 의미한다.이것은 일반적으로트레이스백 및 문자열 표현에 더 유용하다.할당 문을 사용하면더 큰 식에 포함시킬 수 있는명시적 정의 문 보다람다 식이 제공할 수 있는유일한 이점이 제거된다. BaseException이 아닌Exception에서 예외를 파생한다.BaseException에서 직접 상속하는 것은거의 항상 잘못된 작업인예외를 위해 예약된다. Exception 계층은예외가 발생하는 위치가 아니라예외를 포착하는 코드가필요로 할 가능성이 높은구분에 기반하여 설계한다. “문제가 발생했습니다.”라고만 말하지 않고“무엇이 잘못되었습니까?”라는 질문에프로그래밍 방식으로 답변하는 것을목표로 한다(내장 예외 계층에 대해 학습된이 교훈의 예는 PEP 3151 참조). 예외가 오류인 경우예외 클래스에 접미사“Error”를 추가하는데클래스 명명 규칙을 적용한다.비로컬 흐름 제어 또는다른 형태의 신호 전달에 사용되는비오류 예외에는특별한 접미사가 필요없다. exception chaining을 적절하게 사용한다.Rise X from Y는 원래트레이스백을 잃지 않고명시적인 대체를 나타낼 수 있다.내부 예외를 의도적으로 교체할 때(raise X from None 사용) 관련 세부 정보가새 예외로 전송되는지 확인한다.(예: KeyError를 AttributeError로변환할 때 속성 이름을 유지하거나원래 예외의 텍스트를새 예외 메시지에 포함). exception catching때는 그대로 쓰는것보다 특정 예외를 언급```pythontry: import platform_specific_moduleexcept ImportError: platform_specific_module = None exception: 절은SystemExit 및 KeyboardInterrupt예외를 포착하여 Control-C로프로그램을 중단하기 어렵게 만들고다른 문제를 위장할 수 있다.프로그램 오류를 알리는모든 예외를 포착하려면except Exception:을 사용.(bareexcept는except BaseException:과 동일). 경험상 exception은다음 두 가지로 제한하는 것이 좋다. 예외 핸들러가 트레이스백을 출력하거나 기록할 경우 적어도 사용자는오류가 발생했음을 알 수 있음. 코드에서 일부 정리 작업을 수행해야 하지만 예외가 raise로 위쪽으로 전파되도록 하는 경우 try...finally가 이 경우를 처리하는 더 좋은 방법일 수 있다. 운영 체제 오류를 탐지할 때는“errno” 값의 내성보다Python 3.3에 도입된명시적 예외 계층을 선호한다. 또한 모든 try/except 절에 대해try 절을 필요한 최소 코드 양으로 제한.이것은 마스킹 버그를 방지. # Correct:try: value = collection[key]except KeyError: return key_not_found(key)else: return handle_value(value)# Wrong:try: # Too broad! return handle_value(collection[key])except KeyError: # Will also catch KeyError raised by handle_value() return key_not_found(key) 리소스가 코드의 특정 섹션에 로컬인 경우사용 후 신속하고 안정적으로 정리되도록with 문을 사용한다. try/finally도 가능. 컨텍스트 관리자는 리소스 획득 및해제 이외의 작업을 수행할 때마다별도의 함수 또는 메서드를 통해 호출. # Correct:with conn.begin_transaction(): do_stuff_in_transaction(conn) # Wrong:with conn: do_stuff_in_transaction(conn) 후자의 예에서는__enter__ 및__exit__ 메서드가트랜잭션 후 연결을 닫는 것 이외의작업을 수행한다는 것을나타내는 정보가 없다.이 경우에는 명시적인 것이 중요합니다. return 문에서 일관성을 유지해야 한다.함수의 모든 return 문은표현식을 반환해야 하거나아무 것도 반환하지 않아야 한다. 반환 문이 표현식을 반환하는 경우값이 반환되지 않는 모든 반환 문은이를 명시적으로return None으로 명시해야 하며명시적 반환 문이 함수 끝에 있어야 한다(도달할 수 있는 경우): # Correct:def foo(x): if x &amp;gt;= 0: return math.sqrt(x) else: return Nonedef bar(x): if x &amp;lt; 0: return None return math.sqrt(x) # Wrong:def foo(x): if x &amp;gt;= 0: return math.sqrt(x)def bar(x): if x &amp;lt; 0: return return math.sqrt(x) 문자열 슬라이싱 대신&#39;&#39;.startswith() 및&#39;&#39;.endswith()를 사용하여접두사 또는 접미사를 확인한다.startswith() 및 endwith()는더 깨끗하고 오류가 덜 발생. # Correct:if foo.startswith(&#39;bar&#39;):# Wrong:if foo[:3] == &#39;bar&#39;: 객체 유형 비교는유형을 직접 비교하는 대신항상 isinstance()를 사용한다. # Correct:if isinstance(obj, int): # Wrong:if type(obj) is type(1): 시퀀스(문자열, 목록, 튜플)의 경우빈 시퀀스가 거짓이라는 사실을 사용한다. # Correct:if not seq:if seq: # Wrong:if len(seq):if not len(seq): 상당한 후행 공백에 의존하는문자열 리터럴을 작성하지 않는다.이러한 후행 공백은시각적으로 구별할 수 없으며일부 편집자 (또는 최근에는 reindent.py)가이를 수정할 수 있음. ”==”를 사용해 부울 값을True 또는 False와 비교하지 않는다. # Correct:if greeting:# Wrong:if greeting == True: Worse: # Wrong:if greeting is True: try...finally의 finally 내에서 흐름 제어 문을 권장하지 않음. 이는 그러한 명령문이 finally를 통해 전파되는 활성 예외를 암시적으로 취소하기 때문.```python# Wrong:def foo(): try: 1 / 0 finally: return 42 Function Annotations PEP 484의 승인으로함수 주석에 대한 스타일 규칙이 변경됨. 함수 주석은 PEP 484 구문을 사용한다 이전 섹션에 주석에 대한몇 가지 형식 권장 사항이 있음. 이 PEP에서 이전에 권장되었던주석 스타일에 대한 실험은더 이상 권장하지 않는다. 그러나 stdlib 외부에서는이제 PEP 484 규칙 내에서 실험을 권장. 예를 들어,대규모 타사 library 또는 app을PEP 484 스타일 유형 주석으로마크업하고 해당 주석을 추가하는 것이얼마나 쉬운지 검토하고,주석의 존재가 코드 이해도를높이는지 관찰합니다. Python 표준 라이브러리는이러한 주석을 채택하는 데 있어보수적이어야 하지만새 코드와 대규모 리팩토링에 쓸 수 있음. 함수 주석을 다르게 사용하려는 코드는다음 형식의 주석을 넣는 것이 좋다. # type: ignore 파일 상단 근처에 위치하고유형 검사기가모든 주석을 무시하도록 지시합니다.(유형 검사기의불만 사항을 비활성화하는 보다세분화된 방법은 PEP 484에.) 린터와 마찬가지로 유형 검사기는선택 사항이며 별도의 도구임.기본적으로 Python 인터프리터는유형 검사로 인해메시지를 발행해서는 안 되며주석을 기반으로 동작을 변경해서는 안 됨. 린트(lint) 또는 린터(linter) 소스 코드를 분석하여프로그램 오류, 버그, 스타일 오류,의심스러운 구조체에표시(flag)를 달아놓기 위한도구들을 가리킨다. 유형 검사기를사용하고 싶지 않으면 무시가능.그러나 타사 라이브러리 패키지 사용자는해당 패키지에 대해유형 검사기를 실행할 수 있음.이를 위해 PEP 484는 에서는해당 .py 파일보다유형 검사기가 읽는 .pyi 파일인stub 파일의 사용을 권장. stub 파일은라이브러리와 함께 배포되거나typeshed repo를 통해 별도로(라이브러리 작성자의 허가 하에)배포될 수 있음. Variable Annotations PEP 526은 변수 주석을 도입함.이에 대한 스타일 권장 사항은위에서 설명한함수 주석의 권장 사항과 유사. 모듈 수준 변수, 클래스,인스턴스 변수, 지역 변수에 대한 주석은콜론 뒤에 한 칸 띄움. 콜론 앞에 공백이 없어야 합니다. 할당에 오른쪽이 있는 경우등호는 양쪽에 정확히하나의 공백이 있어야 함. # Correct:code: intclass Point: coords: Tuple[int, int] label: str = &#39;&amp;lt;unknown&amp;gt;&#39; # Wrong:code:int # No space after coloncode : int # Space before colonclass Test: result: int=0 # No spaces around equality sign PEP 526이 Python 3.6에 허용되지만,모든 Python 버전에서스텁 파일에 대한 기본 구문은변수 주석 구문.(자세한 내용은 PEP 484 참조). outro 여기까지 본격적인 시작 전에전반적으로 알아보고 싶은 내용이었다. 주로 기본 적인 이념(?)과작정방법(문법)이 중점. 그 외 pep를 보면 도움이 될게 많은듯.아직 나는 그정도까지 깊이를 갖지 않으므로나중에라도 도움이 되었으면 한다. " }, { "title": "Intro 1", "url": "/posts/Python_Intro_1/", "categories": "Grind, Python", "tags": "python", "date": "2022-04-15 00:00:00 +0900", "snippet": "1. Intro 언젠가의 목표였고 더 늦기전에 하는걸로. 진행중인 다른 프로젝트에서 주 언어이기도 하고 좀 관심이 가서. 쓰다 보니까 이 전 경험에 비춰봤을 때다른점들을 적는 경향이 있음. 아항상 그렇듯 자세히 쓸 것같진않다.알고싶은걸 알게된것만큼 쓸듯하다.2. 특징 고급언어, 인터프리터 방식 언어 고급언어는 좀더 사람에게 친숙한 인터프리터방식은 한줄한줄 해석실행.일반적으로 컴파일하는 방식의java, C#등이 반대포지션. 얕은 식견으로는 코드가다른 언어에 비해 직관적이고 쉽다. c -&amp;gt; java -&amp;gt; C# -&amp;gt; python 순서로배울 기회가 있었는데배운 순서대로 쉬운느낌이었다. c #include &amp;lt;stdio.h&amp;gt;int main(int argc, char** argv) { printf(&quot;Hello world&quot;);} java class Main { public static void main(String[] args) { System.out.println(&quot;Hello, world!&quot;); }} c# using System;class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello, world!&quot;); }} 또는 //C# 10.0 ~ Console.WriteLine(&quot;Hello, world!&quot;); python print(&quot;Hello, world!&quot;) 시작점이되는 예를들면 main까지쓸게 많은건 생각보다 귀찮음.namespace, class, main,import, using 등등막상 ide도움없이 쓸때 한번씩 막힘.. 실행할 내용 외에 주렁주렁 쓸게 적은게인터프리터 방식이라 그렇다고.얼추 본것같음. library가 많다.는데 이건 사실다른 언어도 비슷하지 않을까 싶다 다만, 언어가 쓰기 쉽다는 특성이랑 엮여서복잡하게 다른걸로 이 작업을 하느니파이선으로 호로록 하는게 많아지고그러다보니 사용 빈도가 늘어나는것같다. 별개로, data science, ML등의 분야에서관련 library가 강세인것같음. 해서 생산성이 좋음. 근데 느리다함.물론 이게 보일정도로 써보진 않았음.3. PEP 여기 정보가 많다. 참고하자. https://peps.python.org/# 다음 몇 개만 보고 넘어간다.3.1 PEP 1 – PEP Purpose and Guidelines What is a PEP? PEP stands for Python Enhancement Proposal. A PEP is a design document providing information to the Python community, or describing a new feature for Python or its processes or environment. The PEP should provide a concise technical specification of the feature and a rationale for the feature.We intend PEPs to be the primary mechanisms for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python. The PEP author is responsible for building consensus within the community and documenting dissenting opinions.Because the PEPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal. This historical record is available by the normal git commands for retrieving older revisions, and can also be browsed on [GitHub](https://github.com/python/peps). Python 커뮤니티에 정보를 제공하거나Python 또는 Python의 프로세스 또는환경에 대한 새로운 기능을 설명하는design document(? 설계문서?). 라는데 아무튼 정해진 규약이나,그 외 기본이념 등 언어 전반에 걸친내용을 정리해 좋은것. 3.2 PEP 20 – The Zen of Python zen은 ‘선’ 이라는데 뭔지 모르겠다. 마음을 가다듬고 정신을 통일하여 무아정적(無我靜寂)의 경지에 도달하는 정신 집중의 수행(修行) 방법. 명상과 정신 통일로써 번뇌를 끊고 진실의 법칙을 체득하는 일을 말한다. 라고하는데 일종의 기본 이념?같은거라 생각하면 될듯. 아래 19개가 그 내용. Beautiful is better than ugly. 못생긴것보다 이쁜게 좋다. Explicit is better than implicit. 암시적인것보다 명시적인게 좋다. Simple is better than complex. 복잡한것보다 간단한게 좋다. Complex is better than complicated. 복잡한것보다 복잡한게 좋다. 개소리하나 싶었는데… Complex는 쉬운지 어려운지보다많은 요소로 이루어진 것(&amp;lt;-&amp;gt; simple) Complicated는어려움의 정도와 관계(&amp;lt;-&amp;gt; easy) 한 뭉탱이에 다 박아넣어어렵게 하지말고 조각조각 많더라도좀 쉽게하라는뜻인가? 난해한것보다 명확해질 수 있아면길더라도 복잡한게 좋다 이런건가? Flat is better than nested. 중첩보다 수평적인게 좋다 nest가 쌓아올린 구조의 뜻도 있나봄. Sparse is better than dense. 빽빽한것보다 널널한게 좋다. Readability counts. 가독성은 중요하다. Special cases aren’t specialenough to break the rules. 특수한 경우는규칙을 깰만큼 특수하지 않다. Although practicality beats purity. 뭐라는건지 모르겠음. 순수함보다 실용성이란 뜻인가?그 반댄가?? Errors should never pass silently. 에러는 조용히 지나가서는 안된다. Unless explicitly silenced. 명시적으로 묵과하는게 아니라면. 위랑 이어지는 내용? In the face of ambiguity,refuse the temptation to guess. 모호함에 직면했을 때,추측하려는 유혹을 거부한다. ambiguity는 애매한 표현을 말하는듯직감이 아니라 증거에 기반하라는것같음.pep목적도 그렇고. There should be one–and preferably only one–obvious way to do it. 무언가를 할 수 있는 방법은하나만 있어야 한다. ?? Although that way may not be obviousat first unless you’re Dutch. 처음에는 그 방법이확실치 않을 수 있다. 위랑 이어지는듯 위꺼랑 합쳐서 당신이 네덜란드 사람이 아니라면처음에는 그 방법이분명하지 않을 수 있지만 하나의-그리고 바람직하게는 단 하나의-분명한 방법이 있어야 함. 네덜란드는 왜? Now is better than never. 안하는것보다 지금 하는게 더 좋다. Although never is often betterthan right now. 하는것보다 안하는것이 좋을지라도. If the implementation is hardto explain, it’s a bad idea. 구현한것을 설명하기 힘들다면나쁜 아이디어다. If the implementation is easyto explain, it may be a good idea. 구현한것을 설명하기 쉽다면좋은 아이디어다. Namespaces areone honking great idea– let’s do more of those! Namespaces는 좋은 아이디어다. 더 써라. Outro PEP 20은 보편적으로 좋은 내용인것같다.코딩할 때 참고하면 좋겠다 싶었다. 아무튼 깔끔, 명확, 단순이 주 키워드인듯. import this하면 이 내용이 나옴. 해석이 틀릴 수 있는건 한국인이기때문.참고 pythontutor" }, { "title": "17. Tuple", "url": "/posts/CS_17_Tuple/", "categories": "Grind, C#", "tags": "c#, tuple", "date": "2022-02-17 12:00:00 +0900", "snippet": "Intro “exchange two variables without temp C#”을 검색 중 찾게된게 있는데1그 답이 Tuple쓰면 된다하길래보다가 남겨봄.Tuple types C# 7.0 부터 간단한 데이터 구조에서여러 데이터 요소를 그룹화 하기위해 사용 튜플 유형은 값 유형 이고튜플 요소는 공개 필드임이는 튜플을 가변값 유형으로 만듭니다. .NET Framework 4.7 이상에서 사용가능하고.NET Framework 4.6.2 이하는NuGet 패키지 System.ValueTuple를 추가.Example 기본적으로 이래됨 Tuple&amp;lt;int, string&amp;gt; t1 = new Tuple&amp;lt;int, string&amp;gt;(1, &quot;test1&quot;);Console.WriteLine(t1);(int, string) t2 = (2, &quot;test2&quot;);Console.WriteLine(t2);var t3 = (3, &quot;test3&quot;);Console.WriteLine(t3);Console.WriteLine(t3.Item1);Console.WriteLine(t3.Item2);(int count, string name) t4 = (4, &quot;test4&quot;);Console.WriteLine(t4);Console.WriteLine(t4.count);Console.WriteLine(t4.name);var t5 = (count:5, name:&quot;test5&quot;);//var t5 = (count, name : 5, &quot;test5&quot;);Console.WriteLine(t5);Console.WriteLine(t5.count);Console.WriteLine(t5.name);var t6 = Tuple.Create(6, &quot;test6&quot;);Console.WriteLine(t6);var sum = 4.5;var count = 3;var t = (sum, count);Console.WriteLine($&quot;Sum of {t.count} elements is {t.sum}.&quot;);// (1, test1)// (2, test2)// (3, test3)// 3// test3// (4, test4)// 4// test4// (5, test5)// 5// test5// (6, test6) t1 처럼 쓰는 일은 거의 없어보임 더 간단한게 많아보이는데뭐.. 또, 이 방법은element name을 명시 못하는것같음.내가 못찾았거나.. element name 기본은 .Item?로 정해짐.?는 element 순서 t3처럼 대충 하고 t3.Item?로 접근 가능 이걸 t4처럼 명시적으로 이름도 지어줄 수 있음이걸 t5 처럼도 가능 명시적으로 이름을 지어도 .Item? 는 여전히 가능 t 처럼 대충해도 변수 이름으로 유추해준다함. 다만 Item?, ToString또는 Rest나중복이면 element이름으로 불가능 t6 처럼도 되는데 1~8개 element만 됨 원래 튜플에 element 수에 대한 제한은 없음 일반적으로 var xs = new[] { 4, 7, 9 };var limits = FindMinMax(xs);Console.WriteLine($&quot;Limits of [{string.Join(&quot; &quot;, xs)}] are {limits.min} and {limits.max}&quot;);// Output:// Limits of [4 7 9] are 4 and 9var ys = new[] { -9, 0, 67, 100 };var (minimum, maximum) = FindMinMax(ys);Console.WriteLine($&quot;Limits of [{string.Join(&quot; &quot;, ys)}] are {minimum} and {maximum}&quot;);// Output:// Limits of [-9 0 67 100] are -9 and 100(int min, int max) FindMinMax(int[] input){ if (input is null || input.Length == 0) { throw new ArgumentException(&quot;Cannot find minimum and maximum of a null or empty array.&quot;); } var min = int.MaxValue; var max = int.MinValue; foreach (var i in input) { if (i &amp;lt; min) { min = i; } if (i &amp;gt; max) { max = i; } } return (min, max);} 이게 그래서 list로 return하는거랑 뭐다름? 했는데데이터형이 여러개여도 한번에 담을수 있고암튼 편한듯? return을 여러개 쓰는 방법은 ref,out 등이 있었는데그런 방법들 보다 이게 더 간편하다함. Tuple assignment and deconstructionassignment 튜플 간의 할당은 다음 조건을 모두 충족하는 경우 가능. 두 튜플 모두 동일한 수의 요소를 가집니다. 각 튜플 element에 대해오른쪽 튜플 요소의 유형은 해당왼쪽 튜플 요소의 유형과동일하거나 암시적으로 변환 가능해야함. 튜플 element 값은 순서에 따라 할당.이름은 무시되고 할당되지 않음. (int, double) t1 = (17, 3.14);(double First, double Second) t2 = (0.0, 1.0);t2 = t1;Console.WriteLine($&quot;{nameof(t2)}: {t2.First} and {t2.Second}&quot;);// Output:// t2: 17 and 3.14(double A, double B) t3 = (2.0, 3.0);t3 = t2;Console.WriteLine($&quot;{nameof(t3)}: {t3.A} and {t3.B}&quot;);// Output:// t3: 17 and 3.14 deconstruction =(할당 연산자)을 사용해별도의 변수에서 튜플 인스턴스를 분해 할 수 있음.다음 방법 중 하나로 이를 수행할 수 있다. 괄호 안에 각 변수의 유형을 명시적으로 선언. var t = (&quot;post office&quot;, 3.6);(string destination, double distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers.Console.WriteLine(destination); 괄호 외부에 var 키워드를 사용해암시적으로 형식이 지정된 변수를 선언하고컴파일러가 해당 형식을 유추하게함. var t = (&quot;post office&quot;, 3.6);var (destination, distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers. 기존 변수 사용 var destination = string.Empty;var distance = 0.0;var t = (&quot;post office&quot;, 3.6);(destination, distance) = t;Console.WriteLine($&quot;Distance to {destination} is {distance} kilometers.&quot;);// Output:// Distance to post office is 3.6 kilometers. Tuple equality(int a, byte b) left = (5, 10);(long a, int b) right = (5, 10);Console.WriteLine(left == right); // output: TrueConsole.WriteLine(left != right); // output: Falsevar t1 = (A: 5, B: 10);var t2 = (B: 5, A: 10);Console.WriteLine(t1 == t2); // output: TrueConsole.WriteLine(t1 != t2); // output: False element name은 신경 안씀. C# 7.3부터 == 및 != 연산자 지원. 비교가 가능한 조건은 동일한 수의 element. 각 element들은 비교 가능해야함. 예를 들어, (1, (2, 3)) == ((1, 2), 3) 은1이 (1, 2)와 비교할 수 없기 때문에 컴파일되지 않음. == 및 != 연산자는 튜플을 단락 방식으로 비교.즉, 같지 않은 한 쌍의 요소를 만나거나튜플의 끝에 도달하는 즉시 종료.그러나 비교하기 전에 다음 예제와 같이모든 튜플 요소가 평가됨. Console.WriteLine((Display(1), Display(2)) == (Display(3), Display(4)));int Display(int s){ Console.WriteLine(s); return s;}// Output:// 1// 2// 3// 4// False 비교때 문제가 생기면 바로 끝나는데그 전에 별개로 실행은 다 된다는것같음. Tuples as out parameters 일반적으로 out 매개 변수가 있는 메서드를튜플을 반환하는 메서드로 리팩터링함. 그러나 out 매개변수가튜플 유형일 수 있는 경우가 있음. 다음 예는 튜플을 out 매개변수로 사용하는 방법. var limitsLookup = new Dictionary&amp;lt;int, (int Min, int Max)&amp;gt;(){ [2] = (4, 10), [4] = (10, 20), [6] = (0, 23)};if (limitsLookup.TryGetValue(4, out (int Min, int Max) limits)){ Console.WriteLine($&quot;Found limits: min is {limits.Min}, max is {limits.Max}&quot;);}// Output:// Found limits: min is 10, max is 20 Tuples vs System.Tuple System.ValueTuple 형식으로 지원되는 C# 튜플은System.Tuple 형식으로 표시되는 튜플과 다름.주요 차이점은 다음과 같습니다. System.ValueTuple 형식은 값 형식.System.Tuple 형식은 참조 형식. System.ValueTuple 유형은 변경 가능.System.Tuple 형식은 변경할 수 없음. System.ValueTuple 형식의 데이터 멤버는 필드.System.Tuple 형식의 데이터 멤버는 속성. 참고 Swap two variables without using a temporary variable &amp;#8617; " }, { "title": "16. Callback", "url": "/posts/CS_16_Callback/", "categories": "Grind, C#", "tags": "c#", "date": "2021-12-15 12:15:00 +0900", "snippet": "Delegate - Event - Callback Callback이라는 키워드는 delegate할때,그 뒤 event할떄 같이 언급된다. 찾으면 질문도 많고 답변도 많은데딱 이해됐다기보다 아 이런느낌이구나 정도.What is Callback? 일단 위키의 설명을 보면 프로그래밍에서 콜백(callback) 또는 콜애프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다. 라고한다. 조금더 쉽게 하면 “실행가능한코드”만 method로 바꾸면 된다. 간단한 예 class Test4 { public delegate void delegatecallback(int i); delegatecallback dc; public delegate void eventcallback(int _i, delegatecallback _delegatecallback); event eventcallback ec; public Test4() { dc += mtd_2; mtd_1(0, dc); // ec += mtd_1; // ec(1, dc); } void mtd_1(int _i, delegatecallback _delegatecallback) { for (int i = _i; i &amp;lt; 5; i++) { if (i%2 == 0) { _delegatecallback(i); } } } void mtd_2(int i) { Console.WriteLine(i); } } mtd_1은 parameter로 int, delegatecallback을 받는다 delegatecallback은 mtd_2가 연결 되어있다. mtd_1은 실행 중 조건에 따라 delegatecallback을 호출하고 그 결과 mtd_2가 실행된다. 하나더..1 List&amp;lt;string&amp;gt; names = new List&amp;lt;string&amp;gt;(); names.Add(&quot;Bruce&quot;); names.Add(&quot;Alfred&quot;); names.Add(&quot;Tim&quot;); names.Add(&quot;Richard&quot;); // Display the contents of the list using the Print method. names.ForEach(Print); // The following demonstrates the anonymous method feature of C# // to display the contents of the list to the console. names.ForEach(delegate(string name) { Console.WriteLine(name); }); void Print(string s) { Console.WriteLine(s); } /* This code will produce output similar to the following: * Bruce * Alfred * Tim * Richard * Bruce * Alfred * Tim * Richard */ ForEach의 정의는2 public void ForEach(Action&amp;lt;T&amp;gt; action) { if( action == null) { ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match); } Contract.EndContractBlock(); int version = _version; for(int i = 0 ; i &amp;lt; _size; i++) { if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5) { break; } action(_items[i]); } if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5) ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion); } 일단, 쉽게보면 위와같은 형태가 callback인데 처음 접할 때 이게 뭔소리지 싶은건 “A=B”다 처럼 딱 떨어지는게 아니라 일종의 패턴같은거라서 그런갑다. 아무튼 C#에서는 delegate를 사용해 구현한다. 방법은 delegate를 parameter로 넘져주는 방식. 사실 이 전에 delegate에 대해 쓴 글에있는데 “use delegate as parameter”의 내용 그래서 delegate를 시작으로 저 셋이 자주 엮인것. delegate : 근본 event : delegate의 특수한 형태 callback : parameter로 delegate를 이용한것. 차피 딴설명 이해도 안되서 대충 이해가 되는 내용만 적어보면 parameter로 delegate를 넘겨 실제 method를 호출 가능하게 함. 흐름상 직접 호출하는 method에 “이것도 같이 해줘”느낌으로 던지는것처럼 보인다. Why Callback??? 잘 모르겠음 이걸 정리하는게 이 글 목적이었다.. 예를들어 Linq의 경우 사용시 가독성이 좋아지고, 결과 데이터의 새 형식생성이 쉬운 등 확연히 이점이 있어 보이는데 이 경우는 좀 달라보임. 아마 이게 delegate를 넘겨주는 “패턴”이기때문으로 보임. 아님 내 지식이 짧거나…… 다만, 내가 느끼기에 delegate, event, callback등 다시말해 delegate와 그 파생군은 쓸때 안쓸때 차이점이라면 코딩하는데 좀더 유연해지는것 같다. 여기는 정리가 잘 안되서 중구난방 하다가 다 날림… 그냥 느낌만 알고 넘어가고나중에 정리 가능해지면 수정관련 내용은 아래 읽어보는게 더 나을듯.참고 delagate, event, callback What is a callback function? How to explain callbacks in plain english? Events and Callbacks 콜백 Callback 함수 콜백 함수 관련 질문 입니다. C# callback advantage(google) What is the real advantage of using a CallBack? Advantages of using delegates? Why use a callback in C#? Callback Operation By Delegate Or Interface List&amp;lt;T&amp;gt;.ForEach Method &amp;#8617; List&amp;lt;T&amp;gt; Reference &amp;#8617; " }, { "title": "15. Delegate, Event", "url": "/posts/CS_15_Delegate_Event/", "categories": "Grind, C#", "tags": "c#", "date": "2021-10-01 12:00:00 +0900", "snippet": "intro delegate를 찾다보면 꼭 따라오는 두 키워드가 더 있다. event callback 그 중 event, delegate는 형태나 쓰임새나 비슷해 보여서한번 정리할겸 쓴다. callback은 뒤에서 따로 하기로하고.Delegate vs Event 둘 다 비슷해 보이는데 비슷한 시기에 막 등장. delegate를 찾다보면 event랑 엮어서같이 설명하는게가 많아서 그런가봄. 하기전에 비슷한점을 보면 실제 사용될 method를 연결은 +=로 함 호출하면 다른게 트리거된다는점(+=로 연결한것.) 정도? 비슷한건 이게 다인것같은데이럴거면 왜 구분지어 사용하나 싶음. 둘 사이 차이점을 찾아보면 공통적인 설명이 event는 delegate의 일종으로 특수한 형태. event는 class외부에서 사용하지 못함. delegate는 쌉가능. class외부에서 추가(+=)는 됨. event는 “=” 연산자 사용 못함. Event1. event는 delegate의 특수한 형태이다? form에 Load자동생성한다. private void Form1_Load(object sender, EventArgs e){ throw new System.NotImplementedException();} 이떄 designer에는 다음이 생성된다. this.Load += new System.EventHandler(this.Form1_Load); 여기까지 자주보는 .. 이 Load를 따라가 보면 public event EventHandler Load{ add =&amp;gt; this.Events.AddHandler(Form.EVENT_LOAD, (Delegate) value); remove =&amp;gt; this.Events.RemoveHandler(Form.EVENT_LOAD, (Delegate) value);} 여기 event는 쓰여진 자리로봐서 알겠지만 그냥 키워드임. “async”때처럼 “여긴 이런 기능을 할겁니다” 느낌. 그럼 EventHandler은? namespace System{ [ComVisible(true)] [__DynamicallyInvokable] [Serializable] public delegate void EventHandler(object sender, EventArgs e);} 미리 만들어놓은 delegate 시그니처였음 익숙한 순서로 정리해보면 //delegate 시그니처 정의public delegate void EventHandler(object sender, EventArgs e); //event키워드가 붙은 delegate정의public event EventHandler Load{ add =&amp;gt; this.Events.AddHandler(Form.EVENT_LOAD, (Delegate) value); remove =&amp;gt; this.Events.RemoveHandler(Form.EVENT_LOAD, (Delegate) value);}//트리거될 method 연결this.Load += new System.EventHandler(this.Form1_Load);//실제 methodprivate void Form1_Load(object sender, EventArgs e){ throw new System.NotImplementedException();} 요 순서대로 하면 전에 delegate쓰던거랑 같음 event를 빼고 똑같이 만들면 보통의 delegate가 됨. public delegate void EventHandler_1(object sender, EventArgs e); public EventHandler_1 evt_1; 이런식으로. 따라서 event는 delegate의 특수한 형태가 맞다. event는 키워드로써 아무튼 delegate를 인첸트 시켰겠지.뭔진 아직 모르겠고. 2. event는 class외부에서 사용하지 못한다? 예를들어 class Program{ static void Main(string[] args) { Console.WriteLine(&quot;Hello World!&quot;); Test1 t = new Test1(); //delegate t.evt_1 += t.TestDelegate; t.evt_1 += T1_tempevent; //event t.evt_2 += t.TestEvent; t.evt_2 += T1_tempevent; t.evt_1(new object(), new EventArgs()); //t.evt_2(new object(), new EventArgs()); //컴파일에러 } private static void T1_tempevent(object sender, EventArgs e) { Console.WriteLine(&quot;T1_tempevent&quot;); }}///////////////////////////////public class Test1{ //delegate public delegate void EventHandler_1(object sender, EventArgs e); public EventHandler_1 evt_1; //event public delegate void EventHandler_2(object sender, EventArgs e); public event EventHandler_2 evt_2; public Test1() { evt_2 += TestEvent; evt_2(new object(), new EventArgs()); } public void TestDelegate(object sender, EventArgs e) { Console.WriteLine(&quot;delegate&quot;); } public void TestEvent(object sender, EventArgs e) { Console.WriteLine(&quot;event&quot;); } } Program class에서 t.evt_2 += t.TestEvent;즉, 이벤트에 메서드 추가는 됨. 단, 주석처리된t.evt_2(new object(), new EventArgs());이부분은 안되는데 내용이 The event ‘evt_2’ can only appear on the left hand side of += or -= (except when used from within the class ‘DelegateEvent.Test1’) 라고함. 쫌 더 보편적으로 말하면 event는 +=의 왼쪽에만 쓰일 수 있는데 event가 선언 된 class는 상관 없다로 보임. 다시말해 event가 선언되었던 class가 아니면 event에 method추가외의 호출은 불가. 단, event의 호출은 event가 선언된 class내부에서만 되지만event에 대한 구독은 외부에서도 가능 (T1_tempevent) 정리하면 ‘외부에서 사용’의 의미는‘선언되었던 class외부에서 호출이 가능하냐’는 뜻이고, 불가능하다. event call은 event가 선언된 class내부에서만 가능 event에 대한 subscribe는 제약이 없다면 내/외부 다 가능. subscribe할 method도 제약이 없다면 내/외부 상관없음. 3. event는 “=” 연산자 사용 못함? 위 예의 Program class에서t.evt_2 += t.TestEvent;는 += 를 = 로 바꾸면 에러가 난다.내용은 위에꺼랑 동일. Test1 class의 evt_2 += TestEvent;에서 +=대신 =를 써도 상관없음. 대신 덮어써지겠지만.. 위에 에러 내용을 다시 보면 (except when used from within the class ‘DelegateEvent.Test1’) 이 부분이 있는데 event가 선언됐던 class내부에서는 =나 +=나 딱히 상관없는듯함. 꼭 저런 형태여야하는가? event의 기본 뼈대가 delegate니까 변형도 가능할듯. parameter 추가 return값 추가 public class Test1{ //delegate public delegate void EventHandler_1(object sender, EventArgs e); public EventHandler_1 evt_1; //event public delegate void EventHandler_2(object sender, EventArgs e); public event EventHandler_2 evt_2; //event 2 public delegate int EventHandler_3(object sender, EventArgs e, int i); public event EventHandler_3 evt_3; public Test1() { evt_2 += TestEvent; evt_2(new object(), new EventArgs()); evt_3 += TestEvent_2; evt_3 += TestEvent_3; int i = evt_3(new object(), new EventArgs(), 3); Console.WriteLine(i); } public void TestDelegate(object sender, EventArgs e) { Console.WriteLine(&quot;delegate&quot;); } public void TestEvent(object sender, EventArgs e) { Console.WriteLine(&quot;event&quot;); } public int TestEvent_2(object sender, EventArgs e, int i) { Console.WriteLine(&quot;event2&quot;); return i * i; } public int TestEvent_3(object sender, EventArgs e, int i) { Console.WriteLine(&quot;event3&quot;); return i + i;/ (EventHandler_3)item }} 물론 parameter를 설정하는건 자유. return이 문제가 되는 부분인데 보통 event에는 return이 없음. 만들때는 return이 있어도 상관없는데event에 연결된 method가 많을경우(위처럼)return된 값은 마지막에 실행(연결)된method의 return값만 받을 수 있음 이래서 void를 주로 쓰는것같고void아기 때문에 chain인 상황에서트리거될 method들에게 통지하는 모습으로 보여지게됨. 아무튼 이런 이유때문에 일반적으로 void만 쓴다면임의로 event를 만들어 쓸때도 이 방식을 따르는게 맞아보임. EventArgs 지금까지 예시에 parameter로 항상(object sender, EventArgs e)이게 들어갔음. object는 event를 발생시킨주체로예를들어 buttonclick은 button 등등 EventArgs는 event의 정보를 나타내는데 이벤트 데이터를 포함하는 클래스의 기본 클래스.이벤트 데이터를 포함하지 않는 이벤트에 사용할 값 제공. 그래서 이벤트에 별다른 값이 필요하지 않는 것들 ex) form.closed, form.load등 EventArgs내부에도 사실 별 내용이 없긴함 그 외 이벤트에 따로 값이 필요한것들은 여기서 파생해서 사용. ex) MouseDown, , MouseClick등 에서의 MouseEventArgs. 여기는 부가적으로 위치, 클릭획수 등의 정보가 더 들어감. EventArgs를 접미사로씀. 만약 event를 새 형식으로 만들어 사용한다면 public class Test2{ delegate void CustomEventDelegate(object o, CusTomEventArgs e); event CustomEventDelegate CusTomEventHandler; public Test2() { CusTomEventHandler += temp; CusTomEventHandler(this, new CusTomEventArgs() { msg = &quot;message&quot;, cnt = 123 }); } void temp(object o, CusTomEventArgs e) { Console.WriteLine(string.Format(&quot;msg:{0}\\ncnt:{1}&quot;,e.msg,e.cnt)); }}public class CusTomEventArgs: EventArgs{ public string msg; public int cnt;} class CusTomEventArgs를 보면 EventArgs를 상속받는데EventArgs가 기본형이니까 이걸 토대로 만드는것처럼보임. 이 형식을 따른 예제들이 자주보여 쓰긴했는데object랑 eventargs가 꼭 필요한가싶음.그냥 없이 간단하게 써도 될듯함. 는 어림도 없지 아래 이벤트2 읽다보면 EventArgs를 기본으로 하던가이거 상속하는걸 권장하고있음. 왜 event? delegate를 만들고 이걸 Action, Func로 표준화함. 이해됨. 자주쓰인다니까 귀찮아서 만들었겠지. delegate/event 둘 다 시그니처 선언하고그에 맞는 method연결하고 시그니처 호출하면연결되어있던 method들이 트리거됨 여기까지 공통. 그런데 delegate에 제약을 거는event라는 키워드를 붙임.같은 동작인데 왜 제약을 줬을까? delegate 자유도 event라는 제약없이 delegate라면,method추가는 =, += 둘 다 가능한데이 경우 모두 트리거됬어야될 상황이=으로 사라질 수 있다.다시말해 초기화의 위험성이 있다.그래서 event가 선언되었던 class내부에서는=을 허용한게 아닐까 싶다. 그럼 호출도 이런의미로 생각하면 될듯.예를들어 Form.Load를 아무데서나 쓸 수 있게 하면좀 헷갈릴것같기도하고..그래서 Refresh()나 RaiseKeyEvent(,)같은걸 만들어event는 class내부에서만 호출하고그 비슷한 기능이 필요한 경우를 위해저렇게 따로 만들어 놓은것같음. Access Modifiers access가 외부에서 되지 않는다는 점 때문에처음생각엔 event라는 키워드가 없러라도간단히 public을 안쓰면 되지않나 생각해봤는데 public protected internal private public,private는 당연히 안되고 protected는 외부호출을 막으면서method추가도 할 수 없게됨.상속을 받아야 하는데 그렇게 보면 event가 선녀임. internal은 되나싶었는데외부참조한 곳의 event는 못쓰게됨 어차피 한정자에 대한 설명을 한번 더 쓴것같긴한데 어쨌든 위 키워드 넷 다 애매하게 빗나감. 결과적으로 delegate에 대한 subscribe는자유롭게 할 수 있으면서임의의 위치에서 호출을 막고초기화의 위험을 줄이는 용도로이걸 쓴다하면 대퉁 맞는것같음.참고 이벤트1 이벤트2 이벤트와 델리게이트 C# event 이벤트 개념 잡기와 만들기 이벤드 만들고 사용하기 C# 이벤트 Delegate에서 Event로" }, { "title": "14. LINQ 2", "url": "/posts/CS_14_Linq_2/", "categories": "Grind, C#", "tags": "c#, linq", "date": "2021-08-21 12:00:00 +0900", "snippet": "쿼리쿼리 식 이 전 내용은 표준 쿼리식과 그 키워드에 관한 내용들. 절 Description from 데이터 소스와 범위 변수(반복 변수와 유사함)를 지정. where 논리적 AND 및 OR 연산자(&amp;amp;&amp;amp; 또는 ||)로 구분된하나 이상의 부울 식을 기준으로소스 요소를 필터링. select 쿼리를 실행할 때 반환된 시퀀스의 요소에 사용할 형식 및 모양을 지정. group 지정된 키 값에 따라 쿼리 결과를 그룹화. into join, group 또는 select 절의 결과에 대한참조로 사용할 수 있는 식별자 제공. orderby 요소 형식에 대한 기본 비교자에 따라오름차순 또는 내림차순으로 쿼리 결과를 정렬. join 지정한 두 일치 조건 간의같음 비교를 기반으로 두 데이터 소스를 조인. let 쿼리 식에 하위 식 결과를 저장할 범위 변수 도입. in join 절의 상황별 키워드. on join 절의 상황별 키워드. equals join 절의 상황별 키워드. by group 절의 상황별 키워드. ascending orderby 절의 상황별 키워드. descending orderby 절의 상황별 키워드. 이상 내용들은 이 전 내용 또는 없으면 나중에 추가하겠지.. 쿼리 연산자 LINQ 패턴을 형성하는 메서드. 이 중 대부분은 sequences라는 형식 개체에서 동작 IEnumerable&amp;lt;T&amp;gt; 인터페이스 IQueryable&amp;lt;T&amp;gt; 인터페이스 위 둘을 구현함. 필터링, 프로젝션, 집계, 정렬 등 다양한 쿼리 기능 제공. 두 가지 LINQ 표준 쿼리 연산자 집합이 있다. IEnumerable&amp;lt;T&amp;gt; 형식의 개체와 작동하는 연산자, IQueryable&amp;lt;T&amp;gt; 형식의 개체와 작동하는 연산자 각 집합을 구성하는 메서드는 각각 Enumerable 및 Queryable 클래스의 정적 멤버. 작동하는 형식의 확장 메서드로 정의. 확장 메서드는 정적 메서드 구문 또는인스턴스 메서드 구문을 사용하여 호출할 수 있다. 아래 method 예시에 이 두 경우 모두 씀 AsEnumerable() : 대부분의 경우 기본이Enumerable 형이거나 이 키워드는 생략 가능한듯 AsQueryable은 꼭 명시 해줘야되는데Enumerable이면서 Queryable은안되는 경우가 가끔 있음 몇 가지 표준 쿼리 연산자 메서드는IEnumerable&amp;lt;T&amp;gt; 또는 IQueryable&amp;lt;T&amp;gt; 이외의 형식에서 작동. Enumerable 형식은둘 다 IEnumerable 형식의 개체에서 작동하는두 가지 메서드를 정의. 이러한 메서드Cast&amp;lt;TResult&amp;gt;(IEnumerable) 및OfType&amp;lt;TResult&amp;gt;(IEnumerable)을 사용하면매개 변수화되지 않거나제네릭이 아닌 컬렉션을LINQ 패턴에서 쿼리 할 수 있음. 강력한 형식의 개체 컬렉션을 만들어 이를 수행. Queryable 클래스는IQueryable 형식의 개체에서 작동하는Cast&amp;lt;TResult&amp;gt;(IQueryable) 및OfType&amp;lt;TResult&amp;gt;(IQueryable)의두 가지 유사한 메서드를 정의. 표준 쿼리 연산자는 반환값에따라 실행되는 타이밍이 다름. 단일 값 또는 시퀀스가 있음. singleton 값(예: Average 및 Sum)을 반환하는 메서드는 즉시 실행. 시퀀스를 반환하는 메서드는 쿼리실행을 지연하고 열거 가능한 개체를 반환. IEnumerable&amp;lt;T&amp;gt;을 확장하는 메서드 메모리 내 컬렉션에 대해 작동하는 메서드 반환된 열거 가능한 개체는 메서드에 전달된 인수를 캡처. 해당 개체를 열거하는 경우쿼리 연산자의 논리가 사용되며쿼리 결과가 반환. IQueryable&amp;lt;T&amp;gt;을 확장하는 메서드 쿼리 동작을 구현하지 않음. 수행할 쿼리를 나타내는 식 트리를 빌드. 쿼리 처리는 IQueryable&amp;lt;T&amp;gt; 개체에 의해 처리. 쿼리 메서드에 대한 호출을 하나의 쿼리로 함께 연결할 수 있으므로쿼리가 임의로 복잡해질 수 있다. 식 / 연산자 비교 string sentence = &quot;the quick brown fox jumps over the lazy dog&quot;; // Split the string into individual words to create a collection. string[] words = sentence.Split(&#39; &#39;); // Using query expression syntax. var query = from word in words group word.ToUpper() by word.Length into gr orderby gr.Key select new { Length = gr.Key, Words = gr }; // Using method-based query syntax. var query2 = words. GroupBy(w =&amp;gt; w.Length, w =&amp;gt; w.ToUpper()). Select(g =&amp;gt; new { Length = g.Key, Words = g }). OrderBy(o =&amp;gt; o.Length); foreach (var obj in query) { Console.WriteLine(&quot;Words of length {0}:&quot;, obj.Length); foreach (string word in obj.Words) Console.WriteLine(word); } // This code example produces the following output: // // Words of length 3: // THE // FOX // THE // DOG // Words of length 4: // OVER // LAZY // Words of length 5: // QUICK // BROWN // JUMPS 분류 Sorting Data Set Operations Filtering Data Quantifier Operations Projection Operations Partitioning Data Join Operations Grouping Data Generation Operations Equality Operations Element Operations Converting Data Types Concatenation Operations Aggregation Operations Sorting Data(C#) 하나 이상의 특성을 기준으로 시퀀스의 요소를 정렬. 첫 번째 정렬 기준은 요소에 대해 기본 정렬을 수행. 두 번째 정렬 기준을 지정하면 각 기본 정렬 그룹 내의 요소를 정렬.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 OrderBy 값을 오름차순으로 정렬. orderby Enumerable.OrderByQueryable.OrderBy OrderByDescending 값을 내림차순으로 정렬. orderby … descending Enumerable.OrderByDescendingQueryable.OrderByDescending ThenBy 2차 정렬을 오름차순으로 정렬. orderby …, … Enumerable.ThenByQueryable.ThenBy ThenByDescending 2차 정렬을 내림차순으로 정렬. orderby …, … descending Enumerable.ThenByDescendingQueryable.ThenByDescending Reverse 컬렉션에서 요소의 순서를 반대로 정렬. 해당 사항 없음. Enumerable.ReverseQueryable.Reverse OrderBy class Pet{ public string Name { get; set; } public int Age { get; set; }}public static void OrderByEx1(){ Pet[] pets = { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; IEnumerable&amp;lt;Pet&amp;gt; query = pets .OrderBy(pet =&amp;gt; pet.Age); IEnumerable&amp;lt;Pet&amp;gt; query = pets .AsQueryable() .OrderBy(pet =&amp;gt; pet.Age); foreach (Pet pet in query) { Console.WriteLine(&quot;{0} - {1}&quot;, pet.Name, pet.Age); }}/*This code produces the following output:Whiskers - 1Boots - 4Barley - 8*/ OrderByDescending /// &amp;lt;summary&amp;gt;/// This IComparer class sorts by the fractional part of the decimal number./// &amp;lt;/summary&amp;gt;public class SpecialComparer : IComparer&amp;lt;decimal&amp;gt;{ /// &amp;lt;summary&amp;gt; /// Compare two decimal numbers by their fractional parts. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;d1&quot;&amp;gt;The first decimal to compare.&amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;d2&quot;&amp;gt;The second decimal to compare.&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;1 if the first decimal&#39;s fractional part /// is greater than the second decimal&#39;s fractional part, /// -1 if the first decimal&#39;s fractional /// part is less than the second decimal&#39;s fractional part, /// or the result of calling Decimal.Compare() /// if the fractional parts are equal.&amp;lt;/returns&amp;gt; public int Compare(decimal d1, decimal d2) { decimal fractional1, fractional2; // Get the fractional part of the first number. try { fractional1 = decimal.Remainder(d1, decimal.Floor(d1)); } catch (DivideByZeroException) { fractional1 = d1; } // Get the fractional part of the second number. try { fractional2 = decimal.Remainder(d2, decimal.Floor(d2)); } catch (DivideByZeroException) { fractional2 = d2; } if (fractional1 == fractional2) return Decimal.Compare(d1, d2); else if (fractional1 &amp;gt; fractional2) return 1; else return -1; }}public static void OrderByDescendingEx1(){ List&amp;lt;decimal&amp;gt; decimals = new List&amp;lt;decimal&amp;gt; { 6.2m, 8.3m, 0.5m, 1.3m, 6.3m, 9.7m }; IEnumerable&amp;lt;decimal&amp;gt; query = decimals .OrderByDescending(num =&amp;gt; num, new SpecialComparer()); IEnumerable&amp;lt;decimal&amp;gt; query = decimals .AsQueryable() .OrderByDescending(num =&amp;gt; num, new SpecialComparer()); foreach (decimal num in query) { Console.WriteLine(num); }}/*This code produces the following output:9.70.58.36.31.36.2*/ ThenBy string[] fruits = { &quot;grape&quot;, &quot;passionfruit&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;raspberry&quot;, &quot;apple&quot;, &quot;blueberry&quot; };// Sort the strings first by their length and then//alphabetically by passing the identity selector function.IEnumerable&amp;lt;string&amp;gt; query = fruits .OrderBy(fruit =&amp;gt; fruit.Length) .ThenBy(fruit =&amp;gt; fruit);IEnumerable&amp;lt;string&amp;gt; query = fruits .AsQueryable() .OrderBy(fruit =&amp;gt; fruit.Length) .ThenBy(fruit =&amp;gt; fruit);foreach (string fruit in query){ Console.WriteLine(fruit);}/* This code produces the following output: apple grape mango banana orange blueberry raspberry passionfruit*/ ThenByDescending public class CaseInsensitiveComparer : IComparer&amp;lt;string&amp;gt;{ public int Compare(string x, string y) { return string.Compare(x, y, true); }}public static void ThenByDescendingEx1(){ string[] fruits = { &quot;apPLe&quot;, &quot;baNanA&quot;, &quot;apple&quot;, &quot;APple&quot;, &quot;orange&quot;, &quot;BAnana&quot;, &quot;ORANGE&quot;, &quot;apPLE&quot; }; // Sort the strings first ascending by their length and // then descending using a custom case insensitive comparer. IEnumerable&amp;lt;string&amp;gt; query = fruits .OrderBy(fruit =&amp;gt; fruit.Length) .ThenByDescending(fruit =&amp;gt; fruit, new CaseInsensitiveComparer()); IEnumerable&amp;lt;string&amp;gt; query = fruits .AsQueryable() .OrderBy(fruit =&amp;gt; fruit.Length) .ThenByDescending(fruit =&amp;gt; fruit, new CaseInsensitiveComparer()); foreach (string fruit in query) { Console.WriteLine(fruit); }}/* This code produces the following output: apPLe apple APple apPLE orange ORANGE baNanA BAnana*/ Reverse char[] apple = { &#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39; };char[] reversed = apple.Reverse().ToArray();IQueryable&amp;lt;char&amp;gt; reversed = apple.AsQueryable().Reverse();foreach (char chr in reversed){ Console.Write(chr + &quot; &quot;);}Console.WriteLine();/*This code produces the following output:e l p p a*/ Set Operations 동일 컬렉션이나 별개 컬렉션(또는 집합)에동등한 요소가 있는지 여부에 따라결과 집합을 생성하는 쿼리 작업.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Distinct 컬렉션에서 중복 값을 제거. 해당 사항 없음. Enumerable.DistinctQueryable.Distinct Except 두 번째 컬렉션에 표시되지 않는한 컬렉션의 요소를 의미하는 차집합을 반환. 해당 사항 없음. Enumerable.ExceptQueryable.Except Intersect 두 컬렉션에 공통으로 표시되는 교집합을 반환. 해당 사항 없음. Enumerable.IntersectQueryable.Intersect Union 두 컬렉션 모두 포함한 합집합을 반환. 해당 사항 없음. Enumerable.UnionQueryable.Union Distinct List&amp;lt;int&amp;gt; ages = new List&amp;lt;int&amp;gt; { 21, 46, 46, 55, 17, 21, 55, 55 };IEnumerable&amp;lt;int&amp;gt; distinctAges = ages.Distinct();IEnumerable&amp;lt;int&amp;gt; distinctAges = ages.AsQueryable().Distinct();Console.WriteLine(&quot;Distinct ages:&quot;);foreach (int age in distinctAges){ Console.WriteLine(age);}/*This code produces the following output:Distinct ages:21465517*/ Except double[] numbers1 = { 2.0, 2.0, 2.1, 2.2, 2.3, 2.3, 2.4, 2.5 };double[] numbers2 = { 2.2 };IEnumerable&amp;lt;double&amp;gt; onlyInFirstSet = numbers1 .Except(numbers2);IEnumerable&amp;lt;double&amp;gt; onlyInFirstSet = numbers1 .AsQueryable() .Except(numbers2);foreach (double number in onlyInFirstSet) Console.WriteLine(number);/*This code produces the following output:22.12.32.42.5*/ Intersect int[] id1 = { 44, 26, 92, 30, 71, 38 };int[] id2 = { 39, 59, 83, 47, 26, 4, 30 };// Get the numbers that occur in both arrays (id1 and id2).IEnumerable&amp;lt;int&amp;gt; both = id1 .Intersect(id2);IEnumerable&amp;lt;int&amp;gt; both = id1 .AsQueryable() .Intersect(id2);foreach (int id in both) Console.WriteLine(id);/* This code produces the following output: 26 30*/ Union int[] ints1 = { 5, 3, 9, 7, 5, 9, 3, 7 };int[] ints2 = { 8, 3, 6, 4, 4, 9, 1, 0 };// Get the set union of the items in the two arrays.IEnumerable&amp;lt;int&amp;gt; union = ints1 .Union(ints2);IEnumerable&amp;lt;int&amp;gt; union = ints1 .AsQueryable() .Union(ints2);foreach (int num in union) Console.Write(&quot;{0} &quot;, num);/* This code produces the following output: 5 3 9 7 8 6 4 1 0*/ Filtering Data 지정된 조건을 충족하는 요소만 포함하도록 결과 집합을 제한. 필터링은 선택이라고도 한다.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 OfType 지정된 형식으로 캐스트할 수 있는지 여부에 따라 값을 선택. 해당 사항 없음. Enumerable.OfTypeQueryable.OfType Where 조건자 함수를 기반으로 하는 값을 선택. where Enumerable.WhereQueryable.Where OfType IList fruits = new List&amp;lt;object&amp;gt;();fruits.Add(&quot;Mango&quot;);fruits.Add(&quot;Orange&quot;);fruits.Add(&quot;Apple&quot;);fruits.Add(3.0);fruits.Add(&quot;Banana&quot;);// Apply OfType() to the ArrayList.IEnumerable&amp;lt;string&amp;gt; query1 = fruits .OfType&amp;lt;string&amp;gt;();IQueryable&amp;lt;string&amp;gt; query1_1 = fruits .AsQueryable() .OfType&amp;lt;string&amp;gt;();Console.WriteLine(&quot;Elements of type &#39;string&#39; are:&quot;);foreach (string fruit in query1){ Console.WriteLine(fruit);}// The following query shows that the standard query operators such as// Where() can be applied to the ArrayList type after calling OfType().IEnumerable&amp;lt;string&amp;gt; query2 = fruits .OfType&amp;lt;string&amp;gt;() .Where(fruit =&amp;gt; fruit.ToLower().Contains(&quot;n&quot;));IEnumerable&amp;lt;string&amp;gt; query2_2 = fruits .AsQueryable() .OfType&amp;lt;string&amp;gt;() .Where(fruit =&amp;gt; fruit.ToLower().Contains(&quot;n&quot;));Console.WriteLine(&quot;\\nThe following strings contain &#39;n&#39;:&quot;);foreach (string fruit in query2){ Console.WriteLine(fruit);}// This code produces the following output://// Elements of type &#39;string&#39; are:// Mango// Orange// Apple// Banana//// The following strings contain &#39;n&#39;:// Mango// Orange// Banana Where int[] numbers = { 0, 30, 20, 15, 90, 85, 40, 75 };// Get all the numbers that are less than or equal to// the product of their index in the array and 10.IEnumerable&amp;lt;int&amp;gt; query = numbers .Where((number, index) =&amp;gt; number &amp;lt;= index * 10);IEnumerable&amp;lt;int&amp;gt; query = numbers .AsQueryable() .Where((number, index) =&amp;gt; number &amp;lt;= index * 10);foreach (int number in query) Console.WriteLine(number);/* This code produces the following output: 0 20 15 40*/ Quantifier Operations 수량자 작업은 시퀀스에서 조건을 충족하는 요소가일부인지 전체인지를 나타내는 Boolean 값.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 All 모든 요소가 조건을 만족하는지를 확인. 해당 사항 없음. Enumerable.AllQueryable.All Any 임의의 요소가 조건을 만족하는지를 확인. 해당 사항 없음. Enumerable.AnyQueryable.Any Contains 지정된 요소가 들어 있는지를 확인. 해당 사항 없음. Enumerable.ContainsQueryable.Contains All public static void AllEx2(){ List&amp;lt;Person&amp;gt; people = new List&amp;lt;Person&amp;gt; { new Person { LastName = &quot;Haas&quot;, Pets = new Pet[] { new Pet { Name=&quot;Barley&quot;, Age=10 }, new Pet { Name=&quot;Boots&quot;, Age=14 }, new Pet { Name=&quot;Whiskers&quot;, Age=6 } } }, new Person { LastName = &quot;Fakhouri&quot;, Pets = new Pet[] { new Pet { Name = &quot;Snowball&quot;, Age = 1} } }, new Person { LastName = &quot;Antebi&quot;, Pets = new Pet[] { new Pet { Name = &quot;Belle&quot;, Age = 8} } }, new Person { LastName = &quot;Philips&quot;, Pets = new Pet[] { new Pet { Name = &quot;Sweetie&quot;, Age = 2}, new Pet { Name = &quot;Rover&quot;, Age = 13} } } }; // Determine which people have pets that are all older than 5. IEnumerable&amp;lt;Person&amp;gt; p = people .Where(person =&amp;gt; person.Pets.All(pet =&amp;gt; pet.Age &amp;gt; 5)); IEnumerable&amp;lt;Person&amp;gt; p = people .AsQueryable() .Where(person =&amp;gt; person.Pets.All(pet =&amp;gt; pet.Age &amp;gt; 5)); foreach (var pp in p) { Console.WriteLine(pp.LastName); } IEnumerable&amp;lt;string&amp;gt; names = from person in people where person.Pets.All(pet =&amp;gt; pet.Age &amp;gt; 5) select person.LastName; IEnumerable&amp;lt;string&amp;gt; names = from person in people where person.Pets.AsQueryable().All(pet =&amp;gt; pet.Age &amp;gt; 5) select person.LastName; foreach (string name in names) { Console.WriteLine(name); } /* This code produces the following output: * Haas * Antebi * Haas * Antebi */}class Pet{ public string Name { get; set; } public int Age { get; set; }}class Person{ public string LastName { get; set; } public Pet[] Pets { get; set; }} Any public static void AllEx2(){ List&amp;lt;Person&amp;gt; people = new List&amp;lt;Person&amp;gt; { new Person { LastName = &quot;Haas&quot;, Pets = new Pet[] { new Pet { Name=&quot;Barley&quot;, Age=10 }, new Pet { Name=&quot;Boots&quot;, Age=14 }, new Pet { Name=&quot;Whiskers&quot;, Age=6 } } }, new Person { LastName = &quot;Fakhouri&quot;, Pets = new Pet[] { new Pet { Name = &quot;Snowball&quot;, Age = 1} } }, new Person { LastName = &quot;Antebi&quot;, Pets = new Pet[] { } }, new Person { LastName = &quot;Philips&quot;, Pets = new Pet[] { new Pet { Name = &quot;Sweetie&quot;, Age = 2}, new Pet { Name = &quot;Rover&quot;, Age = 13} } } }; IEnumerable&amp;lt;Person&amp;gt; p = people .Where(person =&amp;gt; person.Pets.Any()); IEnumerable&amp;lt;Person&amp;gt; p = people .AsQueryable().Where(person =&amp;gt; person.Pets.Any()); foreach (var person in p) { Console.WriteLine(person.LastName); } // Determine which people have a non-empty Pet array. IEnumerable&amp;lt;string&amp;gt; names = from person in people where person.Pets.Any() select person.LastName; IEnumerable&amp;lt;string&amp;gt; names = from person in people where person.Pets.AsQueryable().Any() select person.LastName; foreach (string name in names) { Console.WriteLine(name); } /* This code produces the following output: Haas Fakhouri Philips */}class Pet{ public string Name { get; set; } public int Age { get; set; }}class Person{ public string LastName { get; set; } public Pet[] Pets { get; set; }} Contains string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };string fruit = &quot;mango&quot;;bool hasMango = fruits .Contains(fruit);bool hasMango = fruits .AsQueryable() .Contains(mango);Console.WriteLine( &quot;The array {0} contain &#39;{1}&#39;.&quot;, hasMango ? &quot;does&quot; : &quot;does not&quot;, fruit);// This code produces the following output://// The array does contain &#39;mango&#39;. Projection Operations 프로젝션은 주로 이후에 사용할 속성으로만 구성된새 양식으로 개체를 변환하는 작업을 가리킵니다. 프로젝션을 사용하면 각 개체를 기반으로 만들어지는새 형식을 생성할 수 있습니다. 속성을 프로젝션하고 속성에서 수학 함수를 수행할 수 있습니다. 원래 개체를 변경하지 않고 프로젝션할 수도 있습니다.Select 및 SelectMany 둘 다의 작업은 소스 값에서 결과 값(value (or values))을 생성. Select()는 모든 소스 값에 대해 하나의 결과 값을 생성합니다.따라서 전체 결과는 소스 컬렉션과 동일한 개수의 요소가 들어 있는 컬렉션. SelectMany()는 각 소스 값에서 연결된 하위 컬렉션을 포함하는하나의 전체 결과를 생성. SelectMany()에 대한 인수로 전달되는 변환 함수는각 소스 값에 대해 열거 가능한 값 시퀀스를 반환해야 한다.이러한 열거 가능한 시퀀스는 SelectMany()에 의해 연결되어하나의 큰 시퀀스를 만든다. Select - SelectMany class Bouquet { public List&amp;lt;string&amp;gt; Flowers { get; set; } } static void SelectVsSelectMany() { List&amp;lt;Bouquet&amp;gt; bouquets = new List&amp;lt;Bouquet&amp;gt;() { new Bouquet{ Flowers = new List&amp;lt;string&amp;gt; { &quot;sunflower&quot;, &quot;daisy&quot;, &quot;daffodil&quot;, &quot;larkspur&quot; }}, new Bouquet{ Flowers = new List&amp;lt;string&amp;gt; { &quot;tulip&quot;, &quot;rose&quot;, &quot;orchid&quot; }}, new Bouquet{ Flowers = new List&amp;lt;string&amp;gt; { &quot;gladiolis&quot;, &quot;lily&quot;, &quot;snapdragon&quot;, &quot;aster&quot;, &quot;protea&quot; }}, new Bouquet{ Flowers = new List&amp;lt;string&amp;gt; { &quot;larkspur&quot;, &quot;lilac&quot;, &quot;iris&quot;, &quot;dahlia&quot; }} }; // *********** Select *********** IEnumerable&amp;lt;List&amp;lt;string&amp;gt;&amp;gt; query1 = bouquets .Select(bq =&amp;gt; bq.Flowers); var query1_1 = from bq in bouquets select bq.Flowers; Console.WriteLine(&quot;\\nResults by using Select(): method&quot;); // Note the extra foreach loop here. foreach (IEnumerable&amp;lt;String&amp;gt; collection in query1) { foreach (string item in collection) { Console.WriteLine(item); } } Console.WriteLine(&quot;\\nResults by using Select(): expression&quot;); foreach (List&amp;lt;string&amp;gt; item in query1_1) { foreach (string sitem in item) { Console.WriteLine(sitem); } } // ********* SelectMany ********* IEnumerable&amp;lt;string&amp;gt; query2 = bouquets .SelectMany(bq =&amp;gt; bq.Flowers); var query2_2 = from bq in bouquets from fl in bq.Flowers select fl; var query2_3 = from bq in bouquets select bq.Flowers into fl from f in fl select f; Console.WriteLine(&quot;\\nResults by using SelectMany(): method&quot;); foreach (string item in query2) { Console.WriteLine(item); } Console.WriteLine(&quot;\\nResults by using SelectMany(): expression1&quot;); foreach (string item in query2_2) { Console.WriteLine(item); } Console.WriteLine(&quot;\\nResults by using SelectMany(): expression2&quot;); foreach (string item in query2_3) { Console.WriteLine(item); }/*Results by using Select(): methodsunflowerdaisydaffodillarkspurtuliproseorchidgladiolislilysnapdragonasterprotealarkspurlilacirisdahliaResults by using Select(): expressionsunflowerdaisydaffodillarkspurtuliproseorchidgladiolislilysnapdragonasterprotealarkspurlilacirisdahliaResults by using SelectMany(): methodsunflowerdaisydaffodillarkspurtuliproseorchidgladiolislilysnapdragonasterprotealarkspurlilacirisdahliaResults by using SelectMany(): expression1sunflowerdaisydaffodillarkspurtuliproseorchidgladiolislilysnapdragonasterprotealarkspurlilacirisdahliaResults by using SelectMany(): expression2sunflowerdaisydaffodillarkspurtuliproseorchidgladiolislilysnapdragonasterprotealarkspurlilacirisdahlia*/ 비교하자면 이런 차이. select로 나올 수 있는 결과값이각각 단일 개체가 아닌하위에 다시 컬렉션 형태를 갖고있는 경우SelectMany로 묶어 한번에 표현. expression에서는 다중 from 으로 표현하던가쿼리결과를 다중으로 반복문을 써서 검색. 메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Select 변환 함수를 기반으로 하는 값을 프로젝션. select Enumerable.SelectQueryable.Select SelectMany 변환 함수를 기반으로 하는 값의 시퀀스를 프로젝션한 다음하나의 시퀀스로 평면화합. 여러 from 절 사용 Enumerable.SelectManyQueryable.SelectMany Select string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;,&quot;passionfruit&quot;, &quot;grape&quot; };// Project an anonymous type that contains the// index of the string in the source array, and// a string that contains the same number of characters// as the string&#39;s index in the source array.var query = fruits .Select((fruit, index) =&amp;gt; new { index, str = fruit.Substring(0, index) });var query = fruits .AsQueryable() .Select((fruit, index) =&amp;gt; new { index, str = fruit.Substring(0, index) });foreach (var obj in query) Console.WriteLine(&quot;{0}&quot;, obj);/* This code produces the following output: { index = 0, str = } { index = 1, str = b } { index = 2, str = ma } { index = 3, str = ora } { index = 4, str = pass } { index = 5, str = grape }*/ SelectMany class PetOwner{ public string Name { get; set; } public List&amp;lt;string&amp;gt; Pets { get; set; }}public static void SelectManyEx2(){ PetOwner[] petOwners = { new PetOwner { Name=&quot;Higa, Sidney&quot;, Pets = new List&amp;lt;string&amp;gt;{ &quot;Scruffy&quot;, &quot;Sam&quot; } }, new PetOwner { Name=&quot;Ashkenazi, Ronen&quot;, Pets = new List&amp;lt;string&amp;gt;{ &quot;Walker&quot;, &quot;Sugar&quot; } }, new PetOwner { Name=&quot;Price, Vernette&quot;, Pets = new List&amp;lt;string&amp;gt;{ &quot;Scratches&quot;, &quot;Diesel&quot; } }, new PetOwner { Name=&quot;Hines, Patrick&quot;, Pets = new List&amp;lt;string&amp;gt;{ &quot;Dusty&quot; } } }; // For each PetOwner element in the source array, // project a sequence of strings where each string // consists of the index of the PetOwner element in the // source array and the name of each pet in PetOwner.Pets. IEnumerable&amp;lt;string&amp;gt; query = petOwners .SelectMany ( (petOwner, index) =&amp;gt; petOwner.Pets.Select(pet =&amp;gt; index + pet) ); IEnumerable&amp;lt;string&amp;gt; query = petOwners .AsQueryable() .SelectMany ( (petOwner, index) =&amp;gt; petOwner.Pets.Select(pet =&amp;gt; index + pet) ); foreach (string pet in query) Console.WriteLine(pet);}// This code produces the following output://// 0Scruffy// 0Sam// 1Walker// 1Sugar// 2Scratches// 2Diesel// 3Dusty Partitioning Data(C#) LINQ의 분할은 요소를 다시 정렬한 후섹션 중 하나를 반환하지 않고입력 시퀀스를 두 개의 섹션으로 나눔.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Skip 시퀀스에서 지정한 위치까지 요소를 건너뜀. 해당 사항 없음. Enumerable.SkipQueryable.Skip SkipWhile 요소가 조건을 충족하지 않을 때까지조건자 함수를 기반으로 하여 요소를 건너뜀. 해당 사항 없음. Enumerable.SkipWhileQueryable.SkipWhile Take 시퀀스에서 지정된 위치까지 요소를 사용. 해당 사항 없음. Enumerable.TakeQueryable.Take TakeWhile 요소가 조건을 충족하지 않을 때까지조건자 함수를 기반으로 하여 요소를 사용. 해당 사항 없음. Enumerable.TakeWhileQueryable.TakeWhile Skip int[] grades = { 59, 82, 70, 56, 92, 98, 85 };// Sort the grades in descending order and// get all except the first three.IEnumerable&amp;lt;int&amp;gt; lowerGrades = grades .OrderByDescending(g =&amp;gt; g) .Skip(3);IEnumerable&amp;lt;int&amp;gt; lowerGrades = grades .AsQueryable() .OrderByDescending(g =&amp;gt; g) .Skip(3);Console.WriteLine(&quot;All grades except the top three are:&quot;);foreach (int grade in lowerGrades) Console.WriteLine(grade);/* This code produces the following output: All grades except the top three are: 82 70 59 56*/ SkipWhile int[] amounts = { 5000, 2500, 9000, 8000, 6500, 4000, 1500, 55000 };// Skip over amounts in the array until the first amount// that is less than or equal to the product of its// index in the array and 1000. Take the remaining items.IEnumerable&amp;lt;int&amp;gt; query = amounts .SkipWhile((amount, index) =&amp;gt; amount &amp;gt; index * 1000);IEnumerable&amp;lt;int&amp;gt; query = amounts .AsQueryable() .SkipWhile((amount, index) =&amp;gt; amount &amp;gt; index * 1000);foreach (int amount in query) Console.WriteLine(amount);/* This code produces the following output: 4000 1500 55000*/ 조건을 충족하면 건너뛰는거에 주의. 처음 조건 만족 안하는 개체부터 이후 전부 반영 Take int[] grades = { 59, 82, 70, 56, 92, 98, 85 };// Sort the grades in descending order and take the first three.IEnumerable&amp;lt;int&amp;gt; topThreeGrades = grades .OrderByDescending(grade =&amp;gt; grade) .Take(3);IEnumerable&amp;lt;int&amp;gt; topThreeGrades = grades .AsQueryable() .OrderByDescending(grade =&amp;gt; grade) .Take(3);Console.WriteLine(&quot;The top three grades are:&quot;);foreach (int grade in topThreeGrades) Console.WriteLine(grade);/* This code produces the following output: The top three grades are: 98 92 85*/ TakeWhile string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };// Take strings from the array until a string// that is equal to &quot;orange&quot; is found.IEnumerable&amp;lt;string&amp;gt; query = fruits .TakeWhile(fruit =&amp;gt; String.Compare(&quot;orange&quot;, fruit, true) != 0);IEnumerable&amp;lt;string&amp;gt; query = fruits .AsQueryable() .TakeWhile(fruit =&amp;gt; String.Compare(&quot;orange&quot;, fruit, true) != 0);foreach (string fruit in query) Console.WriteLine(fruit);/* This code produces the following output: apple banana mango*/ 조건을 충족하면 반영에 주의. 처음 조건 만족 안하는 개체부터 이후 전부 건너뜀 Join Operations 한 데이터 소스의 개체를 공통 특성을 공유하는다른 데이터 소스의 개체와 연결. 서로 간의 관계를 직접 적용할 수 없는데이터 원본을 대상으로 하는 쿼리에서는 Join이 중요. 객체 지향 프로그래밍에서 이것은단방향 관계의 역방향과 같이모델링되지 않은 객체 간의 상관 관계를 의미 할 수 있음. 단방향 관계의 예로는Customer 클래스가 City 형식 속성을 포함하는데City 클래스는 Customer 개체의 컬렉션인 속성을포함하지 않는 경우. City 개체 목록이 있는 경우각 도시의 모든 고객을 찾으려면조인 작업을 사용해야 함. LINQ 프레임워크에 제공되는 조인 메서드는 Join / GroupJoin. 키가 같은지 여부에 따라 두 데이터 소스의일치 여부를 확인하는 조인인 동등 조인을 수행. 비교를 위해 Transact-SQL에서는‘같음’이 아닌 ‘보다 작음’ 연산자와 같은조인 연산자 지원. Join은 내부 조인을 구현.내부 조인은 다른 데이터 집합에 일치하는 항목이 있는 개체만 반환. GroupJoin 메서드는 내부 조인 및 왼쪽 우선 외부 조인의 상위 집합 구현. 왼쪽 우선 외부 조인은 다른 데이터 소스에 서로 관련된 요소가 없더라도첫 번째(왼쪽) 데이터 소스의 각 요소를 반환. 메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Join 키 선택기 함수를 기준으로두 시퀀스를 Join한 다음값 쌍을 추출합니다. join … in … on … equals … Enumerable.JoinQueryable.Join GroupJoin 키 선택기 함수를 기준으로두 시퀀스를 Join한 다음결과로 생성된 일치 항목을요소마다 그룹화. join … in … on … equals … into … Enumerable.GroupJoinQueryable.GroupJoin Join class Person{ public string Name { get; set; }}class Pet{ public string Name { get; set; } public Person Owner { get; set; }}public static void JoinEx1(){ Person magnus = new Person { Name = &quot;Hedlund, Magnus&quot; }; Person terry = new Person { Name = &quot;Adams, Terry&quot; }; Person charlotte = new Person { Name = &quot;Weiss, Charlotte&quot; }; Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry }; Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry }; Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, Owner = charlotte }; Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus }; List&amp;lt;Person&amp;gt; people = new List&amp;lt;Person&amp;gt; { magnus, terry, charlotte }; List&amp;lt;Pet&amp;gt; pets = new List&amp;lt;Pet&amp;gt; { barley, boots, whiskers, daisy }; // Join the list of Person objects and the list of Pet objects // to create a list of person-pet pairs where each element is // an anonymous type that contains the name of pet and the name // of the person that owns the pet. var query = people .Join ( pets, person =&amp;gt; person, pet =&amp;gt; pet.Owner, (person, pet) =&amp;gt; new { OwnerName = person.Name, Pet = pet.Name } ); var query = people .AsQueryable() .Join ( pets, person =&amp;gt; person, pet =&amp;gt; pet.Owner, (person, pet) =&amp;gt; new { OwnerName = person.Name, Pet = pet.Name } ); foreach (var obj in query) { Console.WriteLine( &quot;{0} - {1}&quot;, obj.OwnerName, obj.Pet); }}/* This code produces the following output: Hedlund, Magnus - Daisy Adams, Terry - Barley Adams, Terry - Boots Weiss, Charlotte - Whiskers*/ GroupJoin class Person{ public string Name { get; set; }}class Pet{ public string Name { get; set; } public Person Owner { get; set; }}public static void GroupJoinEx1(){ Person magnus = new Person { Name = &quot;Hedlund, Magnus&quot; }; Person terry = new Person { Name = &quot;Adams, Terry&quot; }; Person charlotte = new Person { Name = &quot;Weiss, Charlotte&quot; }; Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry }; Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry }; Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, Owner = charlotte }; Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus }; List&amp;lt;Person&amp;gt; people = new List&amp;lt;Person&amp;gt; { magnus, terry, charlotte }; List&amp;lt;Pet&amp;gt; pets = new List&amp;lt;Pet&amp;gt; { barley, boots, whiskers, daisy }; // Create a list where each element is an anonymous // type that contains a person&#39;s name and a collection // of names of the pets that are owned by them. var query = people .GroupJoin ( pets, person =&amp;gt; person, pet =&amp;gt; pet.Owner, (person, petCollection) =&amp;gt; new { OwnerName = person.Name, Pets = petCollection.Select(pet =&amp;gt; pet.Name) } ); var query = people .AsQueryable() .GroupJoin ( pets, person =&amp;gt; person, pet =&amp;gt; pet.Owner, (person, petCollection) =&amp;gt; new { OwnerName = person.Name, Pets = petCollection.Select(pet =&amp;gt; pet.Name) } ); foreach (var obj in query) { // Output the owner&#39;s name. Console.WriteLine(&quot;{0}:&quot;, obj.OwnerName); // Output each of the owner&#39;s pet&#39;s names. foreach (string pet in obj.Pets) Console.WriteLine(&quot; {0}&quot;, pet); }}/* This code produces the following output: Hedlund, Magnus: Daisy Adams, Terry: Barley Boots Weiss, Charlotte: Whiskers*/ Grouping Data 데이터를 그룹에 넣어각 그룹의 요소가 공통 특성을 공유.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 GroupBy 공통 특성을 공유하는 요소를 그룹화.각 그룹은 IGrouping&amp;lt;TKey,TElement&amp;gt; 개체로 표시. group … by또는group … by … into … Enumerable.GroupByQueryable.GroupBy ToLookup 키 선택기 함수에 따라Lookup&amp;lt;TKey,TElement&amp;gt;(일대다 사전)에 요소를 삽입. 해당 사항 없음. Enumerable.ToLookup GroupBy class Pet{ public string Name { get; set; } public double Age { get; set; }}public static void GroupByEx3(){ // Create a list of pets. List&amp;lt;Pet&amp;gt; petsList = new List&amp;lt;Pet&amp;gt; { new Pet { Name=&quot;Barley&quot;, Age=8.3 }, new Pet { Name=&quot;Boots&quot;, Age=4.9 }, new Pet { Name=&quot;Whiskers&quot;, Age=1.5 }, new Pet { Name=&quot;Daisy&quot;, Age=4.3 } }; // Group Pet objects by the Math.Floor of their age. // Then project an anonymous type from each group // that consists of the key, the count of the group&#39;s // elements, and the minimum and maximum age in the group. var query = petsList.GroupBy( pet =&amp;gt; Math.Floor(pet.Age), (age, pets) =&amp;gt; new { Key = age, Count = pets.Count(), Min = pets.Min(pet =&amp;gt; pet.Age), Max = pets.Max(pet =&amp;gt; pet.Age) }); var query = petsList.AsQueryable().GroupBy( pet =&amp;gt; Math.Floor(pet.Age), (age, pets) =&amp;gt; new { Key = age, Count = pets.Count(), Min = pets.Min(pet =&amp;gt; pet.Age), Max = pets.Max(pet =&amp;gt; pet.Age) }); // Iterate over each anonymous type. foreach (var result in query) { Console.WriteLine(&quot;\\nAge group: &quot; + result.Key); Console.WriteLine(&quot;Number of pets in this age group: &quot; + result.Count); Console.WriteLine(&quot;Minimum age: &quot; + result.Min); Console.WriteLine(&quot;Maximum age: &quot; + result.Max); } /* This code produces the following output: Age group: 8 Number of pets in this age group: 1 Minimum age: 8.3 Maximum age: 8.3 Age group: 4 Number of pets in this age group: 2 Minimum age: 4.3 Maximum age: 4.9 Age group: 1 Number of pets in this age group: 1 Minimum age: 1.5 Maximum age: 1.5 */} ToLookup class Package{ public string Company { get; set; } public double Weight { get; set; } public long TrackingNumber { get; set; }}public static void ToLookupEx1(){ // Create a list of Packages. List&amp;lt;Package&amp;gt; packages = new List&amp;lt;Package&amp;gt; { new Package { Company = &quot;Coho Vineyard&quot;, Weight = 25.2, TrackingNumber = 89453312L }, new Package { Company = &quot;Lucerne Publishing&quot;, Weight = 18.7, TrackingNumber = 89112755L }, new Package { Company = &quot;Wingtip Toys&quot;, Weight = 6.0, TrackingNumber = 299456122L }, new Package { Company = &quot;Contoso Pharmaceuticals&quot;, Weight = 9.3, TrackingNumber = 670053128L }, new Package { Company = &quot;Wide World Importers&quot;, Weight = 33.8, TrackingNumber = 4665518773L } }; // Create a Lookup to organize the packages. // Use the first character of Company as the key value. // Select Company appended to TrackingNumber // as the element values of the Lookup. ILookup&amp;lt;char, string&amp;gt; lookup = packages .ToLookup(p =&amp;gt; Convert.ToChar(p.Company.Substring(0, 1)), p =&amp;gt; p.Company + &quot; &quot; + p.TrackingNumber); // Iterate through each IGrouping in the Lookup. foreach (IGrouping&amp;lt;char, string&amp;gt; packageGroup in lookup) { // Print the key value of the IGrouping. Console.WriteLine(packageGroup.Key); // Iterate through each value in the // IGrouping and print its value. foreach (string str in packageGroup) Console.WriteLine(&quot; {0}&quot;, str); }}/*This code produces the following output:C Coho Vineyard 89453312 Contoso Pharmaceuticals 670053128L Lucerne Publishing 89112755W Wingtip Toys 299456122 Wide World Importers 4665518773*/ Generation Operations업 생성은 값의 새 시퀀스를 만드는 작업. 생성을 수행하는 표준 쿼리 연산자 메서드는 다음 섹션에 나열.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 DefaultIfEmpty 빈 컬렉션을 기본값을 갖는 singleton 컬렉션으로 변환. 해당 사항 없음. Enumerable.DefaultIfEmptyQueryable.DefaultIfEmpty Empty 비어 있는 컬렉션을 반환. 해당 사항 없음. Enumerable.Empty Range 일련의 숫자를 포함하는 컬렉션을 생성. 해당 사항 없음. Enumerable.Range Repeat 반복되는 값이 하나 들어 있는 컬렉션을 생성. 해당 사항 없음. Enumerable.Repeat DefaultIfEmpty class Pet{ public string Name { get; set; } public int Age { get; set; }}public static void DefaultIfEmptyEx1(){ // Create a list of Pet objects. List&amp;lt;Pet&amp;gt; pets = new List&amp;lt;Pet&amp;gt; { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; // This query selects only those pets that are 10 or older. // In case there are no pets that meet that criteria, call // DefaultIfEmpty(). This code passes an (optional) default // value to DefaultIfEmpty(). string[] oldPets = pets .Where(pet =&amp;gt; pet.Age &amp;gt;= 10) .Select(pet =&amp;gt; pet.Name) .DefaultIfEmpty(&quot;[EMPTY]&quot;) .ToArray(); string[] oldPets = pets .AsQueryable() .Where(pet =&amp;gt; pet.Age &amp;gt;= 10) .Select(pet =&amp;gt; pet.Name) .DefaultIfEmpty(&quot;[EMPTY]&quot;) .ToArray(); Console.WriteLine(&quot;First query: &quot; + oldPets[0]); // This query selects only those pets that are 10 or older. // This code does not call DefaultIfEmpty(). string[] oldPets2 = pets .Where(pet =&amp;gt; pet.Age &amp;gt;= 10) .Select(pet =&amp;gt; pet.Name) .ToArray(); string[] oldPets2 = pets .AsQueryable() .Where(pet =&amp;gt; pet.Age &amp;gt;= 10) .Select(pet =&amp;gt; pet.Name) .ToArray(); // There may be no elements in the array, so directly // accessing element 0 may throw an exception. try { Console.WriteLine(&quot;Second query: &quot; + oldPets2[0]); } catch (Exception e) { Console.WriteLine(&quot;Second query: An exception was thrown: &quot; + e.Message); }} Empty //example demonstrates how to use Empty&amp;lt;TResult&amp;gt;() //to generate an empty IEnumerable&amp;lt;T&amp;gt;.IEnumerable&amp;lt;decimal&amp;gt; empty = Enumerable.Empty&amp;lt;decimal&amp;gt;();/////////////////////////////////////////////////////string[] names1 = { &quot;Hartono, Tommy&quot; };string[] names2 = { &quot;Adams, Terry&quot;, &quot;Andersen, Henriette Thaulow&quot;, &quot;Hedlund, Magnus&quot;, &quot;Ito, Shu&quot; };string[] names3 = { &quot;Solanki, Ajay&quot;, &quot;Hoeing, Helge&quot;, &quot;Andersen, Henriette Thaulow&quot;, &quot;Potra, Cristina&quot;, &quot;Iallo, Lucio&quot; };List&amp;lt;string[]&amp;gt; namesList = new List&amp;lt;string[]&amp;gt; { names1, names2, names3 };// Only include arrays that have four or more elementsIEnumerable&amp;lt;string&amp;gt; allNames = namesList.Aggregate(Enumerable.Empty&amp;lt;string&amp;gt;(), (current, next) =&amp;gt; next.Length &amp;gt; 3 ? current.Union(next) : current);foreach (string name in allNames){ Console.WriteLine(name);}/*This code produces the following output:Adams, TerryAndersen, Henriette ThaulowHedlund, MagnusIto, ShuSolanki, AjayHoeing, HelgePotra, CristinaIallo, Lucio*/ Range // Generate a sequence of integers from 1 to 10// and then select their squares.IEnumerable&amp;lt;int&amp;gt; squares = Enumerable.Range(1, 10).Select(x =&amp;gt; x * x);foreach (int num in squares){ Console.WriteLine(num);}/*This code produces the following output:149162536496481100*/ Repeat IEnumerable&amp;lt;string&amp;gt; strings = Enumerable.Repeat(&quot;I like programming.&quot;, 15);foreach (String str in strings){ Console.WriteLine(str);}/*This code produces the following output:I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.I like programming.*/ Equality Operations 해당 요소가 동일하고 같은 수의 요소를 포함 하는 두 시퀀스는 같은 것으로 간주.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 SequenceEqual 쌍 단위 방식으로 요소를 비교하여두 시퀀스가 서로 같은지 확인. 해당 사항 없음. Enumerable.SequenceEqualQueryable.SequenceEqual Element Operations 요소 작업은 시퀀스에서 특정 단일 요소를 반환합니다.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 ElementAt 컬렉션의 지정된 인덱스에 있는 요소를 반환. 해당 사항 없음. Enumerable.ElementAtQueryable.ElementAt ElementAtOrDefault 컬렉션의 지정된 인덱스에 있는 요소를 반환하거나인덱스가 범위를 벗어나면 기본값을 반환. 해당 사항 없음. Enumerable.ElementAtOrDefaultQueryable.ElementAtOrDefault First 컬렉션의 첫 번째 요소 또는특정 조건에 맞는 첫 번째 요소를 반환. 해당 사항 없음. Enumerable.FirstQueryable.First FirstOrDefault 컬렉션의 첫 번째 요소 또는 특정 조건에 맞는 첫 번째 요소를 반환.이러한 요소가 없으면 기본값을 반환. 해당 사항 없음. Enumerable.FirstOrDefaultQueryable.FirstOrDefaultQueryable.FirstOrDefault&amp;lt;TSource&amp;gt;(IQueryable&amp;lt;TSource&amp;gt;) Last 컬렉션의 마지막 요소 또는특정 조건에 맞는 마지막 요소를 반환. 해당 사항 없음. Enumerable.LastQueryable.Last LastOrDefault 컬렉션의 마지막 요소 또는특정 조건에 맞는 마지막 요소를 반환. 이러한 요소가 없으면 기본값을 반환. 해당 사항 없음. Enumerable.LastOrDefaultQueryable.LastOrDefault Single 컬렉션의 유일한 요소 또는 특정 조건에 맞는 유일한 요소를 반환.반환할 요소가 없거나 두 개 이상 있는 경우InvalidOperationException을 throw. 해당 사항 없음. Enumerable.SingleQueryable.Single SingleOrDefault 컬렉션의 유일한 요소 또는특정 조건에 맞는 유일한 요소를 반환. 반환할 요소가 없는 경우 기본값을 반환.반환할 요소가 두 개 이상 있는 경우 InvalidOperationException을 throw. 해당 사항 없음. Enumerable.SingleOrDefaultQueryable.SingleOrDefault ElementAt string[] names = { &quot;Hartono, Tommy&quot;, &quot;Adams, Terry&quot;, &quot;Andersen, Henriette Thaulow&quot;, &quot;Hedlund, Magnus&quot;, &quot;Ito, Shu&quot; };Random random = new Random(DateTime.Now.Millisecond);string name = names .ElementAt(random.Next(0, names.Length));string name = names .AsQueryable() .ElementAt(random.Next(0, names.Length));Console.WriteLine(&quot;The name chosen at random is &#39;{0}&#39;.&quot;, name);/* This code produces the following sample output. Yours may be different due to the use of Random. The name chosen at random is &#39;Ito, Shu&#39;.*/ ElementAtOrDefault string[] names = { &quot;Hartono, Tommy&quot;, &quot;Adams, Terry&quot;, &quot;Andersen, Henriette Thaulow&quot;, &quot;Hedlund, Magnus&quot;, &quot;Ito, Shu&quot; };int index = 20;string name = names .ElementAtOrDefault(index);string name = names .AsQueryable() .ElementAtOrDefault(index);Console.WriteLine( &quot;The name chosen at index {0} is &#39;{1}&#39;.&quot;, index, String.IsNullOrEmpty(name) ? &quot;[NONE AT THIS INDEX]&quot; : name);/* This code produces the following output: The name chosen at index 20 is &#39;[NONE AT THIS INDEX]&#39;.*/ First int[] numbers = { 9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19 };// Get the first number in the array that is greater than 80.int first = numbers .First(number =&amp;gt; number &amp;gt; 80);int first = numbers .AsQueryable() .First(number =&amp;gt; number &amp;gt; 80);Console.WriteLine(first);/* This code produces the following output: 92*/ FirstOrDefault string[] names = { &quot;Hartono, Tommy&quot;, &quot;Adams, Terry&quot;, &quot;Andersen, Henriette Thaulow&quot;, &quot;Hedlund, Magnus&quot;, &quot;Ito, Shu&quot; };// Get the first string in the array that is longer// than 20 characters, or the default value for type// string (null) if none exists.string firstLongName = names .FirstOrDefault(name =&amp;gt; name.Length &amp;gt; 20);string firstLongName = names .AsQueryable() .FirstOrDefault(name =&amp;gt; name.Length &amp;gt; 20);Console.WriteLine(&quot;The first long name is &#39;{0}&#39;.&quot;, firstLongName);// Get the first string in the array that is longer// than 30 characters, or the default value for type// string (null) if none exists.string firstVeryLongName = names .FirstOrDefault(name =&amp;gt; name.Length &amp;gt; 30);string firstVeryLongName = names .AsQueryable() .FirstOrDefault(name =&amp;gt; name.Length &amp;gt; 30);Console.WriteLine( &quot;There is {0} name that is longer than 30 characters.&quot;, string.IsNullOrEmpty(firstVeryLongName) ? &quot;NOT a&quot; : &quot;a&quot;);/* This code produces the following output: The first long name is &#39;Andersen, Henriette Thaulow&#39;. There is NOT a name that is longer than 30 characters.*/ Last int[] numbers = { 9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 67, 12, 19 };// Get the last number in the array that is greater than 80.int last = numbers .Last(num =&amp;gt; num &amp;gt; 80);int last = numbers .AsQueryable() .Last(num =&amp;gt; num &amp;gt; 80);Console.WriteLine(last);/* This code produces the following output: 87*/ LastOrDefault double[] numbers = { 49.6, 52.3, 51.0, 49.4, 50.2, 48.3 };// Get the last number in the array that rounds to 50.0,// or else the default value for type double (0.0).double last50 = numbers .LastOrDefault(n =&amp;gt; Math.Round(n) == 50.0);double last50 = numbers .AsQueryable() .LastOrDefault(n =&amp;gt; Math.Round(n) == 50.0);Console.WriteLine(&quot;The last number that rounds to 50 is {0}.&quot;, last50);// Get the last number in the array that rounds to 40.0,// or else the default value for type double (0.0).double last40 = numbers .LastOrDefault(n =&amp;gt; Math.Round(n) == 40.0);double last40 = numbers .AsQueryable() .LastOrDefault(n =&amp;gt; Math.Round(n) == 40.0);Console.WriteLine( &quot;The last number that rounds to 40 is {0}.&quot;, last40 == 0.0 ? &quot;[DOES NOT EXIST]&quot; : last40.ToString());/* This code produces the following output: The last number that rounds to 50 is 50.2. The last number that rounds to 40 is [DOES NOT EXIST].*/ Single string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };// Get the only string in the array whose length is greater than 10.string fruit1 = fruits .Single(fruit =&amp;gt; fruit.Length &amp;gt; 10);string fruit1 = fruits .AsQueryable() .Single(fruit =&amp;gt; fruit.Length &amp;gt; 10);Console.WriteLine(&quot;First Query: &quot; + fruit1);try{ // Try to get the only string in the array // whose length is greater than 15. string fruit2 = fruits .Single(fruit =&amp;gt; fruit.Length &amp;gt; 15); string fruit2 = fruits .AsQueryable() .Single(fruit =&amp;gt; fruit.Length &amp;gt; 15); Console.WriteLine(&quot;Second Query: &quot; + fruit2);}catch (System.InvalidOperationException){ Console.Write(&quot;Second Query: The collection does not contain &quot;); Console.WriteLine(&quot;exactly one element whose length is greater than 15.&quot;);}/* This code produces the following output: First Query: passionfruit Second Query: The collection does not contain exactly one element whose length is greater than 15.*/ SingleOrDefault string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };// Get the single string in the array whose length is greater// than 10, or else the default value for type string (null).string fruit1 = fruits .SingleOrDefault(fruit =&amp;gt; fruit.Length &amp;gt; 10);string fruit1 = fruits .AsQueryable() .SingleOrDefault(fruit =&amp;gt; fruit.Length &amp;gt; 10);Console.WriteLine(&quot;First Query: &quot; + fruit1);// Get the single string in the array whose length is greater// than 15, or else the default value for type string (null).string fruit2 = fruits .SingleOrDefault(fruit =&amp;gt; fruit.Length &amp;gt; 15);string fruit2 = fruits .AsQueryable() .SingleOrDefault(fruit =&amp;gt; fruit.Length &amp;gt; 15);Console.WriteLine(&quot;Second Query: &quot; + (String.IsNullOrEmpty(fruit2) ? &quot;No such string!&quot; : fruit2));/* This code produces the following output: First Query: passionfruit Second Query: No such string!*/ Converting Data Types 변환 메서드는 입력 개체의 형식을 변경. LINQ 쿼리의 변환 작업은 다양한 애플리케이션에서 유용. Enumerable.AsEnumerable 메서드는표준 쿼리 연산자의 형식 사용자 지정 구현을 숨기는 데 사용. Enumerable.OfType 메서드는LINQ 쿼리에 대해 매개 변수가 없는 컬렉션을 사용하도록 설정 Enumerable.ToArray, Enumerable.ToDictionary,Enumerable.ToList, Enumerable.ToLookup 메서드는쿼리가 열거될 때까지 연기하는 대신강제로 쿼리를 즉시 실행하는 데 사용. 메서드 이 표에서 이름이 “As”로 시작하는 변환 메서드는소스 컬렉션의 정적 형식을 변경하지만 열거하지는 않음.이름이 “To”로 시작하는 메서드는 소스 컬렉션을 열거하고항목을 해당하는 컬렉션 형식에 삽입. 이름 설명 C# 쿼리 식 구문 추가 정보 AsEnumerable IEnumerable&amp;lt;T&amp;gt;로 형식화된 입력을 반환. 해당 사항 없음. Enumerable.AsEnumerable AsQueryable (generic)IEnumerable을 (generic)IQueryable로 변환. 해당 사항 없음. Queryable.AsQueryable Cast 컬렉션의 요소를 지정된 형식으로 캐스트. 명시적 형식 범위 변수 사용.예를 들어:from string str in words Enumerable.CastQueryable.Cast OfType 지정된 형식으로 캐스트할 수 있는지 여부에 따라 값을 필터링. 해당 사항 없음. Enumerable.OfTypeQueryable.OfType ToArray 컬렉션을 배열로 변환합니다.이 메서드는 쿼리를 강제로 실행. 해당 사항 없음. Enumerable.ToArray ToDictionary 키 선택기 함수에 따라Dictionary&amp;lt;TKey,TValue&amp;gt;에 요소를 배치.이 메서드는 쿼리를 강제로 실행. 해당 사항 없음. Enumerable.ToDictionary ToList 컬렉션을 List&amp;lt;T&amp;gt;로 변환.이 메서드는 쿼리를 강제로 실행. 해당 사항 없음. Enumerable.ToList ToLookup 키 선택기 함수에 따라Lookup&amp;lt;TKey,TElement&amp;gt;(일 대 다 사전)에 요소를 배치.이 메서드는 쿼리를 강제로 실행. 해당 사항 없음. Enumerable.ToLookup AsEnumerable // Custom class.class Clump&amp;lt;T&amp;gt; : List&amp;lt;T&amp;gt;{ // Custom implementation of Where(). public IEnumerable&amp;lt;T&amp;gt; Where(Func&amp;lt;T, bool&amp;gt; predicate) { Console.WriteLine(&quot;In Clump&#39;s implementation of Where().&quot;); return Enumerable.Where(this, predicate); }}static void AsEnumerableEx1(){ // Create a new Clump&amp;lt;T&amp;gt; object. Clump&amp;lt;string&amp;gt; fruitClump = new Clump&amp;lt;string&amp;gt; { &quot;apple&quot;, &quot;passionfruit&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;blueberry&quot;, &quot;grape&quot;, &quot;strawberry&quot; }; // First call to Where(): // Call Clump&#39;s Where() method with a predicate. IEnumerable&amp;lt;string&amp;gt; query1 = fruitClump.Where(fruit =&amp;gt; fruit.Contains(&quot;o&quot;)); Console.WriteLine(&quot;query1 has been created.\\n&quot;); // Second call to Where(): // First call AsEnumerable() to hide Clump&#39;s Where() method and thereby // force System.Linq.Enumerable&#39;s Where() method to be called. IEnumerable&amp;lt;string&amp;gt; query2 = fruitClump.AsEnumerable().Where(fruit =&amp;gt; fruit.Contains(&quot;o&quot;)); // Display the output. Console.WriteLine(&quot;query2 has been created.&quot;);}// This code produces the following output://// In Clump&#39;s implementation of Where().// query1 has been created.//// query2 has been created. AsQueryable List&amp;lt;int&amp;gt; grades = new List&amp;lt;int&amp;gt; { 78, 92, 100, 37, 81 };// Convert the List to an IQueryable&amp;lt;int&amp;gt;.IQueryable&amp;lt;int&amp;gt; iqueryable = grades.AsQueryable();// Get the Expression property of the IQueryable object.System.Linq.Expressions.Expression expressionTree = iqueryable.Expression;Console.WriteLine(&quot;The NodeType of the expression tree is: &quot; + expressionTree.NodeType.ToString());Console.WriteLine(&quot;The Type of the expression tree is: &quot; + expressionTree.Type.Name);/* This code produces the following output: The NodeType of the expression tree is: Constant The Type of the expression tree is: EnumerableQuery`1*/ Cast // Create a list of objects.List&amp;lt;object&amp;gt; words = new List&amp;lt;object&amp;gt; { &quot;green&quot;, &quot;blue&quot;, &quot;violet&quot; };// Cast the objects in the list to type &#39;string&#39;// and project the first letter of each string.IEnumerable&amp;lt;string&amp;gt; query1 = words.AsQueryable() .Cast&amp;lt;string&amp;gt;() .Select(str =&amp;gt; str.Substring(0, 1));IEnumerable&amp;lt;string&amp;gt; query2 = words .Cast&amp;lt;string&amp;gt;() .Select(str =&amp;gt; str.Substring(0, 1));foreach (string s in query1) Console.WriteLine(s);foreach (string s in query2) Console.WriteLine(s);/* This code produces the following output: g b v*/ OfType System.Collections.ArrayList fruits = new System.Collections.ArrayList(4);fruits.Add(&quot;Mango&quot;);fruits.Add(&quot;Orange&quot;);fruits.Add(&quot;Apple&quot;);fruits.Add(3.0);fruits.Add(&quot;Banana&quot;);// Apply OfType() to the ArrayList.IEnumerable&amp;lt;string&amp;gt; query1 = fruits.OfType&amp;lt;string&amp;gt;();Console.WriteLine(&quot;Elements of type &#39;string&#39; are:&quot;);foreach (string fruit in query1){ Console.WriteLine(fruit);}// The following query shows that the standard query operators such as// Where() can be applied to the ArrayList type after calling OfType().IEnumerable&amp;lt;string&amp;gt; query2 = fruits .OfType&amp;lt;string&amp;gt;() .Where(fruit =&amp;gt; fruit.ToLower() .Contains(&quot;n&quot;));IEnumerable&amp;lt;string&amp;gt; query2 = fruits .OfType&amp;lt;string&amp;gt;() .AsQueryable() .Where(fruit =&amp;gt; fruit.ToLower().Contains(&quot;n&quot;));Console.WriteLine(&quot;\\nThe following strings contain &#39;n&#39;:&quot;);foreach (string fruit in query2){ Console.WriteLine(fruit);}// This code produces the following output://// Elements of type &#39;string&#39; are:// Mango// Orange// Apple// Banana//// The following strings contain &#39;n&#39;:// Mango// Orange// Banana ToArray class Package{ public string Company { get; set; } public double Weight { get; set; }}public static void ToArrayEx1(){ List&amp;lt;Package&amp;gt; packages = new List&amp;lt;Package&amp;gt; { new Package { Company = &quot;Coho Vineyard&quot;, Weight = 25.2 }, new Package { Company = &quot;Lucerne Publishing&quot;, Weight = 18.7 }, new Package { Company = &quot;Wingtip Toys&quot;, Weight = 6.0 }, new Package { Company = &quot;Adventure Works&quot;, Weight = 33.8 } }; string[] companies = packages.Select(pkg =&amp;gt; pkg.Company).ToArray(); foreach (string company in companies) { Console.WriteLine(company); }}/*This code produces the following output:Coho VineyardLucerne PublishingWingtip ToysAdventure Works*/ ToDictionary class Package{ public string Company { get; set; } public double Weight { get; set; } public long TrackingNumber { get; set; }}public static void ToDictionaryEx1(){ List&amp;lt;Package&amp;gt; packages = new List&amp;lt;Package&amp;gt; { new Package { Company = &quot;Coho Vineyard&quot;, Weight = 25.2, TrackingNumber = 89453312L }, new Package { Company = &quot;Lucerne Publishing&quot;, Weight = 18.7, TrackingNumber = 89112755L }, new Package { Company = &quot;Wingtip Toys&quot;, Weight = 6.0, TrackingNumber = 299456122L }, new Package { Company = &quot;Adventure Works&quot;, Weight = 33.8, TrackingNumber = 4665518773L } }; // Create a Dictionary of Package objects, // using TrackingNumber as the key. Dictionary&amp;lt;long, Package&amp;gt; dictionary = packages.ToDictionary(p =&amp;gt; p.TrackingNumber); foreach (KeyValuePair&amp;lt;long, Package&amp;gt; kvp in dictionary) { Console.WriteLine( &quot;Key {0}: {1}, {2} pounds&quot;, kvp.Key, kvp.Value.Company, kvp.Value.Weight); }}/*This code produces the following output:Key 89453312: Coho Vineyard, 25.2 poundsKey 89112755: Lucerne Publishing, 18.7 poundsKey 299456122: Wingtip Toys, 6 poundsKey 4665518773: Adventure Works, 33.8 pounds*/ ToList string[] fruits = { &quot;apple&quot;, &quot;passionfruit&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;blueberry&quot;, &quot;grape&quot;, &quot;strawberry&quot; };List&amp;lt;int&amp;gt; lengths = fruits.Select(fruit =&amp;gt; fruit.Length).ToList();foreach (int length in lengths){ Console.WriteLine(length);}/*This code produces the following output:5126569510*/ ToLookup class Package{ public string Company { get; set; } public double Weight { get; set; } public long TrackingNumber { get; set; }}public static void ToLookupEx1(){ // Create a list of Packages. List&amp;lt;Package&amp;gt; packages = new List&amp;lt;Package&amp;gt; { new Package { Company = &quot;Coho Vineyard&quot;, Weight = 25.2, TrackingNumber = 89453312L }, new Package { Company = &quot;Lucerne Publishing&quot;, Weight = 18.7, TrackingNumber = 89112755L }, new Package { Company = &quot;Wingtip Toys&quot;, Weight = 6.0, TrackingNumber = 299456122L }, new Package { Company = &quot;Contoso Pharmaceuticals&quot;, Weight = 9.3, TrackingNumber = 670053128L }, new Package { Company = &quot;Wide World Importers&quot;, Weight = 33.8, TrackingNumber = 4665518773L } }; // Create a Lookup to organize the packages. // Use the first character of Company as the key value. // Select Company appended to TrackingNumber // as the element values of the Lookup. ILookup&amp;lt;char, string&amp;gt; lookup = packages .ToLookup(p =&amp;gt; Convert.ToChar(p.Company.Substring(0, 1)), p =&amp;gt; p.Company + &quot; &quot; + p.TrackingNumber); // Iterate through each IGrouping in the Lookup. foreach (IGrouping&amp;lt;char, string&amp;gt; packageGroup in lookup) { // Print the key value of the IGrouping. Console.WriteLine(packageGroup.Key); // Iterate through each value in the // IGrouping and print its value. foreach (string str in packageGroup) Console.WriteLine(&quot; {0}&quot;, str); }}/*This code produces the following output:C Coho Vineyard 89453312 Contoso Pharmaceuticals 670053128L Lucerne Publishing 89112755W Wingtip Toys 299456122 Wide World Importers 4665518773*/ Concatenation Operations 연결은 한 시퀀스를 다른 시퀀스에 추가하는 작업.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Concat 두 시퀀스를 연결헤 하나의 시퀀스를 구성. 해당 사항 없음. Enumerable.ConcatQueryable.Concat Concat class Pet{ public string Name { get; set; } public int Age { get; set; }}// This method creates and returns an array of Pet objects.static Pet[] GetCats(){ Pet[] cats = { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; return cats;}// This method creates and returns an array of Pet objects.static Pet[] GetDogs(){ Pet[] dogs = { new Pet { Name=&quot;Bounder&quot;, Age=3 }, new Pet { Name=&quot;Snoopy&quot;, Age=14 }, new Pet { Name=&quot;Fido&quot;, Age=9 } }; return dogs;}public static void ConcatEx1(){ Pet[] cats = GetCats(); Pet[] dogs = GetDogs(); // Concatenate a collection of cat names to a // collection of dog names by using Concat(). IEnumerable&amp;lt;string&amp;gt; query = cats .Select(cat =&amp;gt; cat.Name) .Concat(dogs.Select(dog =&amp;gt; dog.Name)); IEnumerable&amp;lt;string&amp;gt; query = cats .AsQueryable() .Select(cat =&amp;gt; cat.Name) .Concat(dogs.Select(dog =&amp;gt; dog.Name)); foreach (string name in query) Console.WriteLine(name);}// This code produces the following output://// Barley// Boots// Whiskers// Bounder// Snoopy// Fido///////////////////////////////////////////////////////////// vs selectmanyPet[] cats = GetCats();Pet[] dogs = GetDogs();IEnumerable&amp;lt;string&amp;gt; query = new[] { cats.Select(cat =&amp;gt; cat.Name), dogs.Select(dog =&amp;gt; dog.Name) } .SelectMany(name =&amp;gt; name);foreach (string name in query){ Console.WriteLine(name);}// This code produces the following output://// Barley// Boots// Whiskers// Bounder// Snoopy// Fido Aggregation Operations 값의 컬렉션에서 하나의 값을 계산. 예를 들어 1달 동안의 일일 온도 값에서 평균 일일 온도를 계산.메서드 이름 설명 C# 쿼리 식 구문 추가 정보 Aggregate 컬렉션 값에 대해 사용자 지정 집계 작업을 수행. 해당 사항 없음. Enumerable.AggregateQueryable.Aggregate Average 값 컬렉션의 평균 값을 계산. 해당 사항 없음. Enumerable.AverageQueryable.Average Count 컬렉션에서 조건자 함수를 충족하는 개수를 계산. 해당 사항 없음. Enumerable.CountQueryable.Count LongCount 큰 컬렉션에서 조건자 함수를 충족하는 개수를 계산. 해당 사항 없음. Enumerable.LongCountQueryable.LongCount Max 컬렉션의 최대값. 해당 사항 없음. Enumerable.MaxQueryable.Max Min 컬렉션의 최소값. 해당 사항 없음. Enumerable.MinQueryable.Min Sum 컬렉션에 있는 값의 합계. 해당 사항 없음. Enumerable.SumQueryable.Sum Aggregate string[] fruits = { &quot;apple&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };// Determine whether any string in the array is longer than &quot;banana&quot;.// Return the final result as an upper case string.string longestName = fruits .Aggregate(&quot;banana&quot;, (longest, next) =&amp;gt; next.Length &amp;gt; longest.Length ? next : longest, fruit =&amp;gt; fruit.ToUpper());string longestName = fruits .AsQueryable() .Aggregate(&quot;banana&quot;, (longest, next) =&amp;gt; next.Length &amp;gt; longest.Length ? next : longest,fruit =&amp;gt; fruit.ToUpper());Console.WriteLine( &quot;The fruit with the longest name is {0}.&quot;, longestName);// This code produces the following output://// The fruit with the longest name is PASSIONFRUIT. Average string[] fruits = { &quot;apple&quot;, &quot;banana&quot;, &quot;mango&quot;, &quot;orange&quot;, &quot;passionfruit&quot;, &quot;grape&quot; };// Determine the average string length in the array.double average = fruits .Average(s =&amp;gt; s.Length);double average = fruits .AsQueryable() .Average(s =&amp;gt; s.Length);Console.WriteLine(&quot;The average string length is {0}.&quot;, average);// This code produces the following output://// The average string length is 6.5. Count class Pet{ public string Name { get; set; } public bool Vaccinated { get; set; }}public static void CountEx2(){ // Create an array of Pet objects. Pet[] pets = { new Pet { Name=&quot;Barley&quot;, Vaccinated=true }, new Pet { Name=&quot;Boots&quot;, Vaccinated=false }, new Pet { Name=&quot;Whiskers&quot;, Vaccinated=false } }; // Count the number of unvaccinated pets in the array. int numberUnvaccinated = pets .Count(p =&amp;gt; p.Vaccinated == false); int numberUnvaccinated = pets .AsQueryable() .Count(p =&amp;gt; p.Vaccinated == false); Console.WriteLine( &quot;There are {0} unvaccinated animals.&quot;, numberUnvaccinated);}// This code produces the following output://// There are 2 unvaccinated animals. LongCount class Pet{ public string Name { get; set; } public int Age { get; set; }}public static void LongCountEx2(){ Pet[] pets = { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; const int Age = 3; // Count the number of Pet objects where Pet.Age is greater than 3. long count = pets .LongCount(pet =&amp;gt; pet.Age &amp;gt; Age); long count = pets .AsQueryable() .LongCount(pet =&amp;gt; pet.Age &amp;gt; Age); Console.WriteLine(&quot;There are {0} animals over age {1}.&quot;, count, Age);}/* This code produces the following output: There are 2 animals over age 3.*/ Max class Pet{ public string Name { get; set; } public int Age { get; set; }}public static void MaxEx2(){ Pet[] pets = { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; // Add Pet.Age to the length of Pet.Name // to determine the &quot;maximum&quot; Pet object in the array. int max = pets .Max(pet =&amp;gt; pet.Age + pet.Name.Length); int max = pets .AsQueryable() .Max(pet =&amp;gt; pet.Age + pet.Name.Length); Console.WriteLine( &quot;The maximum pet age plus name length is {0}.&quot;, max);}/* This code produces the following output: The maximum pet age plus name length is 14.*/ Min class Pet{ public string Name { get; set; } public int Age { get; set; }}public static void MinEx2(){ Pet[] pets = { new Pet { Name=&quot;Barley&quot;, Age=8 }, new Pet { Name=&quot;Boots&quot;, Age=4 }, new Pet { Name=&quot;Whiskers&quot;, Age=1 } }; // Get the Pet object that has the smallest Age value. int min = pets .Min(pet =&amp;gt; pet.Age); int min = pets .AsQueryable() .Min(pet =&amp;gt; pet.Age); Console.WriteLine(&quot;The youngest animal is age {0}.&quot;, min);}/* This code produces the following output: The youngest animal is age 1.*/ Sum class Package{ public string Company { get; set; } public double Weight { get; set; }}public static void SumEx3(){ List&amp;lt;Package&amp;gt; packages = new List&amp;lt;Package&amp;gt; { new Package { Company = &quot;Coho Vineyard&quot;, Weight = 25.2 }, new Package { Company = &quot;Lucerne Publishing&quot;, Weight = 18.7 }, new Package { Company = &quot;Wingtip Toys&quot;, Weight = 6.0 }, new Package { Company = &quot;Adventure Works&quot;, Weight = 33.8 } }; // Calculate the sum of all package weights. double totalWeight = packages .Sum(pkg =&amp;gt; pkg.Weight); double totalWeight = packages .AsQueryable() .Sum(pkg =&amp;gt; pkg.Weight); Console.WriteLine(&quot;The total weight of the packages is: {0}&quot;, totalWeight);}/* This code produces the following output: The total weight of the packages is: 83.7*/ 참고 표준 쿼리 연산자 개요(C#) 쿼리 키워드(C# 참조) 표준 쿼리 연산자의 쿼리 식 구문(C#)" }, { "title": "13. LINQ 1", "url": "/posts/CS_13_Linq_1/", "categories": "Grind, C#", "tags": "c#, linq", "date": "2021-04-06 12:00:00 +0900", "snippet": "LINQ(Language-Integrated Query)개요 LINQ는 데이터 소스에서 데이터를 쿼리하고 변환하는 데 사용. ex) 단일 쿼리로 SQL 데이터베이스에서 검색하고 XML 출력. 데이터 모델 단순화 관계형 데이터베이스에는다양한 형식의 데이터 소스에 서로 다른 언어 필요 LINQ는 다양한 데이터 소스 및 형식에일관된 모델을 제공함으로써이러한 상황을 단순화 했다. 쿼리 식은 쉽다. 대부분의 경우 컴파일러가 형식을 유추하기 때문에명시적 형식을 제공할 필요는 없지만쿼리 식의 변수는 모두 강력한 형식을 갖는다.(LINQ 쿼리 작업의 형식 관계.) 보통 결과를 var로 처리하는 이유인듯 쿼리는 쿼리 변수를 반복할 때까지(예: foreach 문) 실행되지 않는다. 지연된 실행에 관한건 아래. 컴파일 타임에 쿼리 식은 C#에 명시된 규칙에 따라표준 쿼리 연산자 메서드 호출으로 변환된다. 쿼리 구문을 사용하여 표현할 수 있는 모든 쿼리는메서드 구문으로도 표현할 수 있다. 원래 쓰던 query처럼 쓰는방법, method처럼 쓰는방법에 대한 설명. 1,2로 나눠 쓸 예정 LINQ 쿼리를 작성하는 경우 가능하면 쿼리 구문을 사용하고필요한 경우 메서드 구문을 사용하는 것이 좋다.두 개의 다른 폼 간에 의미 체계 또는 성능상의 차이는 없다. 쿼리 식이 메서드 구문으로 작성된 동급의 식보다 읽기 쉬운 경우가 많다. C# 언어 사양 / 표준 쿼리 연산자 개요 참고 expression with method 일부 linq method는 expression으로 표현할 수 없음 Count 또는 Max등등.뒤에 보면 더 많음 해당하는 쿼리 식 절이 없으므로 메서드 호출로 표현해야 한다.단, expression 으로 구현을 못하는게 아니라직접 같은 결과를 도출하려면 번거로움 메서드 구문을 다양한 방법으로 쿼리 구문에 조합할 수 있다.따라서 expression은 일반적으로 가독성이 좋고method에는 좀더 편리하게 만들어진것들이 더 있음잘 조합하는게 좋음. 쿼리 식은 쿼리가 적용되는 형식에 따라식 트리 또는 대리자로 컴파일될 수 있다. IEnumerable&amp;lt;T&amp;gt; 쿼리는 대리자로 컴파일. IQueryable 및 IQueryable&amp;lt;T&amp;gt; 쿼리는 식 트리로 컴파일. 자세한 내용은 식 트리를 참조. Data Source LINQ 쿼리는 .NET Framework 2.0에서 도입된 제네릭 형식을 기반으로 힌다. List&amp;lt;T&amp;gt; 같은 제네릭 컬렉션 클래스의 인스턴스를 만들 때“T”를 목록에 포함할 개체 형식으로 대체. 예를 들어 문자열 목록은 List&amp;lt;string&amp;gt;으로, Customer 개체 목록은 List&amp;lt;Customer&amp;gt;로 표현함. 따라서 형식 캐스팅을 수행할 필요가 없어짐. 제네릭 IEnumerable&amp;lt;T&amp;gt; 인터페이스를 암시적으로 지원하면 LINQ로 쿼리할 수 있다. 쿼리가 foreach 문에서 실행되고,foreach는 IEnumerable 또는 IEnumerable&amp;lt;T&amp;gt;이 필요. IEnumerable&amp;lt;T&amp;gt; 또는 제네릭 IQueryable&amp;lt;T&amp;gt; 같은파생된 인터페이스를 지원하는 형식을 쿼리 가능 형식이라고 함. 이해하는 바가 맞다면 query는 foreach를 이용해 실행함. foreach는 IEnumerable&amp;lt;T&amp;gt;을 이용함. foreach를 사용할 수 있는 모든 데이터 형식은 linq를 사용가능해짐. Query Execution Deferred Execution 특이한점은 쿼리 변수 자체는 쿼리 명령을 저장하는 기능만 함.실제 쿼리 실행은 foreach 문에서 쿼리 변수가 반복될 때까지 지연된다. void mtd(){ int[] data = { 3, 5, 4, 2, 1 }; var q = from d in data orderby d select d; foreach (var item in q) { Console.WriteLine(&quot;{0}&quot;,item ); } data[0] = 1000; //3 에서 10으로 foreach(var item in q) { Console.WriteLine(&quot;{0}&quot;,item); }}/// 1 2 3 4 5/// 1 2 3 4 10 쿼리식은 명령만 저장하고 있음 원본 데이터의 변경과 쿼리식은 서로 상관 없음 쿼리식을 직접 검색할 때 그 시점의 데이터를 볼 수 있음 foreach 문은 쿼리 결과가 검색되는 위치이기도 하다. 예를 들어 이전 쿼리에서 반복 변수 item은반환된 시퀀스에서 각 값을 한 번에 하나씩 저장한다. 쿼리 변수 자체는 쿼리 결과를 저장하지 않으므로원하는 만큼 자주 실행할 수 있다. 예를 들어 지속적으로 업데이트되는 데이터베이스가 있을 때애플리케이션에서 최근 데이터를 검색하는 쿼리를 작성하고이를 일정 간격을 두고 반복적으로 실행하여매번 다른 결과를 검색할 수 있다. Forcing Immediate Execution 소스 요소 범위에 대해 집계 함수를 수행하는 쿼리는먼저 해당 요소를 반복해야 한다. ex) Count, Max, Average, First 등 이러한 쿼리는 쿼리 자체에서 결과를 반환하려면foreach를 사용해야 하기 때문에 명시적 foreach 문 없이 실행된다. 이러한 유형의 쿼리는 IEnumerable 컬렉션이 아니라 단일 값을 반환한다. 배열에서 짝수의 개수를 반환하는 예. var evenNumQuery = from num in numbers where (num % 2) == 0 select num;int evenNumCount = evenNumQuery.Count();List&amp;lt;int&amp;gt; numQuery2 = (from num in numbers where (num % 2) == 0 select num).ToList();// or like this:// numQuery3 is still an int[]var numQuery3 = (from num in numbers where (num % 2) == 0 select num).ToArray(); 모든 쿼리를 즉시 실행하고 그 결과를 캐시하기 위해ToList 또는 ToArray 메서드를 호출할 수 있다. foreach 루프를 쿼리 식 바로 다음에 배치하여 강제로 실행할 수 있고,ToList 또는 ToArray를 호출하여단일 컬렉션 개체에서 모든 데이터를 캐시할 수도 있다. Query C# 식이 유효한 모든 컨텍스트에서 사용할 수 있다. 쿼리 식은 SQL 또는 XQuery와 유사한 선언적 구문으로 작성된 절 집합. 다만, 서순이 좀 다름. 각 절에는 하나 이상의 C# 식이 포함되며, 이러한 식은자체가 쿼리 식이거나 쿼리 식을 포함할 수 있다. 쿼리 식은 from 절로 시작하고 select 또는 group 절로 끝나야 한다. 첫 번째 from 절과 마지막 select 또는 group 절 사이에선택적으로 where, orderby, join, let 절과추가 from 절 중에서 하나 이상을 포함할 수 있다. 또한 into 키워드를 사용하여, join 또는 group 절의 결과를동일한 쿼리 식의 추가 쿼리 절에 대한 소스로 사용할 수 있다. 흔히 보던 query랑 다를게 없어 보이는 설명인데차이점이 있다면 query쓰는 순서, join 정도? 일반적인 db qry는결과(select) - data(from) - 조건(where…) 이라면 LINQ는data(from) - 조건(where…) - 결과(select) 순서. var result = from num in nums where num &amp;lt; 10 select num from 쿼리 시작점. from이 나타내는 내용은 쿼리 또는 하위쿼리가 실행된 데이터소스 소스 시퀀스의 각 요소를 나타내는 지역 범위 변수 컴파일러는 데이터 소스가 IEnumerable&amp;lt;T&amp;gt;을 구현할 경우범위 변수의 형식을 유추한다. 아래의 경우 numbers는 데이터 소스이고 num은 범위 변수. var 키워드가 사용되어도 두 변수는 모두 강력한 형식. 아래의 예제에서 num은 int 형식으로 유추된다. 범위 변수가 강력한 형식이므로 범위 변수에서 메서드를 호출하거나다른 작업에서 범위 변수를 사용 가능. 예를 들어 select num을 작성하는 대신에select num.ToString() 사용 가능. 또는 select num + 10을 작성하여식에서 14, 11, 13, 12, 10 시퀀스를 반환 가능 소스가 ArrayList와 같이 제네릭이 아닌 IEnumerable 형식인 경우에만형식을 명시적으로 지정하면 됨. (해당내용은 ArrayList를 쿼리하는 방법 참조.) class LowNums { static void Main() { // A simple data source. int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; // Create the query. // lowNums is an IEnumerable&amp;lt;int&amp;gt; var lowNums = from num in numbers where num &amp;lt; 5 select num; // Execute the query. foreach (int i in lowNums) { Console.Write(i + &quot; &quot;); } } } // Output: 4 1 3 2 0 하위에 다른 from 가능 경우에 따라 소스 시퀀스의 각 요소 자체가 시퀀스이거나 시퀀스를 포함할 수 있다. 예를 들어, 시퀀스의 각 학생 개체에 테스트 점수 목록이 포함된IEnumerable&amp;lt;Student&amp;gt;가 데이터 소스일 수 있음. 각 Student 요소 내의 내부 목록에 액세스하려면 복합 from 절을 사용. 이 기술은 중첩된 foreach 문을 사용하는 것과 같다. where 또는 orderby 절을 둘 중 하나의 from 절에 추가하여 필터링. class CompoundFrom{ // The element type of the data source. public class Student { public string LastName { get; set; } public List&amp;lt;int&amp;gt; Scores { get; set; } } static void Main() { // Use a collection initializer to create the data source. Note that // each element in the list contains an inner sequence of scores. List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt; { new Student {LastName=&quot;Omelchenko&quot;, Scores= new List&amp;lt;int&amp;gt; {97, 72, 81, 60}}, new Student {LastName=&quot;O&#39;Donnell&quot;, Scores= new List&amp;lt;int&amp;gt; {75, 84, 91, 39}}, new Student {LastName=&quot;Mortensen&quot;, Scores= new List&amp;lt;int&amp;gt; {88, 94, 65, 85}}, new Student {LastName=&quot;Garcia&quot;, Scores= new List&amp;lt;int&amp;gt; {97, 89, 85, 82}}, new Student {LastName=&quot;Beebe&quot;, Scores= new List&amp;lt;int&amp;gt; {35, 72, 91, 70}} }; // Use a compound from to access the inner sequence within each element. // Note the similarity to a nested foreach statement. var scoreQuery = from student in students from score in student.Scores where score &amp;gt; 90 select new { Last = student.LastName, score }; // Execute the queries. Console.WriteLine(&quot;scoreQuery:&quot;); // Rest the mouse pointer on scoreQuery in the following line to // see its type. The type is IEnumerable&amp;lt;&#39;a&amp;gt;, where &#39;a is an // anonymous type defined as new {string Last, int score}. That is, // each instance of this anonymous type has two members, a string // (Last) and an int (score). foreach (var student in scoreQuery) { Console.WriteLine(&quot;{0} Score: {1}&quot;, student.Last, student.score); } // Keep the console window open in debug mode. Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/*scoreQuery:Omelchenko Score: 97O&#39;Donnell Score: 91Mortensen Score: 94Garcia Score: 97Beebe Score: 91*/ where 데이터 소스의 어떤 요소가 쿼리 식에서 반환될지를 지정 : 필터링. 각 소스 요소(범위 변수로 참조됨)에부울 조건(predicate)을 적용하고 참인 요소를 반환. 단일 쿼리 식에는 여러 where 절을 포함할 수 있으며단일 절에는 여러 조건부 하위 식을 포함 가능. 첫 번째 또는 마지막 절이 될 수 없다는 점을 제외하고,쿼리 식의 거의 모든 곳에 배치할 수 있다. 소스 요소를 그룹화 전에 필터링할지,그룹화 후에 필터링할지에 따라where 절은 group 절 앞 또는 뒤에 나타날 수 있다. 지정된 조건자가 데이터 소스의 요소에 대해유효하지 않은 경우 컴파일 오류 발생. 이는 LINQ에서 제공하는 강력한 형식 검사의 이점.컴파일 시간에 where 키워드는Where 표준 쿼리 연산자 메서드에 대한 호출로 변환된다. class LINQ_where { public Action&amp;lt;string&amp;gt; action; public void test() { // Data source. int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 }; // Create the query with two where clause. var queryLowNums3 = from num in numbers where num &amp;gt; 0 &amp;amp;&amp;amp; num &amp;lt; 10 where IsEven(num) select num; // Execute the query foreach (var s in queryLowNums3) { action(s.ToString()); } } bool IsEven(int i) { return i % 2 == 0; } } // Output: // 4 8 6 2 where num &amp;gt; 0 &amp;amp;&amp;amp; num &amp;lt; 10는 where num &amp;gt; 0 where num &amp;lt; 10 로 변환 가능. 결국, bool로 판단할 수 있는 식또는 method가 들어가는건 모두 가능하며 적당히 &amp;amp;&amp;amp; || 등으로 묶어서 표현 가능.select 쿼리 식의 끝 1. 쿼리를 실행할 때 생성되는 값의 형식을 지정.또는 쿼리 결과에서 실제 뽑아올 데이터를 지정. 결과는 모든 이전 절의 평가와select 절 자체의 모든 계산을 기반으로 한다. class LINQ_select { public Action&amp;lt;string&amp;gt; action; // Define some classes public class Student { public string First { get; set; } public string Last { get; set; } public int ID { get; set; } public List&amp;lt;int&amp;gt; Scores; public ContactInfo GetContactInfo(LINQ_select app, int id) { ContactInfo cInfo = (from ci in app.contactList where ci.ID == id select ci) .FirstOrDefault(); return cInfo; } public override string ToString() { return First + &quot; &quot; + Last + &quot;:&quot; + ID; } } public class ContactInfo { public int ID { get; set; } public string Email { get; set; } public string Phone { get; set; } public override string ToString() { return Email + &quot;,&quot; + Phone; } } public class ScoreInfo { public double Average { get; set; } public int ID { get; set; } } // The primary data source List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt;() { new Student { First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores= new List&amp;lt;int&amp;gt;() {97, 92, 81, 60} }, new Student { First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112, Scores= new List&amp;lt;int&amp;gt;() {75, 84, 91, 39} }, new Student { First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores= new List&amp;lt;int&amp;gt;() {88, 94, 65, 91} }, new Student { First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114, Scores= new List&amp;lt;int&amp;gt;() {97, 89, 85, 82} }, }; // Separate data source for contact info. List&amp;lt;ContactInfo&amp;gt; contactList = new List&amp;lt;ContactInfo&amp;gt;() { new ContactInfo {ID=111, Email=&quot;SvetlanO@Contoso.com&quot;, Phone=&quot;206-555-0108&quot;}, new ContactInfo {ID=112, Email=&quot;ClaireO@Contoso.com&quot;, Phone=&quot;206-555-0298&quot;}, new ContactInfo {ID=113, Email=&quot;SvenMort@Contoso.com&quot;, Phone=&quot;206-555-1130&quot;}, new ContactInfo {ID=114, Email=&quot;CesarGar@Contoso.com&quot;, Phone=&quot;206-555-0521&quot;} }; public void test() { LINQ_select app = new LINQ_select(); // Produce a filtered sequence of unmodified Students. var studentQuery1 = from student in app.students where student.ID &amp;gt; 111 select student; action(&quot;Query1: select range_variable&quot;); foreach (var s in studentQuery1) { action(s.ToString()); } // Produce a filtered sequence of elements that contain // only one property of each Student. IEnumerable&amp;lt;String&amp;gt; studentQuery2 = from student in app.students where student.ID &amp;gt; 111 select student.Last; action(&quot;\\r\\n studentQuery2: select range_variable.Property&quot;); foreach (string s in studentQuery2) { action(s); } // Produce a filtered sequence of objects created by // a method call on each Student. IEnumerable&amp;lt;ContactInfo&amp;gt; studentQuery3 = from student in app.students where student.ID &amp;gt; 111 select student.GetContactInfo(app, student.ID); action(&quot;\\r\\n studentQuery3: select range_variable.Method&quot;); foreach (ContactInfo ci in studentQuery3) { action(ci.ToString()); } // Produce a filtered sequence of ints from // the internal array inside each Student. IEnumerable&amp;lt;int&amp;gt; studentQuery4 = from student in app.students where student.ID &amp;gt; 111 select student.Scores[0]; action(&quot;\\r\\n studentQuery4: select range_variable[index]&quot;); foreach (int i in studentQuery4) { action(string.Format(&quot;First score = {0}&quot;, i)); } // Produce a filtered sequence of doubles // that are the result of an expression. IEnumerable&amp;lt;double&amp;gt; studentQuery5 = from student in app.students where student.ID &amp;gt; 111 select student.Scores[0] * 1.1; action(&quot;\\r\\n studentQuery5: select expression&quot;); foreach (double d in studentQuery5) { action(string.Format(&quot;Adjusted first score = {0}&quot;, d)); } // Produce a filtered sequence of doubles that are // the result of a method call. IEnumerable&amp;lt;double&amp;gt; studentQuery6 = from student in app.students where student.ID &amp;gt; 111 select student.Scores.Average(); action(&quot;\\r\\n studentQuery6: select expression2&quot;); foreach (double d in studentQuery6) { action(string.Format(&quot;Average = {0}&quot;, d)); } // Produce a filtered sequence of anonymous types // that contain only two properties from each Student. var studentQuery7 = from student in app.students where student.ID &amp;gt; 111 select new { student.First, student.Last }; action(&quot;\\r\\n studentQuery7: select new anonymous type&quot;); foreach (var item in studentQuery7) { action(string.Format(&quot;{0}, {1}&quot;, item.Last, item.First)); } // Produce a filtered sequence of named objects that contain // a method return value and a property from each Student. // Use named types if you need to pass the query variable // across a method boundary. IEnumerable&amp;lt;ScoreInfo&amp;gt; studentQuery8 = from student in app.students where student.ID &amp;gt; 111 select new ScoreInfo { Average = student.Scores.Average(), ID = student.ID }; action(&quot;\\r\\n studentQuery8: select new named type&quot;); foreach (ScoreInfo si in studentQuery8) { action(string.Format(&quot;ID = {0}, Average = {1}&quot;, si.ID, si.Average)); } // Produce a filtered sequence of students who appear on a contact list // and whose average is greater than 85. IEnumerable&amp;lt;ContactInfo&amp;gt; studentQuery9 = from student in app.students where student.Scores.Average() &amp;gt; 85 join ci in app.contactList on student.ID equals ci.ID select ci; action(&quot;\\r\\n studentQuery9: select result of join clause&quot;); foreach (ContactInfo ci in studentQuery9) { action(string.Format(&quot;ID = {0}, Email = {1}&quot;, ci.ID, ci.Email)); } // Keep the console window open in debug mode action(&quot;Press any key to exit.&quot;); } } 위는 select로 할 수 있는 모든 짓거리들. select 절에서 생성된 시퀀스의 형식에 따라쿼리 변수의 형식이 결정. 위의 경우 studentQuery1 이며이전 설명에도 나와있듯이 var이지만 강력한 형식. 가장 단순한 경우에서는 select 절이 범위 변수를 지정합니다. 이것도 studentQuery1의 경우. 이렇게 하면 반환된 시퀀스에데이터 소스와 동일한 형식의 요소가 포함된다. 관련 내용은 LINQ 쿼리 작업의 형식 관계 참조. select 절은 소스 데이터를새 형식으로 변환(또는 프로젝션)하기 위한 메커니즘도 제공. studentQuery7에서와 같이 이 전과 다른 새로운 형식으로 생성 가능. studentQuery8에 표시된 대로 반환된 시퀀스의 요소에소스 요소의 속성 하위 집합만 포함하려는 경우도 가능. 반환된 시퀀스를 최대한 작게 유지하면메모리 요구 사항을 줄이고 쿼리 실행 속도를 높일 수 있다. select 절에서 무명 형식을 만들고개체 이니셜라이저를 사용하여소스 요소의 적절한 속성으로 초기화하면 된다. 관련 내용은 LINQ를 통한 데이터 변환(C#),개체 및 컬렉션 이니셜라이저를 참조. group 쿼리 식의 끝 2 group 절은 그룹의 키 값과 일치하는0개 이상의 항목이 포함된IGrouping&amp;lt;TKey,TElement&amp;gt; 개체 시퀀스를 반환. 예를 들어 각 문자열의 첫 번째 문자에 따라문자열 시퀀스를 그룹화할 수 있다. 이 경우 첫 번째 문자는 키로, char 형식이며각 IGrouping&amp;lt;TKey,TElement&amp;gt; 개체의 Key 속성에 저장. 컴파일러는 키의 형식을 유추한다. 그룹 키는 문자열, 기본 제공 숫자 형식,사용자 정의 명명된 형식, 무명 형식 등 모든 형식가능. 위 경우 IGrouping&amp;lt;char,string&amp;gt; 인듯. by를 사용해 반환된 항목의 그룹화 방법을 지정. 다음은 group의 대략적인 예시 // Group students by the first letter of their last name// Query variable is an IEnumerable&amp;lt;IGrouping&amp;lt;char, Student&amp;gt;&amp;gt;var studentQuery2 = from student in students group student by student.Last[0] into g orderby g.Key select g; // Iterate group items with a nested foreach. This IGrouping encapsulates// a sequence of Student objects, and a Key of type char.// For convenience, var can also be used in the foreach statement.foreach (IGrouping&amp;lt;char, Student&amp;gt; studentGroup in studentQuery2){ Console.WriteLine(studentGroup.Key); // Explicit type for student could also be used here. foreach (var student in studentGroup) { Console.WriteLine(&quot; {0}, {1}&quot;, student.Last, student.First); }} group 쿼리에 의해 생성된 IGrouping&amp;lt;TKey,TElement&amp;gt; 개체는기본적으로 목록의 목록이기 때문에중첩된 foreach로 액세스해야 한다. 외부 루프는 그룹 키를 반복하고,내부 루프는 그룹 자체에 있는 각 항목을 반복. 그룹에 키가 있지만 요소는 없을 수도 있다. 각 그룹에서 추가 쿼리 작업을 수행하려는 경우into 상황별 키워드를 사용하여 임시 식별자를 지정. into를 사용하는 경우 쿼리를 계속 진행하되궁극적으로 select 문이나 다른 group 절로 끝내야 한다. 그룹화 string group key로 위에서는 char를 사용했지만문자열 키를 student.Last등으로 지정할 수 있다. bool class GroupSample1{ // The element type of the data source. public class Student { public string First { get; set; } public string Last { get; set; } public int ID { get; set; } public List&amp;lt;int&amp;gt; Scores; } public static List&amp;lt;Student&amp;gt; GetStudents() { // Use a collection initializer to create the data source. Note that each element // in the list contains an inner sequence of scores. List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt; { new Student { First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores= new List&amp;lt;int&amp;gt; {97, 72, 81, 60} }, new Student { First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112, Scores= new List&amp;lt;int&amp;gt; {75, 84, 91, 39} }, new Student { First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores= new List&amp;lt;int&amp;gt; {99, 89, 91, 95} }, new Student { First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114, Scores= new List&amp;lt;int&amp;gt; {72, 81, 65, 84} }, new Student { First=&quot;Debra&quot;, Last=&quot;Garcia&quot;, ID=115, Scores= new List&amp;lt;int&amp;gt; {97, 89, 85, 82} } }; return students; } static void Main() { // Obtain the data source. List&amp;lt;Student&amp;gt; students = GetStudents(); // Group by true or false. // Query variable is an IEnumerable&amp;lt;IGrouping&amp;lt;bool, Student&amp;gt;&amp;gt; var booleanGroupQuery = from student in students group student by student.Scores.Average() &amp;gt;= 80; //pass or fail! // Execute the query and access items in each group foreach (var studentGroup in booleanGroupQuery) { Console.WriteLine(studentGroup.Key == true ? &quot;High averages&quot; : &quot;Low averages&quot;); foreach (var student in studentGroup) { Console.WriteLine(&quot; {0}, {1}:{2}&quot;, tudent.Last, student.First, student.Scores.Average()); } } // Keep the console window open in debug mode. Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/* Output: Low averages Omelchenko, Svetlana:77.5 O&#39;Donnell, Claire:72.25 Garcia, Cesar:75.5 High averages Mortensen, Sven:93.5 Garcia, Debra:88.25*/ 결과적으로 bool 키 값에 의해 두 그룹으로 나눠짐. 값은 group 절의 하위 식에서 생성. 숫자 범위 class GroupSample2{ // The element type of the data source. public class Student { public string First { get; set; } public string Last { get; set; } public int ID { get; set; } public List&amp;lt;int&amp;gt; Scores; } public static List&amp;lt;Student&amp;gt; GetStudents() { // Use a collection initializer to create the data source. Note that each element // in the list contains an inner sequence of scores. List&amp;lt;Student&amp;gt; students = new List&amp;lt;Student&amp;gt; { new Student { First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores= new List&amp;lt;int&amp;gt; {97, 72, 81, 60} }, new Student { First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112, Scores= new List&amp;lt;int&amp;gt; {75, 84, 91, 39} }, new Student { First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores= new List&amp;lt;int&amp;gt; {99, 89, 91, 95} }, new Student { First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114, Scores= new List&amp;lt;int&amp;gt; {72, 81, 65, 84} }, new Student { First=&quot;Debra&quot;, Last=&quot;Garcia&quot;, ID=115, Scores= new List&amp;lt;int&amp;gt; {97, 89, 85, 82} } }; return students; } // This method groups students into percentile ranges based on their // grade average. The Average method returns a double, so to produce a whole // number it is necessary to cast to int before dividing by 10. static void Main() { // Obtain the data source. List&amp;lt;Student&amp;gt; students = GetStudents(); // Write the query. var studentQuery = from student in students let avg = (int)student.Scores.Average() group student by (avg / 10) into g orderby g.Key select g; // Execute the query. foreach (var studentGroup in studentQuery) { int temp = studentGroup.Key * 10; Console.WriteLine(&quot;Students with an average between {0} and {1}&quot;, temp, temp + 10); foreach (var student in studentGroup) { Console.WriteLine(&quot; {0}, {1}:{2}&quot;, student.Last, student.First, student.Scores.Average()); } } // Keep the console window open in debug mode. Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/* Output: Students with an average between 70 and 80 Omelchenko, Svetlana:77.5 O&#39;Donnell, Claire:72.25 Garcia, Cesar:75.5 Students with an average between 80 and 90 Garcia, Debra:88.25 Students with an average between 90 and 100 Mortensen, Sven:93.5*/ 식을 사용해 백분위수 범위를 나타내는 숫자 그룹 키를 만듦. 메서드 호출 결과를 저장할 위치로let을 사용하여 group 절에서 메서드를 두 번 호출할 필요가 없다. 쿼리 식에 메서드를 안전하게 사용하는 방법에 대한 자세한 내용은 쿼리 식의 예외 처리 참조. 복합 키 group person by new {name = person.surname, city = person.city}; 둘 이상의 키에 따라 요소를 그룹화하려는 경우 복합 키 사용. 무명 형식이나 명명된 형식을 통해 키 요소로 만듦. 위에서는 Person 클래스가 surname 및 city라는 멤버로 선언되었다고 가정했을떄group 절은 성과 도시가 동일한 각 개인 집합에 대해 별도 그룹이 생성되도록 한다. 쿼리 변수를 다른 메서드에 전달해야 하는 경우 명명된 형식을 사용한다.키에 대해 자동 구현 속성을 사용하여 특수 클래스를 만든 다음Equals 및 GetHashCode 메서드를 재정의.구조체를 사용할 수도 있으며, 이 경우 이러한 메서드를 엄격하게 재정의하지 않아도 된다. 관련 내용은 자동으로 구현된 속성을 사용하여 간단한 클래스를 구현하는 방법,디렉터리 트리의 중복 파일을 쿼리하는 방법을 참조. 비연속 그룹화 class GroupExample1{ static void Main() { // Create a data source. string[] words = { &quot;blueberry&quot;, &quot;chimpanzee&quot;, &quot;abacus&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;cheese&quot; }; // Create the query. var wordGroups = from w in words group w by w[0]; // Execute the query. foreach (var wordGroup in wordGroups) { Console.WriteLine(&quot;Words that start with the letter &#39;{0}&#39;:&quot;, wordGroup.Key); foreach (var word in wordGroup) { Console.WriteLine(word); } } // Keep the console window open in debug mode Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/* Output: Words that start with the letter &#39;b&#39;: blueberry banana Words that start with the letter &#39;c&#39;: chimpanzee cheese Words that start with the letter &#39;a&#39;: abacus apple */ 추가 쿼리 논리가 그룹에 적용되지 않는 경우소스 데이터를 그룹으로 정렬하기 위해 사용. 문자열 배열에 있는 요소는 첫 문자에 따라 그룹화. 쿼리 결과는 char 형식의 공개 키 속성이 포함 된IGrouping&amp;lt;TKey, TElement&amp;gt; 형식과그룹화의 각 항목이 포함 된 IEnumerable&amp;lt;T&amp;gt; 컬렉션. group 절의 결과는 시퀀스의 시퀀스이기 때문에반환된 각 그룹 내의 개별 요소에 액세스하려면그룹 키를 반복하는 루프 안에 중첩된 foreach를 사용. into group, join, select 절의 결과를 새 식별자에 저장하기 위한 임시 식별자. 이 식별자 자체는 추가 쿼리 명령의 생성기일 수 있다. group 또는 select 절에 사용할 경우 새 식별자의 사용을 ‘연속’ 이라고함.class IntoSample1{ static void Main() { // Create a data source. string[] words = { &quot;apples&quot;, &quot;blueberries&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;apricots&quot;}; // Create the query. var wordGroups1 = from w in words group w by w[0] into fruitGroup where fruitGroup.Count() &amp;gt;= 2 select new { FirstLetter = fruitGroup.Key, Words = fruitGroup.Count() }; // Execute the query. Note that we only iterate over the groups, // not the items in each group foreach (var item in wordGroups1) { Console.WriteLine(&quot; {0} has {1} elements.&quot;, item.FirstLetter, item.Words); } // Keep the console window open in debug mode Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/* Output: a has 2 elements. b has 2 elements.*/ into를 사용하여 임시 식별자 fruitGroup을 활성화하는 방법. 이 식별자는 IGrouping의 유추된 형식을 갖는다. 식별자를 사용해 각 그룹에서 Count 메서드를 호출하고둘 이상의 단어를 포함하는 그룹만 선택하고있다.orderby 반환된 시퀀스 또는 하위 시퀀스(그룹)를 오름차순이나 내림차순으로 정렬. 하나 이상의 보조 정렬 작업을 수행하기 위해 여러 키를 지정할 수 있다. 정렬은 요소 형식에 대한 기본 비교자에 의해 수행됩니다. 기본은 오름차순입니다. 사용자 지정 비교자를 지정할 수도 있다. 단, 메서드 기반 구문을 통해서만 가능. 자세한 내용은 데이터 정렬을 참조. ```c# class OrderbySample2 { // The element type of the data source. public class Student { public string First { get; set; } public string Last { get; set; } public int ID { get; set; } } public static List GetStudents() { // Use a collection initializer to create the data source. Note that each element // in the list contains an inner sequence of scores. List students = new List { new Student {First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111}, new Student {First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112}, new Student {First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113}, new Student {First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114}, new Student {First=&quot;Debra&quot;, Last=&quot;Garcia&quot;, ID=115} }; return students; } static void Main(string[] args) { // Create the data source. List&amp;lt;Student&amp;gt; students = GetStudents(); // Create the query. IEnumerable&amp;lt;Student&amp;gt; sortedStudents = from student in students orderby student.Last ascending, student.First ascending select student; // Execute the query. Console.WriteLine(&quot;sortedStudents:&quot;); foreach (Student student in sortedStudents) Console.WriteLine(student.Last + &quot; &quot; + student.First); // Now create groups and sort the groups. The query first sorts the names // of all students so that they will be in alphabetical order after they are // grouped. The second orderby sorts the group keys in alpha order. var sortedGroups = from student in students orderby student.Last, student.First group student by student.Last[0] into newGroup orderby newGroup.Key select newGroup; // Execute the query. Console.WriteLine(Environment.NewLine + &quot;sortedGroups:&quot;); foreach (var studentGroup in sortedGroups) { Console.WriteLine(studentGroup.Key); foreach (var student in studentGroup) { Console.WriteLine(&quot; {0}, {1}&quot;, student.Last, student.First); } } // Keep the console window open in debug mode Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); } } /* Output: sortedStudents: Garcia Cesar Garcia Debra Mortensen Sven O&#39;Donnell Claire Omelchenko Svetlana sortedGroups: G Garcia, Cesar Garcia, Debra M Mortensen, Sven O O’Donnell, Claire Omelchenko, Svetlana */- **ascending** - 쿼리 식의 orderby 절에서 정렬 순서를 오름차순으로 지정. - ascending은 기본 정렬 순서이므로 지정할 필요가 없다. ```c# IEnumerable&amp;lt;string&amp;gt; sortAscendingQuery = from vegetable in vegetables orderby vegetable ascending select vegetable; descending 쿼리 식의 orderby 절에서 정렬 순서를 내림차순으로 지정. IEnumerable&amp;lt;string&amp;gt; sortDescendingQuery =from vegetable in vegetablesorderby vegetable descendingselect vegetable; join 개체 모델에서 직접적인 관계가 없는 서로 다른 소스 시퀀스의 요소를 연결. 각 소스의 요소가 같은지 비교할 수 있는 일부 값을 공유할 수 있어야함. 예를들어 식품 유통업체에 특정 제품의 공급업체 목록과 구매자 목록이 있을 때해당 제품의 공급업체 및 구매자 목록을 만드는 데 사용할 수 있다. join 절은 두 개의 소스 시퀀스를 입력으로 사용.각 시퀀스의 요소는 다른 시퀀스의 속성과 비교할 수 있는 속성이거나 해당 속성을 포함해야 함. join 절은 특수한 equals 키워드를 사용하여 지정된 키가 같은지 비교한다. join 절로 수행된 모든 조인은 동등 조인이다. join 절의 출력 형태는 수행하는 조인의 특정 유형에 따른다. 일반적인 조인 유형 내부 조인 그룹 조인 왼쪽 우선 외부 조인 on 을 사용해 조인 조건을 지정. Inner join var innerJoinQuery = from cate in categories.AsEnumerable() join prod in products.AsEnumerable() on cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) equals prod.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) select new { CateID = cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;), CateName = cate.Field&amp;lt;string&amp;gt;(&quot;Name&quot;), ProdID = prod.Field&amp;lt;string&amp;gt;(&quot;ID&quot;), ProdName = prod.Field&amp;lt;string&amp;gt;(&quot;Name&quot;), };foreach (var item in innerJoinQuery){ DataRow dr = result.NewRow(); dr[&quot;CateID&quot;] = item.CateID; dr[&quot;CateName&quot;] = item.CateName; dr[&quot;ProdID&quot;] = item.ProdID; dr[&quot;ProdName&quot;] = item.ProdName; result.Rows.Add(dr);} 내부 동등 조인의 예. 조건은 on뒤에 쓰는데 이떄는 equals만 허용한다함 ID를 비교해 같은 ID에 대한 정보 출력. categories의 요소에 일치하는 products가 없는 경우 해당 범주는 결과에 나타나지 않음. Left outer join var leftOuterJoinQuery = from category in data.categories.AsEnumerable() join prod in data.products.AsEnumerable() on category.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) equals prod.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) into prodGroup from item in prodGroup.DefaultIfEmpty() select new { CateID = category.Field&amp;lt;string&amp;gt;(&quot;ID&quot;), CateName = category.Field&amp;lt;string&amp;gt;(&quot;Name&quot;), ProdID = item == null ? string.Empty : item.Field&amp;lt;string&amp;gt;(&quot;id&quot;), PtodName = item == null ? string.Empty : item.Field&amp;lt;string&amp;gt;(&quot;Name&quot;) }; foreach (var item in leftOuterJoinQuery){ DataRow dr = result.NewRow(); dr[&quot;CateID&quot;] = item.CateID; dr[&quot;CateName&quot;] = item.CateName; dr[&quot;ProdID&quot;] = item.ProdID; dr[&quot;ProdName&quot;] = item.PtodName; result.Rows.Add(dr);} Left outer join에서는 오른쪽 시퀀스에 일치하는 요소가 없는 경우에도왼쪽 소스 시퀀스의 모든 요소가 반환됩니다. LINQ에서 Left outer join을 수행하려면그룹 조인과 함께 DefaultIfEmpty 메서드를 사용하여왼쪽 요소에 일치하는 요소가 없을 경우생성할 기본 오른쪽 요소를 지정합니다. null을 모든 참조 형식의 기본값으로 사용하거나사용자 정의 기본 형식을 지정할 수 있습니다. Group join into 식을 포함한 join . 좀 특이한데 결과가 단순히 inner join처럼 될수도있고아니면 left join처럼 될 수도 있음 왼쪽 기준 오른쪽에 있으면 값이 들어오고없으면 빈 배열 들어옴. 결과에 그룹화된 결과가 들어온다는점을 제외하면개본적으로 inner join과 같음 그룹을 풀어 foreach를 줄여줄 수 있음 like inner join var groupJoinQuery = from cate in data.categories.AsEnumerable() join prod in data.products.AsEnumerable() on cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) equals prod.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) into prodgroup select new { CateID = cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;), CateName = cate.Field&amp;lt;string&amp;gt;(&quot;Name&quot;), ProdGroup = prodgroup };foreach (var item in groupJoinQuery){ foreach (var pg in item.ProdGroup) { DataRow dr = result.NewRow(); dr[&quot;CateID&quot;] = item.CateID; dr[&quot;CateName&quot;] = item.CateName; dr[&quot;ProdID&quot;] = pg.Field&amp;lt;string&amp;gt;(&quot;ID&quot;); dr[&quot;ProdName&quot;] = pg.Field&amp;lt;string&amp;gt;(&quot;Name&quot;); result.Rows.Add(dr); }} 보통의 경우 inner join처럼 출력. 위 설명에 그룹화된 결과를 제외하면 기본적으로 inner join과 같다는게 이거. like left join var groupJoinQuery2 = from cate in data.categories.AsEnumerable() join prod in data.products.AsEnumerable() on cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) equals prod.Field&amp;lt;string&amp;gt;(&quot;ID&quot;) into prodgroup select new { CateID = cate.Field&amp;lt;string&amp;gt;(&quot;ID&quot;), CateName = cate.Field&amp;lt;string&amp;gt;(&quot;Name&quot;), ProdGroup = prodgroup };foreach (var item in groupJoinQuery2){ if (item.ProdGroup.ToList().Count &amp;gt; 0) { foreach (var pg in item.ProdGroup) { DataRow dr = result.NewRow(); dr[&quot;CateID&quot;] = item.CateID; dr[&quot;CateName&quot;] = item.CateName; dr[&quot;ProdID&quot;] = pg.Field&amp;lt;string&amp;gt;(&quot;ID&quot;); dr[&quot;ProdName&quot;] = pg.Field&amp;lt;string&amp;gt;(&quot;Name&quot;); result.Rows.Add(dr); } } else { DataRow dr = result.NewRow(); dr[&quot;CateID&quot;] = item.CateID; dr[&quot;CateName&quot;] = item.CateName; result.Rows.Add(dr); }} 데이터 검색을 좀 더 바꿔본다. 사실 위 설명 다시보면 왼쪽기준 오른쪽에 있으면 값이 들어오고없으면 빈 배열 들어온다 했다.이걸 다 출력하면 left join처럼 된다. 근데 이럴꺼면 굳이 Group Join을 쓸 이유가 있나? equals join 절은 동등 조인을 수행.즉, 일치 항목만을 기준으로 두 키가 같은지 비교할 수 있다.“보다 큼”이나 “같지 않음”과 같은 다른 유형의 비교는 지원되지 않는다. 동등 조인인지 확인하기 위해 “==” 연산자 대신 “equals” 키워드를 사용. equals 키워드는 join 절에서만 사용할 수 있으며 == 연산자와 다르다. equals를 사용할 경우 왼쪽 키는 외부 소스 시퀀스를 사용하고오른쪽 키는 내부 소스를 사용. 외부 소스는 equals의 왼쪽 범위에만 있고 내부 소스 시퀀스는 오른쪽 범위에만 있음. 그 외 비동등조인, 개체 컬렉션 및 관계형 테이블에서 조인, 복합키 등많은건 따로 참고. let 쿼리 식에서 하위 식의 결과를후속 절에서 사용하기 위해 사용. 새 범위 변수를 만들고 제공한 식의 결과로 초기화. 값으로 초기화되면 범위 변수를 사용하여 다른 값을 저장할 수 없음.그러나 범위 변수가 쿼리 가능 형식을 포함할 경우 쿼리할 수 있음. class LetSample1{ static void Main() { string[] strings = { &quot;A penny saved is a penny earned.&quot;, &quot;The early bird catches the worm.&quot;, &quot;The pen is mightier than the sword.&quot; }; // Split the sentence into an array of words // and select those whose first letter is a vowel. var earlyBirdQuery = from sentence in strings let words = sentence.Split(&#39; &#39;) from word in words let w = word.ToLower() where w[0] == &#39;a&#39; || w[0] == &#39;e&#39; || w[0] == &#39;i&#39; || w[0] == &#39;o&#39; || w[0] == &#39;u&#39; select word; // Execute the query. foreach (var v in earlyBirdQuery) { Console.WriteLine(&quot;\\&quot;{0}\\&quot; starts with a vowel&quot;, v); } // Keep the console window open in debug mode. Console.WriteLine(&quot;Press any key to exit.&quot;); Console.ReadKey(); }}/* Output: &quot;A&quot; starts with a vowel &quot;is&quot; starts with a vowel &quot;a&quot; starts with a vowel &quot;earned.&quot; starts with a vowel &quot;early&quot; starts with a vowel &quot;is&quot; starts with a vowel*/ 여기에서는 2가지 용도로 사용하는데 그 자체를 쿼리할 수 있는 열거 가능한 형식을 생성. 쿼리가 범위 변수 word에서 ToLower를 한 번만 호출할 수 있도록 함.let을 사용하지 않을 경우 where 절의 각 조건자에서 ToLower를 호출해야 한다. 참고 C# 프로그래밍 가이드 LINQ C# 개념 LINQ" }, { "title": "12. async/await_3 Excention 2", "url": "/posts/CS_12_Async&Await_4/", "categories": "Grind, C#", "tags": "c#, asynchronous", "date": "2021-03-31 12:00:00 +0900", "snippet": "about exception of void return. 쉽게, sync에서 먼저. class asaw_4_sync{ public void ThrowException() { throw new InvalidOperationException(); } public void SyncExceptions() { try { ThrowException(); } catch (Exception) { // The exception is never caught here! throw; } }}////////////////////////////////////////////////////private void button1_Click(object sender, EventArgs e){ try { aa4s.SyncExceptions(); } catch (Exception ex) { textBox1.AppendText(ex.Message + Environment.NewLine); }} 예상 가능한 결과로호출은 button event =&amp;gt; SyncExceptions() =&amp;gt; ThrowException() 으로, Exceptions은 ThrowException() =&amp;gt; SyncExceptions() =&amp;gt; button event로잘 타고 온다. 항상 보던 당연한 결말. 위 방식을 async로 바꿔해본다. class ASAW_4_async_1{ public async void ThrowException() { throw new InvalidOperationException(); } public void AsyncExceptions() { try { ThrowException(); } catch (Exception) { // The exception is never caught here! throw; } }}//////////////////private void button2_Click(object sender, EventArgs e){ try { aa4a_1.AsyncExceptions(); } catch (Exception ex) { textBox1.AppendText(ex.Message + Environment.NewLine); }} 바뀐점은 ThrowException()가 async로 된것, 또 하지말라던 void로 한것. 호출은 button event =&amp;gt; AsyncExceptions() =&amp;gt; ThrowException()으로 동일,Exception은 throw new InvalidOperationException(); 에서 멈춘다.저 라인에서 throw를 못한다. 그럼 void가 아니라면?? class ASAW_4_async_2{ public async Task ThrowException() { throw new InvalidOperationException(); } public void AsyncExceptions() { try { ThrowException(); } catch (Exception) { // The exception is never caught here! throw; } }}////////////////////////////////////////////////////////private void button2_Click(object sender, EventArgs e){ try { aa4a_1.AsyncExceptions(); } catch (Exception ex) { textBox1.AppendText(ex.Message + Environment.NewLine); }} 위 ASAW_4_async_1과의 차이점은 void에서 Task가 된것. 호출 순서야 같은데 이번엔 throw new InvalidOperationException();에서Exception도 안잡히고 끝난다. 아무런 반응이 없다. 이 전 async/await_3 excention 1에서 말하는 The exception is never caught here!은 Exception이 잡히건 말건 해당 try/catch는 절대 안들어온다는 뜻인것같다. 그럼 되는방법은? class ASAW_4_async_3{ //public async void ThrowException() //{ // throw new InvalidOperationException(); //} public async Task ThrowException() { throw new InvalidOperationException(); } public async void AsyncExceptions() { try { await ThrowException(); } catch (Exception) { // The exception is never caught here! throw; } }}///////////////////////////////////////////////////////////private void button4_Click(object sender, EventArgs e){ try { aa4a_3.AsyncExceptions(); } catch (Exception ex) { textBox1.AppendText(ex.Message + Environment.NewLine); }} 다른점 AsyncExceptions : async에 있어야할 await가 붙음 async void를 그대로 하면 호출할때 에러남 async Task로 수정. 결과는 AsyncExceptions() 의 catch 부분에서 잡힌다. 따라서 정상적인 처리는 되는것처럼 보이는데AsyncExceptions에서 button event로 throw는 안됨. 이 부분은 다시 button4_Click를 async void로 수정하고aa4a_3.AsyncExceptions(); 호출을 await로 한다.AsyncExceptions()도 async void에서 async Task로 수정. class ASAW_4_async_3{ //public async void ThrowException() //{ // throw new InvalidOperationException(); //} public async Task ThrowException() { throw new InvalidOperationException(); } public async Task AsyncExceptions() { try { await ThrowException(); } catch (Exception) { // The exception is never caught here! throw; } }}///////////////////////////////////////////////////////////private async void button4_Click(object sender, EventArgs e){ try { await aa4a_3.AsyncExceptions(); } catch (Exception ex) { textBox1.AppendText(ex.Message + Environment.NewLine); }} 이렇게 되면 button event에서 정상적으로 잡아냄 원래 sync처럼. void AsyncExceptions()에서 Task AsyncExceptions()으로수정했는데 되는거 보면 Task에 뭔가 있겠지? so… 결과를 보면 async 함수들은 Task를 이용해 그 안에 정보를 넘기는듯하다.근데 return이 Task니까 당연한건가 싶은데data적인return 외에도 method적인 측면에서 실행 결과까지.그래서 void return의 경우.. 넘길 수 없어서 그 선에서 끝내는건가?? 무튼 return되는 Task에는 Exception까지 있는것같은데 다시,async/await_3 excention 2 의 Avoid Async Void 를 보면 Async void 메서드는 오류 처리 의미가 다르다. 비동기 작업 또는 비동기 Task&amp;lt;T&amp;gt; 메서드에서 예외가 throw되면 해당 예외가 캡처되어 Task 개체에 배치함. async void 메서드를 사용하면 Task 개체가 없으므로 async void 메서드에서 throw 된 모든 예외는 async void 메서드가 시작될 때 활성화 된 SynchronizationContext에서 직접 발생. 다음은 비동기 void 메서드에서 throw 된 exception을 catch못한 경우. 이 말이 이제 이해가 감. 그럼 event를 제외하고 async void를 쓰지 말라했는데exception의 최종 목적지이면 상관이 없어보임.근데 이렇게 따지느니 Task로 도배하는게 맞는것같기도하고.. 사실 async/await가 해주는 일이 더 많고이것저것 더 볼게 많은것같은데 이거 찾으면서, 또는 이 관련해 더 많은건 아래.참고 Async 쓸까말까 및 주의할 점 async void가 안좋은 이유 async 메서드의 void 반환 타입 사용에 대하여 C# 컴파일러 대신 직접 구현하는 비동기(async/await) 코드 async void 메서드의 예외는 정말 Fire &amp;amp; forget 일까?" }, { "title": "11. async/await_3 Excention 1", "url": "/posts/CS_11_Async&Await_3/", "categories": "Grind, C#", "tags": "c#, asynchronous", "date": "2021-03-30 18:00:00 +0900", "snippet": "AS/AW Example 필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 .. source text파일을 읽고 table 형태로 만들고 grid에 넣음.실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄. 하던 과정 그대로 일단.example 1// 실제 파일을 읽고 취합 후 구조화한 후, // DataTable를 return.// async로 작업할 부분.DataTable datamaker(){...}//datamaker를 호출하는 부분async Task&amp;lt;DataTable&amp;gt; asyncmtd_2(){ DataTable res = null; res = await Task&amp;lt;DataTable&amp;gt;.Run(() =&amp;gt; { return datamaker(); }); return res;}//다시, asyncmtd()를 호출하는부분async void asyncmtd_1(){ try { Task&amp;lt;DataTable&amp;gt; t = asyncmtd_2(); DataTable dt = await asyncmtd_2(); this.dataGridView1.DataSource = dt; //throw new InvalidOperationException(); } catch (Exception) { throw; } }private async void btn_async_Click(object sender, EventArgs e){ this.textBox1.AppendText(Environment.NewLine + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)); asyncmtd_1(); Task&amp;lt;DataTable&amp;gt; t = asyncmtd_2(); DataTable dt = await t; this.dataGridView1.DataSource = dt; this.textBox1.AppendText(Environment.NewLine + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;));} 처음에 만든게 이런식이었는데 이렇게 된 이유는ascyn method는 task를 return하도록하고 void는 권장하지 않음.단, event는 제외. 관련 내용은 이 전 포스팅에 있음. 그런데 method내부에 await가 있으면해당 method는 무조건 async가 붙어야함 (컴파일에러) asyncmtd_2는 위 조건에 따라 만들어지는데이건 또 일반 method에서는 호출을 못함.일반 method에서 호출을하려면 task, await를 써야하는데이러면 method에 또 async가 붙어야 하고또 Task를 return하게 바꾸게됨. 이런식으로 계속 같은 method내용을 계속 쓰게되는데위 사항을 지켜가면서 만들면 끝이 안남.async가 번지는느낌. 결국 위처럼 void로 끝냄.근데 void로 끝내면 일반 method처럼 호출가능.이렇게 작성된게 asyncmethod_1. 단, event는 async void가 혀용된다고 했으니 이 점을 감안하면asyncmethod_2도 위처럼 호출해쓸 수 있음. 그런데 꼭 event에 의해 사용하고싶지는 않으니…example 2DataTable datamaker(){...}async void asyncmtd_3(){ try { DataTable res = await Task&amp;lt;DataTable&amp;gt;.Run(() =&amp;gt; { return datamaker(); }); this.dataGridView1.DataSource = res; } catch (Exception ex) { Console.WriteLine(ex); this.textBox1.AppendText(ex.Message); }}private void btn_async_Click(object sender, EventArgs e){ this.textBox1.AppendText(Environment.NewLine + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;)); asyncmtd_3(); this.textBox1.AppendText(Environment.NewLine + DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss.fff&quot;));} ex1에서 asyncmtd_2처럼 쓰는데 return을 void로 하면다른 method처럼 호출 가능.다만 이 경우 exceptioon이 안잡히니 void형은 권장하지 않는 거였는데해보니 또 잘 잡힘…일단은 이렇게 써도 되는걸로?Async/Await - Best Practices in Asynchronous Programming1 관련해서 좀 더 설명이 있는것같아 찾아봄. 가이드 라인 정도로 생각하라함.Avoid Async Void 비동기 메서드에는 Task, Task&amp;lt;T&amp;gt; 및 void의 세 가지 가능한 반환 형식이 있지만비동기 메서드의 자연적인 반환 형식은 Task 및 Task&amp;lt;T&amp;gt;임.동기 코드에서 비동기 코드로 변환 할 때,T 형식을 반환하는 모든 메서드는 Task&amp;lt;T&amp;gt;를 반환하는 비동기 메서드가 되고void를 반환하는 모든 메서드는 Task를 반환하는 비동기 메서드가됨.예를들어 void MyMethod(){// Do synchronous work.Thread.Sleep(1000);}async Task MyMethodAsync(){// Do asynchronous work.await Task.Delay(1000);} void 반환 비동기 메서드에는 비동기 이벤트 처리기를 가능하게하는 특정 목적이 있다.실제 유형을 반환하는 이벤트 처리기를 가질 수 있지만 언어에서는 제대로 작동하지 않는다.유형을 반환하는 이벤트 핸들러를 호출하는 것은 매우 어색하며실제로 무언가를 반환하는 이벤트 핸들러의 개념은별로 의미가 없음.이벤트 핸들러는 자연스럽게 void를 반환하므로비동기 이벤트 핸들러를 가질 수 있도록 비동기 메소드가 void를 반환.그러나 async void 메서드의 일부 의미는async Task 또는 async Task&amp;lt;T&amp;gt; 메서드의 의미와 미묘하게 다르다. Async void 메서드는 오류 처리 의미가 다르다.비동기 작업 또는 비동기 Task&amp;lt;T&amp;gt; 메서드에서 예외가 throw되면해당 예외가 캡처되어 Task 개체에 배치함.async void 메서드를 사용하면 Task 개체가 없으므로async void 메서드에서 throw 된 모든 예외는async void 메서드가 시작될 때 활성화 된 SynchronizationContext에서 직접 발생.다음은 비동기 void 메서드에서 throw 된 exception을 catch못한 경우. // #1private async void ThrowExceptionAsync(){ throw new InvalidOperationException();}public void AsyncVoidExceptions_CannotBeCaughtByCatch(){ try { ThrowExceptionAsync(); } catch (Exception) { // The exception is never caught here! throw; }} 이러한 예외는 AppDomain.UnhandledException 또는GUI / ASP.NET 응용 프로그램에 대한 유사한catch-all 이벤트를 사용하여 관찰 할 수 있지만이러한 이벤트를 일반 예외 처리에 사용하면 유지 관리가 불가능해짐. async void 메서드는 구성 의미가 다르다고 했다.Task 또는 Task&amp;lt;T&amp;gt;를 반환하는 비동기 메서드는await, Task.WhenAny, Task.WhenAll 등을 사용하여 쉽게 구성 할 수 있는반면,void를 반환하는 비동기 메서드는 호출 코드에 완료를 알리는 쉬운 방법이 없다.여러 async void 메서드를 시작하는 것은 쉽지만 완료 시점 확인이 어렵다.비동기 void 메서드는 시작 및 완료 될 때 SynchronizationContext에 알리지만사용자 지정 SynchronizationContext는 일반 애플리케이션 코드를 위한 복잡한 방법임. Async void 메서드는 테스트하기가 어려움.오류 처리 및 구성의 차이로 인해비동기 void 메서드를 호출하는 단위 테스트를 작성하기가 어렵다.MSTest 비동기 테스트 지원은Task 또는 Task&amp;lt;T&amp;gt;를 반환하는 비동기 메서드에 대해서만 작동함.모든 비동기 void 메서드가 완료되었을 때를 감지하고예외를 수집하는 SynchronizationContext를 설치할 수 있지만,비동기 void 메서드가 대신 Task를 반환하도록하는 것이 훨씬 쉽다. async void 메서드는 async Task 메서드에 비해 단점이 있지만,비동기 이벤트 처리기라는 특정 경우에 매우 유용함.의미 체계의 차이는 비동기 이벤트 처리기에서 의미가 있다.동기 이벤트 처리기가 작동하는 방식과 유사한SynchronizationContext에서 직접 예외를 발생시킨다.동기식 이벤트 핸들러는 일반적으로 비공개이므로구성하거나 직접 테스트 할 수 없다.여기에서(?) 선호하는 접근 방식은 비동기 이벤트 처리기 코드의 최소화.예를 들어 실제 논리가 포함 된 비동기 작업 메서드를 기다리도록한다.다음 코드는 테스트 가능성을 희생하지 않고이벤트 처리기에 비동기 void 메서드를 사용하는이 접근 방식의 예시. // #2// Async Void 메서드의 예외는 Catch로 포착 할 수 없다.private async void button1_Click(object sender, EventArgs e){ await Button1ClickAsync();}public async Task Button1ClickAsync(){ // Do asynchronous work. await Task.Delay(1000);} 호출자가 비동기 일 것으로 예상하지 않는 경우 비동기 void 메서드는 혼란을 일으킬 수 있다.반환 유형이 Task이면 호출자는 향후 작업을 처리하고 있음을 알고 있지만반환 유형이 void이면 호출자는 반환 할 때까지 메서드가 완료되었다고 가정 할 수 있다.이 문제는 예기치 않은 여러 가지 방식으로 발생할 수 있다.인터페이스 (또는 기본 클래스)에서 void 반환 메서드의비동기 구현(또는 재정의)을 제공하는 것은 일반적으로 잘못됨.일부 이벤트는 반환 할 때 처리기가 완료되었다고 가정한다.한 가지 미묘한 트랩은 비동기 람다를 Action 매개 변수를 사용하는 메서드에 전달하는 것.이 경우 비동기 람다는 void를 반환하고 비동기 void 메서드의 모든 문제를 상속한다.일반적으로 비동기 람다는 Task를 반환하는 대리자 형식(예 : Func&amp;lt;Task&amp;gt;)으로 변환 된 경우에만 사용해야한다. 요약하면 async void보다 async Task를 강권함.비동기 작업 메서드를 사용하면 오류 처리, 구성 가능성 및 테스트 가능성이 더 쉬움.이 가이드 라인의 예외는 void를 반환해야하는 비동기 이벤트 처리기이며이 예외에는 문자 그대로 이벤트 처리기가 아니더라도 논리적으로이벤트 처리기 인 메서드(예 : ICommand.Execute 구현)가 포함. Async All the Way 동기식 코드를 비동기식 코드로 변환할 때비동기식 코드가 호출될 경우 가장 잘 작동하고다른 비동기식 코드에 의해 호출되며,이 코드는 하향식(또는 “상향식”)으로 호출된다.다른 사람들은 또한 비동기 프로그래밍의 확산 동작을 발견하고이를 “전염성”이라고 부르거나 좀비 바이러스와 비교했다.비동기 코드는 주변 코드를 비동기로 만드는 경향이 있다. “Async all the way”는 결과를 신중하게 고려하지 않고동기 코드와 비동기 코드를 혼합해서는 안된다는 의미.특히 Task.Wait 또는 Task.Result를 호출하여비동기 코드를 차단하는 것은 일반적으로 좋지 않다.이는 애플리케이션의 작은 부분 만 변환하고 이를 동기 API로 래핑하여나머지 애플리케이션이 변경 사항으로부터 격리되도록“발가락”을 비동기 프로그래밍으로 전환하는 프로그래머에게 특히 일반적인 문제다.이는 교착 상태를 유발할 가능성이 커짐. 다음은 하나의 메서드가 비동기 메서드의 결과를 차단하는 간단한 예.이 코드는 콘솔 응용 프로그램에서 잘 작동하지만GUI 또는 ASP.NET 컨텍스트에서 호출되면 교착 상태가 됨.이 동작은 혼란 스러울 수 있는데, 특히 디버거를 단계별로 진행하는 것이완료되지 않는 대기라는 것을 의미한다는 점을 고려할 때 특히 그렇다.교착 상태의 실제 원인은 Task.Wait가 호출 될 때 호출 스택보다 더 높다. // #3// 비동기 코드에서 차단할 때 발생하는 일반적인 교착 상태 문제public static class DeadlockDemo{ private static async Task DelayAsync() { await Task.Delay(1000); } // This method causes a deadlock when called in a GUI or ASP.NET context. public static void Test() { // Start the delay. var delayTask = DelayAsync(); // Wait for the delay to complete. delayTask.Wait(); }} 이 교착 상태의 근본 원인은 await가 컨텍스트를 처리하는 방식 때문인데,기본적으로 완료되지 않은 작업이 대기하면현재 “컨텍스트”가 캡처되어 작업이 완료 될 때 메서드를 재개하는 데 사용됨.이 “컨텍스트”는 null이 아닌 경우현재 SynchronizationContext이며, 이 경우 현재 TaskScheduler임.GUI 및 ASP.NET 응용 프로그램에는한 번에 하나의 코드 청크 만 실행할 수있는 SynchronizationContext가 있다.await가 완료되면 캡처 된 컨텍스트 내에서나머지 비동기 메서드를 실행하려함.그러나 해당 컨텍스트에는 이미 스레드가 있으며비동기 메서드가 완료되기를(동기적으로) 기다리고 있다.이 둘은 서로를 기다리고있어 교착 상태가 발생. 콘솔 응용 프로그램은이 교착 상태를 일으키지 않는다.한 번에 하나의 청크 SynchronizationContext 대신스레드풀 SynchronizationContext가 있으므로대기가 완료되면 스레드풀 스레드에서 나머지 비동기 메서드를 예약한다.메서드는 완료 할 수 있으며 반환 된 작업을 완료하며 교착 상태가 없다.이러한 동작의 차이는 프로그래머가 테스트 콘솔 프로그램을 작성하고부분적으로 비동기 코드가 예상대로 작동하는 것을 관찰 한 다음동일한 코드를 GUI 또는 ASP.NET 응용 프로그램으로 이동하여교착 상태가되는 경우 혼란 스러울 수 있dma. 이 문제에 대한 최선의 해결책은코드베이스를 통해 비동기 코드가 자연스럽게 성장하도록하는 것.이 솔루션을 따르면 비동기 코드가진입점 (일반적으로 이벤트 처리기 또는 컨트롤러 작업)으로 확장된다.Main 메서드가 비동기 일 수 없기 때문에콘솔 응용 프로그램은 이 솔루션을 완전히 따를 수 없다.Main 메서드가 비동기 인 경우완료되기 전에 반환되어 프로그램이 종료 될 수 있다.다음은 지침에 대한이 예외로 콘솔 응용 프로그램의 Main 메서드는코드가 비동기 메서드에서 차단 될 수 있는 몇 안되는 상황 중 하나. // #4 // Main 메서드는 Task.Wait 또는 Task.Result를 호출 할 수 있습니다. class Program { static void Main() { MainAsync().Wait(); } static async Task MainAsync() { try { // Asynchronous implementation. await Task.Delay(1000); } catch (Exception ex) { // Handle exceptions. } } } 코드베이스를 통해 비동기가 성장하도록허용하는 것이 최상의 솔루션이지만,이는 애플리케이션이 비동기 코드의실질적인 이점을 확인하기위한많은 초기 작업이 있음을 의미한다.대규모 코드베이스를 비동기 코드로점진적으로 변환하는 몇 가지 기술이 있지만이 문서의 범위를 벗난다.경우에 따라 Task.Wait 또는 Task.Result를 사용하면부분 변환에 도움이 될 수 있지만교착 상태 문제와 오류 처리 문제를 알고 있어야한다.뒤는 오류 처리 문제를 설명하고이 글의 뒤에서는 교착 상태 문제를 피하는 방법을 설명함. 모든 작업은 예외 목록을 저장한다.태스크를 기다릴 때 첫 번째 예외가 다시 발생하므로특정 예외 유형 (예 : InvalidOperationException)을 포착 할 수 있다.그러나 Task.Wait 또는 Task.Result를 사용하여 Task를 동기적으로 차단하면모든 예외가 AggregateException으로 래핑되고 throw된다.다시 위 예시를 참조하면, MainAsync의 try/catch는 특정 예외 유형을 포착하지만,Main에 try/catch를 넣으면 항상 AggregateException을 포착한다.AggregateException이 없으면 오류 처리가 훨씬 더 쉽게 처리 할 수 있으므로MainAsync에 “global” try / catch를 넣음. 지금까지 비동기 코드 차단과 관련된 두 가지 문제,즉 가능한 교착 상태와 더 복잡한 오류 처리를 보았다.다음 예는 비동기 메서드 내에서 차단 코드를 사용할 때의 문제. // #5public static class NotFullyAsynchronousDemo{ // This method synchronously blocks a thread. public static async Task TestNotFullyAsync() { await Task.Yield(); Thread.Sleep(5000); }} 위 방법은 완전히 비동기식이 아니다.즉시 양보하여 불완전한 작업을 반환하지만재개되면 실행중인 스레드를 동기적으로 차단한다.이 메소드가 GUI 컨텍스트에서 호출되면 GUI 스레드를 차단.ASP.NET 요청 컨텍스트에서 호출되면현재 ASP.NET 요청 스레드를 차단.비동기 코드는 동기적으로 차단되지 않는 경우 가장 잘 작동.다음은 동기식 작업을위한 비동기식 대체 방법. To Do This … Instead of This … Use This Retrieve the result of a background task Task.Wait or Task.Result await Wait for any task to complete Task.WaitAny await Task.WhenAny Retrieve the results of multiple tasks Task.WaitAll await Task.WhenAll Wait a period of time Thread.Sleep await Task.Delay 요약하면비동기 코드와 차단 코드를 혼합하지 않아야한다.혼합 된 비동기 및 차단 코드는 교착 상태,더 복잡한 오류 처리 및 예기치 않은 컨텍스트 스레드 차단을 유발할 수 있다.이 가이드 라인의 예외는 콘솔 응용 프로그램을 위한 Main 메서드 또는고급 사용자 인 경우 부분적으로 비동기 코드베이스를 관리하는 것입니다. Configure Context 이 전 내용에서 불완전한 작업이 대기 할 때기본적으로 “컨텍스트”가 캡처되는 방법과해당 컨텍스트를 사용하여 비동기 메서드를다시 시작하는 방법에 대해 간단히 설명했다.#3의 예시는 컨텍스트에서 재개가동기 차단과 충돌하여 교착 상태를 유발하는지 보였다.이 컨텍스트 동작은 성능 문제를 일으킬 수도 있다.비동기 GUI 애플리케이션이 커짐에 따라GUI 스레드를 컨텍스트로 사용하는비동기 메소드의 많은 작은 부분을 찾을 수 있다.이로 인해 “수천 장의 종이 절단”으로 인해응답 성이 저하되므로 느려질 수 있다.(This can cause sluggishness as responsiveness suffersfrom “thousands of paper cuts.”) 이를 완화하려면 가능할 때마다 ConfigureAwait의 결과를 기다린다.다음 예는 기본 컨텍스트 동작과 ConfigureAwait의 사용방법. async Task MyMethodAsync(){ // Code here runs in the original context. await Task.Delay(1000); // Code here runs in the original context. await Task.Delay(1000).ConfigureAwait( continueOnCapturedContext: false); // Code here runs without the original // context (in this case, on the thread pool).} ConfigureAwait는 적은 양의 병렬 처리를 활성화 할 수 있다.일부 비동기 코드는 수행 할 작업으로 끊임없이배지를 표시하는 대신 GUI 스레드와 병렬로 실행할 수 있다. 성능 외에도 ConfigureAwait의 또 다른 중요한점은 교착 상태를 피할 수 있게 한다는것.#3에서 DelayAsync의 코드 줄에“ConfigureAwait(false)”를 추가하면 교착 상태가 방지된다.이번에는 await가 완료되면 스레드풀 컨텍스트 내에서나머지 비동기 메서드를 실행하려한다.메서드는 완료 할 수 있으며반환 된 작업을 완료하며 교착 상태가 없다.이 기술은 응용 프로그램을 동기에서 비동기로점진적으로 변환해야하는 경우 특히 유용하다. 메서드 내에서 어느 시점에서 ConfigureAwait를 사용할 수 있다면해당 시점 이후에 해당 메서드의 모든 await에 대해 사용하는 것이 좋다.불완전한 작업이 대기하는 경우에만 컨텍스트가 캡처된다.태스크가 이미 완료된 경우 컨텍스트가 캡처되지 않는다.일부 작업은 다른 하드웨어 및 네트워크 상황에서예상보다 빨리 완료 될 수 있으며,기다리기 전에 완료되는 반환 된 작업을 정중하게 처리해야한다.#6 은 수정 된 예. // #6 // 기다리기 전에 완료되는 반환 된 작업 처리async Task MyMethodAsync(){ // Code here runs in the original context. await Task.FromResult(1); // Code here runs in the original context. await Task.FromResult(1).ConfigureAwait(continueOnCapturedContext: false); // Code here runs in the original context. var random = new Random(); int delay = random.Next(2); // Delay is either 0 or 1 await Task.Delay(delay).ConfigureAwait(continueOnCapturedContext: false); // Code here might or might not run in the original context. // The same is true when you await any Task // that might complete very quickly.} 컨텍스트가 필요한 메서드에서await 후에 코드가있는 경우 ConfigureAwait를 사용하면 안됨.GUI 앱의 경우 여기에는 GUI 요소를 조작하거나데이터 바인딩 된 속성을 작성하거나Dispatcher/CoreDispatcher와 같은GUI 특정 유형에 의존하는 모든 코드가 포함된다.ASP.NET 앱의 경우 여기에는 컨트롤러 작업의 반환 문을 포함하여HttpContext.Current를 사용하거나ASP.NET 응답을 빌드하는 모든 코드가 포된다.#7 은 GUI 앱의 한 가지 일반적인 패턴을 보여준다.비동기 이벤트 처리기가 메서드 시작시 제어를 비활성화하고일부 대기를 수행 한 다음 처리기 끝에서 제어를 다시 활성화한다.이벤트 핸들러는 제어를 다시 활성화해야하므로 컨텍스트를 포기할 수 없다. // #7 // 비동기 이벤트 처리기가 제어를 비활성화하고 다시 활성화하도록 설정private async void button1_Click(object sender, EventArgs e){ button1.Enabled = false; try { // Can&#39;t use ConfigureAwait here ... await Task.Delay(1000); } finally { // Because we need the context here. button1.Enabled = true; }} 각 비동기 메서드에는 고유 한 컨텍스트가 있으므로한 비동기 메서드가 다른 비동기 메서드를 호출하면해당 컨텍스트는 독립적입니다.#8 은 #7의 수정 버전. // #8// 각 비동기 메서드에는 고유 한 컨텍스트가 있다.private async Task HandleClickAsync(){ // Can use ConfigureAwait here. await Task.Delay(1000).ConfigureAwait(continueOnCapturedContext: false);}private async void button1_Click(object sender, EventArgs e){ button1.Enabled = false; try { // Can&#39;t use ConfigureAwait here. await HandleClickAsync(); } finally { // We are back on the original context for this method. button1.Enabled = true; }} 컨텍스트 프리 코드는 더 재사용이 가능하다.컨텍스트에 민감한 코드와 컨텍스트에 구애받지 않는 코드 사이에장벽을 만들고 컨텍스트에 민감한 코드를 최소화하도록 한다.그림 8에서는 상황에 맞는 이벤트 핸들러에 최소한의 코드만 남겨두고테스트 가능하고 컨텍스트가 없는 비동기 태스크 메서드에이벤트 핸들러의 모든 핵심 로직을 배치하는 것이 좋다.ASP.NET 응용 프로그램을 작성하는 경우에도데스크톱 응용 프로그램과 잠재적으로 공유되는 핵심 라이브러리가있는 경우라이브러리 코드에서 ConfigureAwait를 사용하는 것이 좋습니다. 요약하면가능한 경우 ConfigureAwait를 사용해야한다.컨텍스트 프리 코드는GUI 애플리케이션의 성능이 더 우수하며부분 비동기 코드베이스로 작업 할 때교착 상태를 피하는 데 유용한 기술이다.이 가이드 라인의 예외는 컨텍스트가 필요한 메서드인 경우. Know Your Tools 복잡하다. #9는 일반적인 문제에 대한 솔루션의 빠른 참조. 문제 해결책 코드를 실행하는 작업 만들기 Task.Run 또는 TaskFactory.StartNew (작업의 생성자 또는 Task.Start 아님.) 작업 또는 이벤트에 대한 작업 래퍼 만들기 TaskFactory.FromAsync 또는 TaskCompletionSource 지원 취소 CancellationTokenSource 및 CancellationToken 진행 상황보고 IProgress 및 Progress 데이터 스트림 처리 TPL 데이터 흐름 또는 Reactive Extensions 공유 리소스에 대한 액세스 동기화 SemaphoreSlim 리소스를 비동기 적으로 초기화 AsyncLazy 비동기식 생산자 / 소비자 구조 TPL 데이터 흐름 또는 AsyncCollection 첫 번째 문제는 작업 생성이다.분명히 비동기 메서드는 작업을 생성 할 수 있으며이것이 가장 쉬운 옵션입니다.스레드 풀에서 코드를 실행해야하는 경우 Task.Run을 사용합니다.기존 비동기 작업 또는 이벤트에 대한 작업 래퍼를 만들려면TaskCompletionSource&amp;lt;T&amp;gt;를 사용힌다. 다음으로 일반적인 문제는 취소 및 진행보고를 처리하는 방법으로 BCL (기본 클래스 라이브러리)에는 CancellationTokenSource / CancellationToken 및IProgress&amp;lt;T&amp;gt; / Progress&amp;lt;T&amp;gt;와 같은 문제를 해결하기 위해특별히 고안된 형식이 포함되어 있다.비동기 코드는 작업 생성, 취소 및 진행보고를 자세히 설명하는작업 기반 비동기 패턴 또는 TAP ( msdn.microsoft.com/library/hh873175 )를 사용해야한다. 또 다른 문제는 비동기 데이터 스트림을 처리하는 방법이다.Task는 훌륭하지만 하나의 개체 만 반환하고 한 번만 완료 할 수 있다.비동기 스트림의 경우 TPL Dataflow 또는 Reactive Extensions(Rx)를 사용할 수 있다.TPL Dataflow는 행위자 같은 느낌을주는 ‘메시’를 만든다.Rx는 더 강력하고 효율적이지만 학습 곡선이 더 어렵다.TPL Dataflow와 Rx에는 모두 비동기식 메서드가 있으며 비동기 코드에서 잘 작동힌다. 코드가 비동기 적이라고해서 안전하다는 의미는 아니다.공유 리소스는 여전히 보호해야하며잠금 내부에서 기다릴 수 없다는 사실로 인해 복잡하다.다음은 항상 동일한 스레드에서 실행 되더라도공유 상태가 두 번 실행되면 공유 상태를 손상시킬 수있는 비동기 코드의 예. int value;Task&amp;lt;int&amp;gt; GetNextValueAsync(int current);async Task UpdateValueAsync(){ value = await GetNextValueAsync(value);} 문제는 메서드가 값을 읽고 대기시 자체를 일시 중단하고메서드가 다시 시작될 때 값이 변경되지 않은 것으로 가정한다는 것이다.이 문제를 해결하기 위해 SemaphoreSlim 클래스는async-ready WaitAsync 오버로드로 확장되었다.#10 은 SemaphoreSlim.WaitAsync를 보여준다. // #10 // 그림 10 SemaphoreSlim은 비동기 동기화를 허용합니다. SemaphoreSlim mutex = new SemaphoreSlim(1); int value; Task&amp;lt;int&amp;gt; GetNextValueAsync(int current); async Task UpdateValueAsync() { await mutex.WaitAsync().ConfigureAwait(false); try { value = await GetNextValueAsync(value); } finally { mutex.Release(); } } 비동기 코드는 종종 캐시되고 공유되는 리소스를 초기화하는 데 사용됩니다.이에 대한 기본 제공 유형은 없지만Stephen Toub는 Task&amp;lt;T&amp;gt; 및 Lazy&amp;lt;T&amp;gt;의 병합처럼 작동하는AsyncLazy&amp;lt;T&amp;gt;를 개발했습니다.원래 유형은 그의 블로그에 설명되어 있으며234업데이트 된 버전은 내 AsyncEx 라이브러리5에서 사용할 수 있다. 마지막으로, 때때로 비동기 준비 데이터 구조가 필요합니다.TPL Dataflow는 비동기식 생산자 / 소비자 대기열처럼 작동하는 BufferBlock&amp;lt;T&amp;gt;를 제공합니다.또는 AsyncEx는 BlockingCollection 의 비동기 버전 인 AsyncCollection\\를 제공합니다.참고 Async/Await - Best Practices in Asynchronous Programming &amp;#8617; stephen cleary &amp;#8617; AsyncLazy &amp;#8617; AsyncLazy&amp;lt;T&amp;gt; Class &amp;#8617; StephenCleary/AsyncEx &amp;#8617; " }, { "title": "Enable Google Page Views", "url": "/posts/enable-google-pv/", "categories": "Blogging, Tutorial", "tags": "google analytics, pageviews", "date": "2021-01-04 08:32:00 +0900", "snippet": "This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well. Head to https://analytics.google.com/ and click on Start Measuring Enter your desired Account Name and choose the desired checkboxes Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard Enter the required information About your business Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps: Go to Admin on the left column Select the desired property from the drop-down on the second column Click on Data Streams Add a stream and click on Web Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml filegoogle_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine Visit https://console.cloud.google.com/appengine Click on Create Application Click on Create Project Enter the name and choose the data center close to you Select Python language and Standard environment Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient. Go to your App Engine dashboard on your browser and select API &amp;amp; Services from the left navigation menu Click on Enable APIs and Services button on the top Enable the following APIs: Google Analytics API On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&amp;lt;project-id&amp;gt;.&amp;lt;region&amp;gt;.r.appspot.com/admin/auth Note down the Your Client ID and Your Client Secret. You’ll need this in the next section. Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart Run the following commands: [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=XYZ.apps.googleusercontent.com&amp;amp;redirect_uri=ABCDEFGEnter verification code: &amp;lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&amp;gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here Setup Google Analytics superProxy Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local. Remove the first 2 lines in the src/app.yaml file: - application: your-project-id- version: 1 In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard. Enter any random key for XSRF_KEY, your config.py should look similar to this #!/usr/bin/python2.7__author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39;# OAuth 2.0 Client SettingsAUTH_CONFIG = { &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;, &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;, &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % ( &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;, &#39;/admin/auth&#39; )}# XSRF SettingsXSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39; Tip: You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com. But, for the sake of keeping it simple, we will be using the Google provided default URL. From inside the src/ directory, deploy the app [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml]source: [/tmp/google-analytics-super-proxy/src]target project: [chirpy-test-XXXX]target service: [default]target version: [VESRION_NUM]target url: [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse Visit the deployed service. Add a /admin to the end of the URL. Click on Authorize Users and make sure to add yourself as a managed user. If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix. If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows: start-date: fill in the first day of blog posting end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date) metrics: select ga:pageviews dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1: filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=. Among them, ; means using logical AND to concatenate two rules. If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl. After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID pv: proxy_endpoint: &#39;https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&amp;lt;ID FROM SUPER PROXY&amp;gt;&#39; cache_path: # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference Google Analytics Core Reporting API: Filters &amp;#8617; " }, { "title": "10. async/await_2", "url": "/posts/CS_10_Async&Await_2/", "categories": "Grind, C#", "tags": "c#, asynchronous", "date": "2020-12-24 18:00:00 +0900", "snippet": "Asynchronousintro 다시 asynchronous programming를 async, await와 섞어서함. 따라서 본 내용은 이 전 async &amp;amp; await 1 의 내용과위의 async, await 와 중복되는 내용이 많은데,이부분은 아래 링크에도 있듯이 서로 연결되어있거나 순환적임. 무튼, 계속 비슷한 내용들을 조금씩 다르게 설명하고있어서정리는 아래 링크 기준 처음 4개를 기본으로 하고다른 곳에 괜찮은 정리가 있으면 그걸 쓰는 방향으로. 확장식으로 설명을 하려고 하는데겹치는부분이 많고 비슷한건 줄이고싶은데…responsiveness / easy to write 일반적으로 모든 UI는 Main thread에서 처리하기 때문에Async는 UI thread에 액세스할 때어떤 작업 결과를 UI에 반영할 때 특히 유용.대충 의미만..암튼 기본적으로 시간이 좀 오래 걸릴만한 작업에 유용해보임.다만, 이 작업이 연속적으로 지속될 경우는Thread로 빼는게 일반적이었고. 동기식 애플리케이션에서프로세스가 block되면 모두 block됨.다시 말해 그냥 멈춘듯해 보임 비동기에서는 애플리케이션의 응답이 없을 때프로세스가 실패했다고 결론을 내릴 수 있음.이때 멈춘 또는 시간이 오래 걸리는 프로세스와 별개로UI thread는 반응하기때문에해당 프로세스를 멈추거나 하는다른 UI작업이 가능해짐. async 및 await 키워드가 핵심.이 두 키워드를 사용하면.NET Framework, .NET Core 또는 Windows 런타임의리소스를 사용하여 쉽게 비동기 메서드를 만들 수 있다.async키워드를 사용하는 메서드를 비동기 메서드 라고 함. .NET Framework 4.5 이상 및 .NET Core에는 async 및 await에 작동하는많은 멤버가 포함되어 있는데 멤버 이름에 붙는 “Async” 접미사와Task 또는 Task&amp;lt;TResult&amp;gt;의 반환 형식인것들.예를 들어, System.IO.Stream 클래스는동기 메서드인 CopyTo, Read등과 함께비동기 메서드인 CopyToAsync, ReadAsync등과 같은 메서드를 포함. async / await를 사용할라면또는 관련 api를 사용하려면위 버전 이상을 써야하는것같음. Windows 런타임에는Windows 앱에서 async 및 await와 함께 사용할 수 있는많은 메서드도 포함되어 있다고 함.What happens in an async methodexample 위 예제 순서 호출하는 메서드는 GetUrlContentLengthAsync 비동기 메서드를 호출 후 대기. GetUrlContentLengthAsync는 HttpClient 인스턴스를 만들고GetStringAsync 비동기 메서드를 호출하여웹 사이트의 내용을 문자열로 다운로드. GetStringAsync에서 특정 작업이 발생하여 진행이 일시 중단.웹 사이트에서 다운로드 또는다른 차단 작업을 수행할 때까지 기다려야 할 수 있음.리소스를 차단하지 않기 위해 GetStringAsync는해당 호출자인 GetUrlContentLengthAsync에 제어 권한을 양도. GetStringAsync는 TResult가 문자열인 Task&amp;lt;TResult&amp;gt;를 반환하고, GetUrlContentLengthAsync는 getStringTask 변수에 작업을 할당. 이 작업은 작업이 완료될 때 실제 문자열 값을 생성하기 위한 코드와 함께 GetStringAsync를 호출하는 지속적인 프로세스를 나타냄. 작업은 작업이 완료 될 때 실제 문자열 값을 생성하겠다는 약속과 함께 GetStringAsync 호출에 대한 진행중인 프로세스를 나타냄. getStringTask가 아직 대기되지 않았으므로즉, 아직 await가 쓰이지 않았으므로GetUrlContentLengthAsync가GetStringAsync의 최종 결과에 무관한 다른 작업 가능.이 경우는 DoIndependentWork()이 수행되는것. DoIndependentWork는 작업을 수행하고호출자에게 반환하는 동기 메서드. GetUrlContentLengthAsync에는 더이상getStringTask의 결과 없이 수행할 수 있는 작업이 없음.다음으로 GetUrlContentLengthAsync는다운로드한 문자열의 길이를 계산하여 반환하려 하지만,메서드가 문자열을 확인할 때까지 해당 값을 계산할 수 없음. 따라서 GetUrlContentLengthAsync는 await 연산자를 사용해서 해당 프로세스를 일시 중단하고 GetUrlContentLengthAsync를 호출한 메서드에 제어 권한 양도. GetUrlContentLengthAsync는 Task&amp;lt;int&amp;gt;를 호출자에게 반환. 작업은 다운로드한 문자열의 길이인 정수 결과를 만든다는 약속을 나타냄. 참고 GetUrlContentLengthAsync가 await하기 전에 GetStringAsync(및 getStringTask)가 완료되면 GetUrlContentLengthAsync에서 컨트롤을 유지함. 호출된 비동기 프로세스 getStringTask가 이미 완료되었고 GetUrlContentLengthAsync가 최종 결과를 기다릴 필요가 없는 경우 일시 중단한 다음 GetUrlContentLengthAsync로 돌아가는 비용이 낭비됨. 호출하는 메서드(시작점의 calling method) 내에서 처리 패턴이 계속된다. 호출자가 해당 결과를 기다리거나 즉시 기다리기 전에 GetUrlContentLengthAsync에서 결과에 의존하지 않는 다른 작업을 수행할 수 있음. 호출하는 메서드는 GetUrlContentLengthAsync를 기다리고 있으며 GetUrlContentLengthAsync는 GetStringAsync를 기다리고 있음. GetStringAsync가 완료되고 문자열 결과를 생성.GetStringAsync를 호출할 경우문자열 결과가 예상대로 반환되지 않는다.(메서드가 이미 3단계에서 작업을 반환함. 먼저 끝난경우인듯.)대신 문자열 결과는메서드의 완료를 나타내는 작업인 getStringTask에 저장.await 연산자가 getStringTask에서 결과를 검색 하고결과를 contents에 할당. GetUrlContentLengthAsync에 문자열 결과가 있는 경우메서드가 문자열 길이를 계산.그런 다음 GetUrlContentLengthAsync 작업도 완료되고대기 이벤트 처리기를 다시 시작. 동기와 차이점은 동기 메서드는 작업이 완료될 때 반환되지만(5단계) 비동기 메서드는 작업이 일시 중단될 때 반환.(3, 6단계) 비동기 메서드가 해당 작업을 완료하면 작업이 완료된 것으로 표시되고 결과가 있을 경우 작업에 저장. 특징 메서드 서명. async 한정자. 메서드 이름은 Async로 끝남. 반환 형식. Task&amp;lt;int&amp;gt;(이 관련은 아래에서 다시). method의 본문에서 GetStringAsync가 Task&amp;lt;string&amp;gt;을 반환. 즉, task를 await하면 string을 받게 됨(contents). 그 외(flow) 작업을 대기하기 전에 GetStringAsync의 string을 사용하지 않는 작업을 수행할 수 있음. 이 경우에는 DoIndependentWork(); await에 대한 부분이 끝나면 그 뒤(이 전에 안한 부분) 이어서 실행 await 연산자 GetUrlContentLengthAsync를 일시 중단. GetUrlContentLengthAsync는 getStringTask가 완료될 때까지 계속할 수 없음. 반면 제어는 GetUrlContentLengthAsync의 호출자에 반환. getStringTask가 완료되면 컨트롤이 다시 시작하고 await 연산자가 getStringTask에서 string 결과를 검색. GetUrlContentLengthAsync에 GetStringAsync 호출과해당 완료 대기 사이에 수행할 수 있는 작업이 없는 경우다음 단일 문을 호출하고 대기하여 코드를 단순화할 수 있음. string contents = await client.GetStringAsync(&quot;https://docs.microsoft.com/dotnet&quot;); Asynchronous methodbasic. 비동기 메서드는 하나 이상의 await를 포함하는데이는 해당 Task가 완료 될 때까지 메서드가 더 이상 계속될 수 없는 지점을 나타내고여기에서 control은 호출자로 반환됨. 비동기 메서드에서는제공된 키워드와 형식을 사용하여 수행 할 작업을 나타내면컴파일러가 일시 중단 된 메서드의 대기 지점으로 제어가 반환 될 때발생해야하는 작업을 추적하는 등 나머지 작업을 수행. 루프 및 예외 처리와 같은 일부 루틴 프로세스는기존의 비동기 코드에서 처리하기 어려울 수 있음.비동기 메서드에서는 동기 솔루션에서와 같이필요한 만큼 이러한 요소를 작성하여 문제를 해결.명명 규칙 일반적으로 대기 가능한 형식을 반환하는 메서드에는“Async”로 끝나는 이름을 사용.(예: Task, Task&amp;lt;T&amp;gt;, ValueTask, ValueTask&amp;lt;T&amp;gt;) 비동기 작업을 시작하지만 대기 가능한 형식을 반환하지 않는 메서드는“Async”로 끝나는 이름을 사용하지 않아야 하지만,“Begin”, “Start” 또는 일부 다른 동사로 시작하여 이 메서드가작업 결과를 반환하거나 예외가 발생하지 않음을 알려야 함. 여기서 이벤트, 기본 클래스 또는 인터페이스 계약으로다른 이름을 제안하는 규칙을 무시할 수 있음.예를 들어, OnButtonClick과 같은공용 이벤트 처리기의 이름을 변경할 수 없음.Thread 비동기 메서드는 비차단 작업이 목적임.비동기 메서드의 await 식은대기한 작업이 실행되는 동안 현재 스레드를 차단하지 않고메서드의 나머지를 연속으로 등록하고제어 기능을 비동기 메서드 호출자에게 반환. async 및 await 키워드로 인해 추가 스레드가 생성되지 않음.비동기 메서드는 자체 스레드에서 실행되지 않으므로다중 스레드가 필요없음.메서드는 현재 동기화 컨텍스트에서 실행되고메서드가 활성화된 경우에만 스레드에서 시간을 사용.Task.Run을 사용하여 CPU 바인딩 작업을백그라운드 스레드로 이동할 수 있지만백그라운드 스레드는 결과를 사용할 수 있을 때까지기다리는 프로세스를 도와주지 않음. 비동기 프로그래밍에 대한 비동기 기반 접근 방법은거의 모든 경우에 기존 방법보다 선호됨.특히, 이 접근 방식은 코드가 더 간단하고경합 조건을 방지할 필요가 없기 때문에I/O 바인딩 작업의 BackgroundWorker 클래스보다 효과적.비동기 프로그래밍은 코드 실행에 대한 조합 세부 정보를Task.Run이 스레드 풀로 변환하는 작업과 구분하기 때문에Task.Run 메서드를 함께 사용하는 비동기 프로그래밍은CPU 바인딩 작업을 위한 BackgroundWorker보다 효과가 뛰어남.Return types and parameters Task&amp;lt;TResult&amp;gt; 또는 Task를 반환하는 메서드를 선언하고 호출하는 방법. async Task&amp;lt;int&amp;gt; GetTaskOfTResultAsync() { int hours = 0; await Task.Delay(0); return hours; } Task&amp;lt;int&amp;gt; returnedTaskTResult = GetTaskOfTResultAsync(); int intResult = await returnedTaskTResult; // Single line // int intResult = await GetTaskOfTResultAsync(); async Task GetTaskAsync() { await Task.Delay(0); // No return statement needed } Task returnedTask = GetTaskAsync(); await returnedTask; // Single line await GetTaskAsync(); 비동기 메서드는 일반적으로 Task 또는 Task&amp;lt;TResult&amp;gt;를 반환. 비동기 메서드 내에서 await 연산자는다른 비동기 메서드 호출에서 반환 된 작업에 적용. 반환 형식. Task&amp;lt;TResult&amp;gt; : 메서드에 연산자 형식이 TResult인 Return 문이 있는 경우. Task : 메서드에 반환 문이 포함되지 않았거나 피연산자가 없는 반환 문이 포함된 경우. void : 비동기 이벤트 처리기를 작성하는 경우. GetAwaiter 메서드가 포함된 모든 기타 형식. C# 7.0부터는 형식에 GetAwaiter 메서드가 포함된 경우 다른 반환 형식을 지정 가능. 예를들어 ValueTask&amp;lt;TResult&amp;gt;이고 System.Threading.Tasks.Extension NuGet 패키지에서 사용할 수 있음. 반환된 각 작업은 진행 중인 작업을 나타냄.작업은 비동기 프로세스 상태에 대한 정보를 캡슐화하며,결과적으로 프로세스의 최종 결과 또는 성공하지 못한 경우프로세스가 발생시키는 예외에 대한 정보를 캡슐화. 비동기 메서드의 반환 형식은 void일 수 있습니다.이 반환 형식(void)은 기본적으로 이벤트 처리기를 정의.비동기 이벤트 처리기는 비동기 프로그램의 시작점 역할을 함. void 반환 형식을 가진 비동기 메서드는 대기 불가.또한 void를 반환하는 메서드의 호출자는메서드가 throw 하는 예외 catch 못 함. 비동기 메서드는 모든 in, ref 또는 out 매개 변수를 선언할 수 없지만,이러한 매개 변수가 있는 메서드를 호출할 수는 있음. 참조 반환 값이 있는 메서드를 호출할 수 있지만참조를 통해 값을 반환할 수 없다. 자세한 내용과 예제는 비동기 반환 형식(C#)을 참조.1 비동기 메서드에서 예외를 처리하는 방법은 try-catch를 참조.2 Windows 런타임 프로그래밍의 비동기 API에는Task와 유사한 다음 반환 형식에 해당함. Task&amp;lt;TResult&amp;gt;에 해당하는 IAsyncOperation&amp;lt;TResult&amp;gt; Task에 해당하는 IAsyncAction IAsyncActionWithProgress&amp;lt;TProgress&amp;gt; IAsyncOperationWithProgress&amp;lt;TResult,TProgress&amp;gt; 관련 항목 및 샘플(Visual Studio) async 및 await를 사용하여병렬로 여러 웹 요청을 만드는 방법(C#) 3 동시에 여러 작업을 시작하는 방법. 비동기 샘플: 병렬로 여러 웹 요청 만들기 비동기 반환 형식(C#) 4 비동기 메서드에서 반환할 수 있는 형식을 설명하고각 형식이 언제 적절한가를 설명. 신호 메커니즘으로 취소 토큰이 있는 작업 취소. 비동기 솔루션에 다음과 같은 기능을 추가하는 방법. 작업 목록 취소(C#) 5 일정 기간 이후 작업 취소(C#) 6 완료되면 비동기 작업 처리(C#) 7 파일 액세스에 async 사용(C#) 8 async 및 await를 사용하여 파일에 액세스하는 이점을 나열하고 보여줌. TAP(작업 기반 비동기 패턴) 9 비동기 패턴에 대해 설명하고 패턴은 Task 및 Task&amp;lt;TResult&amp;gt; 형식 기반. 비동기 Channel 9 비디오 10 비동기 프로그래밍에 대한 다양한 비디오로 연결되는 링크를 제공. 이었는데 링크 없어져서 다른거로 대체함. async 및 await async 한정자를 사용해서 비동기 메서드로 지정하면다음 두 기능 활성화. 표시된 비동기 메서드는await를 사용하여 일시 중단 지점을 지정.await 연산자는대기된 비동기 프로세스가 완료될 때까지비동기 메서드가 해당 지점을 지나계속할 수 없도록 컴파일러에 지시.한편, 컨트롤이 비동기 메서드의 호출자로 반환.await 식에서 비동기 메서드를 일시 중단하더라도메서드가 종료되지는 않으며 finally 블록이 실행되지 않음. 표시된 비동기 메서드는이 메서드를 호출한 다른 메서드에 의해 대기할 수 있음. 비동기 메서드는 일반적으로 await 연산자를 하나 이상 가지고 있지만,await 식이 없는 경우컴파일러 오류가 발생하지는 않지만 경고는 해줌. await 연산자를 사용하여일시 중단 시점을 표시하지 않는 경우메서드가 async 한정자에 상관없이동기 메서드가 실행되는 방식으로 실행. Async async method라고 알려주는 정도. method, lambda expression, anonymous method에 사용 가능 async 키워드에서 수정하는 메서드에await 식 또는 문이 없는 경우해당 메서드는 동기적으로 실행.await 문이 포함되지 않은 모든 비동기 메서드에서는오류가 발생할 수 있으므로 컴파일러 경고 발생. 비동기 메서드는첫 번째 await 식에 도달할 때까지 동기적으로 실행되며이 시점에서 awawit 된 task가완료 될 때까지 메서드가 일시 중단.그 동안 제어는 메서드 호출자에게 반환. async 키워드는메서드, 람다 식, 무명 메서드를 수정할 때만 키워드로 사용.다른 모든 컨텍스트에서는 식별자로 해석. return 형식 Task,Task&amp;lt;TResult&amp;gt; 번환 형식이 없고 / 있고 차이. 메소드를 호출하면 작업이 반환되지만,작업이 완료되면작업을 기다리는 모든 대기 표현은 무효로 평가된다.이건잘… void 호출자가 해당 메서드를 기다릴 수없고성공적인 완료 또는 오류 조건을 보고하기 위해다른 메커니즘을 구현해야하므로이벤트 처리기 이외의 코드에는 일반적으로비동기 method는 void return을 사용하지 않는 것이 좋다. void return type은 주로이벤트 핸들러를 정의하기 위해 사용하며,여기에는 해당 반환 유형이 필요하다.void 반환 비동기 방법을 호출한 사람은 기다릴 수 없으며비동기 방법이 throw하는 exception을 catch할 수 없다. C#7.0부터는 GetAwaiter(System.Threading.Tasks.ValueTask&amp;lt;TResult&amp;gt;) System.Threading.Tasks.ValueTask&amp;lt;TResult&amp;gt; 형식.NuGet 패키지 System.Threading.Tasks.Extensions를 추가하면 사용가능. C# 7.0부터 GetAwaiter 메서드가 있는다른 형식(일반적으로 값 형식)을반환하여 성능이 중요한 코드 섹션에서 메모리 할당 최소화. in, ref, out을 parameter, return으로 사용 못함.단, 이런 parameter가 있는 method는 호출 가능 Await await 연산자는피연산자가 나타내는 비동기 작업이 완료 될 때까지둘러싸는 비동기 메서드의 평가를 일시 중단. 비동기 작업이 완료되면await 연산자가 작업 결과 반환(있는 경우). 이미 완료된 작업을 나타내는 피연산자에await 연산자를 적용하면둘러싸는 메서드를 중단하지 않고 즉시 작업 결과 반환. await 연산자는비동기 메서드를 평가하는 스레드를 차단하지 않음. await 연산자가 바깥 쪽 비동기 메서드를 일시 중단하면컨트롤이 메서드 호출자에게 반환. ex using System;using System.Net.Http;using System.Threading.Tasks;public class AwaitOperator{ public static async Task Main() { Task&amp;lt;int&amp;gt; downloading = DownloadDocsMainPageAsync(); Console.WriteLine($&quot;{nameof(Main)}: Launched downloading.&quot;); int bytesLoaded = await downloading; Console.WriteLine($&quot;{nameof(Main)}: Downloaded {bytesLoaded} bytes.&quot;); } private static async Task&amp;lt;int&amp;gt; DownloadDocsMainPageAsync() { Console.WriteLine($&quot;{nameof(DownloadDocsMainPageAsync)}: About to start downloading.&quot;); var client = new HttpClient(); byte[] content = await client.GetByteArrayAsync(&quot;https://docs.microsoft.com/en-us/&quot;); Console.WriteLine($&quot;{nameof(DownloadDocsMainPageAsync)}: Finished downloading.&quot;); return content.Length; }}// Output similar to:// DownloadDocsMainPageAsync: About to start downloading.// Main: Launched downloading.// DownloadDocsMainPageAsync: Finished downloading.// Main: Downloaded 27700 bytes. HttpClient.GetByteArrayAsync 메서드는완료시 바이트 배열을 생성하는비동기 작업을 나타내는 Task&amp;lt;byte []&amp;gt; 인스턴스를 반환. 작업이 완료 될 때까지 await 연산자는DownloadDocsMainPageAsync 메서드를 일시 중단. DownloadDocsMainPageAsync가 일시 중단되면제어가 DownloadDocsMainPageAsync의 호출자인Main 메서드로 반환. Main 메서드는DownloadDocsMainPageAsync 메서드에서 수행한비동기 작업의 결과가 필요할 때까지 실행. GetByteArrayAsync가 모든 바이트를 가져 오면나머지 DownloadDocsMainPageAsync 메서드가 평가됨. 그 후 나머지 Main 메서드가 평가됨. await 연산자는 async 키워드로 수정된메서드, 람다 식, 익명 메서드에서만 사용. 비동기 메서드 내에서동기 함수 본문, Lock statement의 블록 내부,unsafe 컨텍스트에서 await 연산자를 사용할 수 없음. await의 피연산자는 일반적으로Task, Task&amp;lt;TResult&amp;gt;, ValueTask, ValueTask&amp;lt;TResult&amp;gt; 인데대기 가능한 모든 식은 가능하다함. t 식의 형식이 Task&amp;lt;TResult&amp;gt; 또는 ValueTask&amp;lt;TResult&amp;gt;이면 await t 식의 형식은 TResult. Task 또는 ValueTask이면 await t 형식은 void. 두 경우 모두t가 예외를 throw하면await t는 예외를 다시 throw. Main 메서드의 await 연산자 C# 7.1부터 애플리케이션 진입점인 Main 메서드는 Task 또는 Task&amp;lt;int&amp;gt;를 반환하여 해당 본문에서 await 연산자를 사용. 이전 C# 버전에서는 Main 메서드가 비동기 작업이 완료될 때까지 대기하는지 확인하기 위해 해당 비동기 메서드에서 반환되는 Task&amp;lt;TResult&amp;gt; 인스턴스의 Task&amp;lt;TResult&amp;gt;.Result 속성 값을 검색할 수 있음. 값을 생성하지 않는 비동기 작업의 경우 Task.Wait 메서드를 호출할 수 있음. Asynchronous programmingOverview 주로 I/O바인딩 또는 CPU바인딩때사용하는것을 권장하고 있는데실제 바인딩 영역은 몇가지 더 있는듯하나11시간이 오래 걸릴가능성이 있는건 이 둘인듯. 아무튼 대부분의 경우 I/O 바인딩된 코드에서는async 메서드의 내부에서Task 또는 Task&amp;lt;T&amp;gt;를 반환하는 작업을, CPU 바인딩된 코드에서는Task.Run 메서드로백그라운드 스레드에서 시작되는 작업을 기다린다. 수행하는 작업이어떤 바인딩인지 인식하는것이 중요하다고 하는데코드의 성능에 큰 영향을 미치고잠재적으로 특정 구문을 잘못 사용하게 될 수 있기 때문. 구별짓기 위해 고려해야하는 사항으로는 코드가 데이터베이스의 데이터와 같은무엇인가를 “기다리게” 되나? 맞으면 I/O 바인딩된 작업. 코드가 비용이 높은 계산을 수행하게 되나? 맞으면 CPU 바인딩된 작업. 위 사항에 따라 I/O 바인딩된 작업이 있을 경우Task.Run 없이 async 및 await를 사용.작업 병렬 라이브러리를 사용하면 안 됨.그 이유는 세부 비동기에 설명.(이건 나중에) CPU 바인딩된 작업이 있고 빠른 응답이 필요할 경우async 및 await를 사용하지만Task.Run을 사용하여 또 다른 스레드에서 작업을 생성. 작업이 동시성 및 병렬 처리에 해당할 경우작업 병렬 라이브러리를 사용할 것을 고려할 수도 있음. 또한 항상 코드 실행을 측정해야 함.예를 들어 CPU 바인딩된 작업이 다중 스레딩시컨텍스트 전환의 오버헤드에 비해부담이 크지 않은 상황이 될 수 있음.모든 선택에는 절충점이 있으니상황에 맞는 올바른 절충점을 선택. 무튼 이 부분에서 중요한 점은 비동기 코드는 I/O 또는 CPU 바인딩된 코드에 둘 다 사용할 수 있지만 시나리오마다 다르게 사용. 비동기 코드는 백그라운드에서 수행되는 작업을 모델링하는데 사용되는 구문인 Task&amp;lt;T&amp;gt; 및 Task를 사용. async 키워드는 본문에서 await 키워드를 사용할 수 있는 비동기 메서드로 메서드를 변환. await 키워드가 적용되면 이 키워드는 호출 메서드를 일시 중단하고 대기 작업이 완료할 때까지 제어 권한을 다시 호출자에게 양도. await는 비동기 메서드 내부에서만 사용. 백그라운드 수행 비동기 작업과 관련하여 많은 작업을 수행함. Task 및 Task&amp;lt;T&amp;gt;의 백그라운드에서 수행되는 작업이 궁금하면 세부 비동기 문서에서 자세한 내용을 확인. C#에서는 컴파일러가 해당 코드를, await에 도달할 때 실행을 양도하고 백그라운드 작업이 완료될 때 실행을 다시 시작하는 것과 같은 작업을 추적하는 상태 시스템으로 변환합니다. 이론적으로 보면 이 변환은 비동기 약속 모델.12 상황에 따른 예 I/O 바인딩 예제: 웹 서비스에서 데이터 다운로드 private readonly HttpClient _httpClient = new HttpClient();downloadButton.Clicked += async (o, e) =&amp;gt;{ // This line will yield control to the UI as the request // from the web service is happening. // // The UI thread is now free to perform other work. var stringData = await _httpClient.GetStringAsync(URL); DoSomethingWithData(stringData);}; 단추가 눌릴 때 웹 서비스에서일부 데이터를 다운로드해야 할 수 있지만UI 스레드를 차단하지 않음. CPU 바인딩 예제: 게임에 대한 계산 수행 private DamageResult CalculateDamageDone(){ // Code omitted: // // Does an expensive calculation and returns // the result of that calculation.}calculateButton.Clicked += async (o, e) =&amp;gt;{ // This line will yield control to the UI while CalculateDamageDone() // performs its work. The UI thread is free to perform other work. var damageResult = await Task.Run(() =&amp;gt; CalculateDamageDone()); DisplayDamage(damageResult);}; 단추를 누르면 화면의 많은 적에게손상을 입힐 수 있는 모바일 게임을 작성할 때손상 계산을 수행하는 것은 부담이 클 수 있고UI 스레드에서 이 작업을 수행하면계산이 수행될 때 게임이 일시 중지되는 것처럼 보임. 이 작업을 처리하는 가장 좋은 방법은 Task.Run을 사용하여작업을 수행하는 백그라운드 스레드를 시작하고await를 사용하여 결과를 기다리는 것.이렇게 하면 작업이 수행되는 동안 UI가 매끄럽게 느껴질 수 있움. 이 코드는 단추 클릭 이벤트의 의도를 표현하고,백그라운드 스레드를 수동으로 관리할 필요가 없고,비차단 방식으로 작업을 수행. 네트워크에서 데이터 추출 private readonly HttpClient _httpClient = new HttpClient();[HttpGet, Route(&quot;DotNetCount&quot;)]public async Task&amp;lt;int&amp;gt; GetDotNetCount(){ // Suspends GetDotNetCount() to allow the caller (the web server) // to accept another request, rather than blocking on this one. var html = await _httpClient.GetStringAsync(&quot;https://dotnetfoundation.org&quot;); return Regex.Matches(html, @&quot;\\.NET&quot;).Count;} https://dotnetfoundation.org에서 HTML을 다운로드하고문자열 “.NET”이 HTML에서 발생하는 횟수를 계산.이 작업을 수행하고 횟수를 반환하는Web API 컨트롤러 메서드를 정의하기 위해ASP.NET을 사용. private readonly HttpClient _httpClient = new HttpClient();private async void OnSeeTheDotNetsButtonClick(object sender, RoutedEventArgs e){ // Capture the task handle here so we can await the background task later. var getDotNetFoundationHtmlTask = _httpClient.GetStringAsync(&quot;https://dotnetfoundation.org&quot;); // Any other work on the UI thread can be done here, such as enabling a Progress Bar. // This is important to do here, before the &quot;await&quot; call, so that the user // sees the progress bar before execution of this method is yielded. NetworkProgressBar.IsEnabled = true; NetworkProgressBar.Visibility = Visibility.Visible; // The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller. // This is what allows the app to be responsive and not block the UI thread. var html = await getDotNetFoundationHtmlTask; int count = Regex.Matches(html, @&quot;\\.NET&quot;).Count; DotNetCountLabel.Text = $&quot;Number of .NETs on dotnetfoundation.org: {count}&quot;; NetworkProgressBar.IsEnabled = false; NetworkProgressBar.Visibility = Visibility.Collapsed;} 버튼이 눌릴 때 같은 작업을 수행하는유니버설 Windows 앱용으로 작성된 동일한 시나리오. 여러 작업이 완료될 때까지 대기 동시에 데이터의 여러 부분을 검색해야 하는 상황이 될 수 있음. Task API에는 여러 백그라운드 작업에서 비차단 대기를 수행하는 비동기 코드를 작성할 수 있는 Task.WhenAll 및 Task.WhenAny 메서드가 포함됨. public async Task&amp;lt;User&amp;gt; GetUserAsync(int userId){ // Code omitted: // // Given a user Id {userId}, retrieves a User object corresponding // to the entry in the database with {userId} as its Id.}public static async Task&amp;lt;IEnumerable&amp;lt;User&amp;gt;&amp;gt; GetUsersAsync(IEnumerable&amp;lt;int&amp;gt; userIds){ var getUserTasks = new List&amp;lt;Task&amp;lt;User&amp;gt;&amp;gt;(); foreach (int userId in userIds) { getUserTasks.Add(GetUserAsync(userId)); } return await Task.WhenAll(getUserTasks);} userId 집합에 대한 User 데이터를 확인하는 방법. public async Task&amp;lt;User&amp;gt; GetUserAsync(int userId){ // Code omitted: // // Given a user Id {userId}, retrieves a User object corresponding // to the entry in the database with {userId} as its Id.}public static async Task&amp;lt;User[]&amp;gt; GetUsersAsync(IEnumerable&amp;lt;int&amp;gt; userIds){ var getUserTasks = userIds.Select(id =&amp;gt; GetUserAsync(id)); return await Task.WhenAll(getUserTasks);} LINQ를 사용하여 보다 간결하게 작성하는 또 다른 방법. 코드 양은 더 적지만LINQ를 비동기 코드와 함께 사용할 때는 주의가 필요함. LINQ는 연기된(지연) 실행을 사용하므로,.ToList() 또는 .ToArray() 호출을반복하도록 생성된 시퀀스를 적용해야비동기 호출이 foreach 루프에서 수행되면즉시 비동기 호출이 발생. caution 비동기 프로그래밍을 사용하는 경우예기치 않은 동작을 방지할 수 있는 몇 가지 사항을 고려해아함. async 메서드에는 본문에 await 키워드가 있어야 함. 키워드가 없으면 일시 중단되지 않음.await가 async 메서드의 본문에 없으면C# 컴파일러가 경고를 생성하지만코드는 동기 메서드인 것처럼 컴파일 및 실행됨.이는 C# 컴파일러가 비동기 메서드에 대해 생성한 상태 시스템이아무것도 수행하지 않기 때문에 매우 비효율. 작성하는 모든 비동기 메서드 이름의 접미사로 “Async”를 추가. 이 규칙을 .NET에서 사용하여 동기 및 비동기 메서드를 더 쉽게 구별. 코드에서 명시적으로 호출되지 않은 특정 메서드가 반드시 적용되는 것은 아님. (예: 이벤트 처리기 또는 웹 컨트롤러 메서드) 이러한 메서드는 코드에서 명시적으로 호출되지 않으므로 명시적으로 명명하는 것은 별로 중요하지 않음. async void는 이벤트 처리기에만 사용. 이벤트에는 반환 형식이 없어서 Task 및 Task&amp;lt;T&amp;gt;를 사용할 수 없으므로 비동기 이벤트는 async void 가능. async void의 다른 사용은 TAP 모델을 따르지 않고 다음과 같이 사용이 어려울 수 있음. async void 메서드에서 throw된 예외는해당 메서드 외부에서 catch될 수 없음. async void 메서드는 테스트하기가 어려움. 호출자가 async void 메서드를비동기로 예상하지 않을 경우이러한 메서드는 의도하지 않은 잘못된 결과를 일으킬 수 있음. LINQ 식에서 비동기 람다를 사용할 경우 신중하게 스레드 LINQ의 람다 식은 연기된 실행을 사용. 즉, 예상치 않은 시점에 코드 실행이 끝날 수 있다. 이 코드에 차단 작업을 도입하면 코드가 제대로 작성되지 않은 경우 교착 상태가 쉽게 발생. 또한 이 코드처럼 비동기 코드를 중첩하면 코드 실행에 대해 추론하기가 어려워짐. 비차단 방식으로 작업을 기다리는 코드 작성 Task가 완료될 때까지 대기하는 수단으로 현재 스레드를 차단하면 교착 상태가 발생하거나 컨텍스트 스레드가 차단되는 등 더 복잡한 오류 처리가 필요할 수 있음. 비차단 방식으로 작업 대기를 처리하는 방법에 대한 지침. 사용 방법 대체 방법 수행할 작업 await Task.Wait 또는 Task.Result 백그라운드 작업의 결과 검색 await Task.WhenAny Task.WaitAny 작업이 완료될 때까지 대기 await Task.WhenAll Task.WaitAll 모든 작업이 완료될 때까지 대기 await Task.Delay Thread.Sleep 일정 기간 대기 가능하면 ValueTask를 사용 비동기 메서드에서 Task 개체를 반환하면 특정 경로에 성능 병목 현상이 발생할 수 있음. Task는 참조 형식이므로 이를 사용하는 것은 개체 할당을 의미. async 한정자로 선언된 메서드가 캐시된 결과를 반환하거나 동기적으로 완료된 경우 코드의 성능이 중요한 섹션에서 추가 할당에 상당한 시간이 소요될 수 있음. 연속 루프에서 이러한 할당이 발생하면 부담이 될 수 있음. 자세한 내용은 일반화된 비동기 반환 형식을 참조. ConfigureAwait(false)를 사용 일반적인 질문은 “언제 Task.ConfigureAwait(Boolean) 메서드를 사용해야 하는가”. 이 메서드를 사용하면 Task 인스턴스가 awaiter를 구성할 수 있음. 다만 잘못 설정할 경우 성능에 영향을 미칠 수 있고 심지어 교착 상태가 발생할 수도 있음. ConfigureAwait에 대한 자세한 내용은 ConfigureAwait FAQ를 참조. 상태 저장 코드 작성 분량 감소 전역 개체의 상태나 특정 메서드의 실행이 아닌메서드의 반환 값에만 의존.그 이유로는 코드를 더 쉽게 추론할 수 있다. 코드를 더 쉽게 테스트할 수 있다. 비동기 및 동기 코드를 훨씬 더 쉽게 혼합할 수 있다. 일반적으로 함께 경합 상태를 피할 수 있다. 반환 값에 의존하면 비동기 코드를 간단히 조정할 수 있다. (이점) 이 방법은 실제로 종속성 주입에도 잘 작동. 권장되는 목적은 코드에서 완전하거나거의 완전한 참조 투명성을 달성하는 것.이렇게 하면 확실히 예측 가능하고,테스트 가능하고, 유지 관리 가능한코드베이스가 생성.참고 작업 비동기 프로그래밍 모델 비동기 프로그래밍 async await async 및 await를 사용한 비동기 프로그래밍 C# 5.0 : async / await 키워드 What’s the difference between Task.Start/Wait and Async/Await? 작업 기반 비동기 패턴 비동기 반환 형식(C#) &amp;#8617; try-catch(C# 참조) &amp;#8617; async 및 await를 사용한 비동기 프로그래밍 &amp;#8617; 비동기 반환 형식(C#) &amp;#8617; 작업 목록 취소(C#) &amp;#8617; 일정 기간 이후 비동기 작업 취소(C#) &amp;#8617; 완료되면 비동기 작업 처리(C#) &amp;#8617; 비동기 파일 액세스(C#) &amp;#8617; 작업 기반 비동기 패턴 &amp;#8617; C# Advanced &amp;#8617; What do the terms “CPU bound” and “I/O bound” mean? &amp;#8617; Futures and promises &amp;#8617; " }, { "title": "9. Task_3", "url": "/posts/CS_9_Task_3/", "categories": "Grind, C#", "tags": "c#", "date": "2020-10-06 15:00:00 +0900", "snippet": "Task 쓰다가 궁금했던것 여기 부분은 나중에 더 알게되면 아는만큼 쓰던가 하고지금은 궁금한거 만 늘어놓고 끝내기로. main과 현재 task의 thread가 다르다는것을 보일 수 있는가? “특정 task에서 실행이 오래걸림”의 재현을THread.sleep()로 구현하는데 맞나? 정확히 Thread.sleep는 어떤 Thread에 작용하는거?? 예를들어 Task에 넘긴 Action에 연결된 method안에Thread.Sleep()가 있다고 가정했을때 어떤 Thread가 sleep하나? 또, 원래 웹을 읽어온다거나 하는등의 시간이 걸렸을 작업을Task안에 Thread.sleep로 구현하는게 맞나? Wait은 Task가 완료 될때까지Task를 실행한 thread는 block돤다고 했는데 … 그럼 왜쓰는거임? main thread / task thread task는 thread pool의 thead에서 샐행 된다 했음. class Program{ static void Main(string[] args) { Console.WriteLine(&quot;Main={0}&quot;,Thread.CurrentThread.ManagedThreadId); new test_3(); }}class test_3{ public test_3() { Console.WriteLine(&quot;test_3={0}&quot;, Thread.CurrentThread.ManagedThreadId); mtd_1(); } void mtd_1() { Action&amp;lt;object&amp;gt; action = (object obj) =&amp;gt; { Console.WriteLine(&quot;Task={0}, obj={1}, Thread={2}&quot;, Task.CurrentId, obj, Thread.CurrentThread.ManagedThreadId); }; Task t1 = new Task(action, &quot;t1&quot;); Task t2 = new Task(action, &quot;t2&quot;); Task t3 = new Task(action, &quot;t3&quot;); t1.Start(); t2.Start(); t3.Start(); t1.Wait(); t2.Wait(); t3.Wait(); }} 실행 결과는 Main=1test_3=1Task=2, obj=t2, Thread=6Task=3, obj=t3, Thread=5Task=1, obj=t1, Thread=3Main=1test_3=1Task=1, obj=t1, Thread=3Task=3, obj=t3, Thread=6Task=2, obj=t2, Thread=5Main=1test_3=1Task=1, obj=t1, Thread=3Task=2, obj=t2, Thread=4Task=3, obj=t3, Thread=5 실행 결과는 대체적으로 할 때마다 순서가 바뀜. 위 실행 결과는 같은거 여러번한거. 1,2,3 start의 순서가 중요한게 아닌것같음 Thread.CurrentThread.ManagedThreadId로확인할 때마다 id가 계속 달라진다. 그래서.. 하는건데Thread.으로 시작하는 static method들은해당 부분을 실재로 실행하고있는 thread를 지징하는것같음그래서 main, test_3은 main에서 왔으니 id = 1로 같고task로 실행하는 부분은 task각각에 다른 thread id가 생긴다. “특정 task에서 실행이 오래걸림”의 재현 위를 시작으로 조금 풀리는듯함. 일단, 위의 전제가 확실히 맞다고 하면Task에 구현된 method안에 Thread.sleep은실제 그 method를 실행하고있는 Task의 thread에 작용하겠지..그럼 맞음.wait()?? Task_2 에서 Wait(Int32)및 Wait(TimeSpan) 메서드는 작업이 완료 되거나 시간 제한 간격이 경과할 때까지 (둘 중 먼저 도달 하는 경우) 호출 스레드를 차단. 이라고 했는데 애초에 이게 이상해서 위에 의문들이 계속 생긴듯함. Wait를 만나면 task를 호출한 thread는 차단되나? class test_4{ public test_4() { Action&amp;lt;object&amp;gt; action = (object obj) =&amp;gt; { Console.WriteLine(DateTime.Now.ToString(&quot;ss.fff&quot;)); Console.WriteLine(&quot;Task={0}, obj={1}, Thread={2}&quot;, Task.CurrentId, obj, Thread.CurrentThread.ManagedThreadId); Thread.Sleep(1000); }; Task t1 = new Task(action,&quot;t1&quot;); Task t2 = new Task(action, &quot;t2&quot;); for (int i = 0; i &amp;lt; 10; i++) { Console.WriteLine(&quot;{0} : {1}&quot;,i, DateTime.Now.ToString(&quot;ss.fff&quot;)); if (i == 2) { t1.Start(); } else if (i == 6) { t1.Wait(); t2.Start(); t2.Wait(); } Thread.Sleep(1000); } }} 출력을 보면 Main=10 : 07.8771 : 08.8922 : 09.90509.910Task=1, obj=t1, Thread=33 : 10.9214 : 11.9355 : 12.9356 : 13.94513.945Task=2, obj=t2, Thread=47 : 15.9518 : 16.9649 : 17.978 Task 1 의 경우t1.wait 만나기 전까지 Action이 끝날만한 충분한 시간이 있어서 잘 끝났는데 Task 2 의 경우 t2.wait전에 끝나지 않아 시간을 잡아먹음.class test_4는 main thread 이므로 t2.wait만나면서 끝날때까지 기다림.흐름상 wait만나기 전까지 task가 끝나기 않으면 task를 호출했던 thread는 block됨.wait 만나기 전까지 thread랑 task는 각각 따로 가는데wait만났을 떄 해당 task가 끝나지 않은 상태면 thread가 기다려줌 실행은 async인데 실제 method에서는 blocking이라 저런식인듯 이런점이 조금 이상했다. 보통 thread로 따로 빼는 작업들은 시간이 오래 걸려main에서 처리를 안하게끔하는게 목적인데이렇게 하면 별반 다를게 없어보인다.어쨌건 wait만나면 UI는 멈춘것처럼 보일테니까. wait()를 빼면 될것같은데 그것도 찝찝하긴함.언제 끝날지 모르는 작업에 대해끝을 정하지 않고 그저 실행만 하고 넘긴다는게 옳은일인가? 정리 task는 async로 동작하나 여전히 block임. paramster, return이 있는경우 상관없음 더 자세한 내용은 기회가 된다면 나중에..참고작업 기반 비동기 프로그래밍작업 기반 비동기 패턴" }, { "title": "8. Lambda expressions", "url": "/posts/CS_8_Lambda_expressions/", "categories": "Grind, C#", "tags": "c#", "date": "2020-09-30 18:00:00 +0900", "snippet": "C#에서 대리자의 발전 원 내용은 링크에 있고 대충 이렇단다.1 1.0때 명시적 delegate가 나왔고,2.0때 명시적일 필요가 없는 Anonymous Method 가 나오고3.0때 Lambda Expressions이 나왔다고 한다. 위 둘은 봤으니 마지막 Lambda expressions 차례. Lambda expressions 이런 식을 lambda expressions 라고 한다. 식 람다 : 식이 본문으로 보함된 형식(input-parameters) =&amp;gt; expression 문장 람다 : 문 블록이 본문으로 포함된 형식(input-parameters) =&amp;gt; {&amp;lt;sequence-of-statements&amp;gt;} 근데 둘이 다른점이 뭐임???한줄이면 식이고 블록이면 문단임?? ex class lambda_1{ delegate void test_del(); test_del test; public lambda_1() { test = () =&amp;gt; { Console.WriteLine(&quot;test_1&quot;); }; test(); test += () =&amp;gt; { Console.WriteLine(&quot;test_2&quot;); }; test(); test_del tt = () =&amp;gt; { Console.WriteLine(&quot;test_3&quot;); }; tt(); Action act_1 = () =&amp;gt; { Console.WriteLine(&quot;act_1&quot;); }; act_1(); Action act_2 = () =&amp;gt; Console.WriteLine(&quot;act_2&quot;); act_2(); Func&amp;lt;int, int, int&amp;gt; func_1 = (int a, int b) =&amp;gt; { return a * b; }; Console.WriteLine(func_1(10, 12)); Func&amp;lt;int, int&amp;gt; func_2 = (int a) =&amp;gt; a * a; Console.WriteLine(func_2(10)); }} test_1test_1test_2test_3act_1act_2120100 일단, 식이건 블록이건 별 다른게 없어보이고(act_1 vs act_2)delegate에서 뻗어나와서 그런지 Action, Func 사용이 자유로움anonymous method에서 delegate를 빼고(parameter) =&amp;gt; (식) 이렇게 간소화한 표현으로 보임.etc 위 까지 기본 설명. 사용법은 사실 저정도로 짧게 끝나는듯. 여기는 그 외 설명인데 MSDN에서 따로 설명한 부분들이 많아서그냥 정리하고 넘어가려함.2 순서대로 봤다면 지금까지 설명에 없던 개념들이 나오는데관련 내용은 추후에 정리를 하던가 직접 찾아봐야할것같음. 미래의 나에게. 나머지는 나중에 보고 필요하다 생각되면 또는 이해가 된다면 정리함.Async Lambdas. async 및 await 으로된 비동기 이벤트도 간단히 할 수 있다? 그러니까 이걸 public partial class Form1 : Form{ public Form1() { InitializeComponent(); button1.Click += button1_Click; } private async void button1_Click(object sender, EventArgs e) { await ExampleMethodAsync(); textBox1.Text += &quot;\\r\\nControl returned to Click event handler.\\n&quot;; } private async Task ExampleMethodAsync() { // The following line simulates a task-returning asynchronous process. await Task.Delay(1000); }} 이렇게 public partial class Form1 : Form{ public Form1() { InitializeComponent(); button1.Click += async (sender, e) =&amp;gt; { await ExampleMethodAsync(); textBox1.Text += &quot;\\r\\nControl returned to Click event handler.\\n&quot;; }; } private async Task ExampleMethodAsync() { // The following line simulates a task-returning asynchronous process. await Task.Delay(1000); }} Lambda expressions and tuples C# 7.0부터 C# 언어에서 튜플을 기본적으로 지원. 람다 식에 인수로 튜플을 제공할 수 있으며람다 식에서 튜플을 반환할 수도 있음. 경우에 따라 C# 컴파일러는 형식 유추를 사용하여튜플 구성 요소의 형식을 확인할 수 있다. 쉼표로 구분된 해당 구성 요소 목록을괄호로 묶어 튜플을 정의함. ex Func&amp;lt;(int, int, int), (int, int, int)&amp;gt; doubleThem = ns =&amp;gt; (2 * ns.Item1, 2 * ns.Item2, 2 * ns.Item3);var numbers = (2, 3, 4);var doubledNumbers = doubleThem(numbers);Console.WriteLine($&quot;The set {numbers} doubled: {doubledNumbers}&quot;);// Output:// The set (2, 3, 4) doubled: (4, 6, 8) 3개 구성 요소가 있는 튜플을 사용하여숫자 시퀀스를 람다 식에 전달하고각 값을 두 배로 늘린 후 곱하기의 결과가 포함된3개 구성 요소가 있는 튜플을 반환. ex Func&amp;lt;(int n1, int n2, int n3), (int, int, int)&amp;gt; doubleThem = ns =&amp;gt; (2 * ns.n1, 2 * ns.n2, 2 * ns.n3);var numbers = (2, 3, 4);var doubledNumbers = doubleThem(numbers);Console.WriteLine($&quot;The set {numbers} doubled: {doubledNumbers}&quot;); 일반적으로 튜플 필드의 이름은 Item1, Item2 등입니다.그러나 다음 예제에서처럼 명명된 구성 요소가 있는 튜플을 정의 가능. Lambdas with the standard query operatorsType inference in lambda expressionsCapture of outer variables and variable scope in lambda expressionsref Lambda expressions↩ 익명 함수(C# 프로그래밍 가이드)↩" }, { "title": "7. Anonymous", "url": "/posts/CS_7_Anonymous/", "categories": "Grind, C#", "tags": "c#", "date": "2020-09-14 13:00:00 +0900", "snippet": "Anonymous 무명.이름이 없음.그 중 최고는 무명왕. 이름처럼 이름없이 쓸때 씀Anonymous Type 명시적인 형 지정 없이 쓰는것키워드는 var.여기 내용은 Anonymous variable과 Anonymous Type 둘다. class AnonymousType{ //var wrong; public AnonymousType() { //var wrong2; var temp = new { a = 1, b = 2, c = &quot;string&quot;, d = new List&amp;lt;int&amp;gt;{1, 2, 3} }; Console.WriteLine(string.Format(&quot;{0}, {1}, {2}&quot;,temp.a, temp.b, temp.c)); //temp.a = 123; var i = 0; i = 123; var j = new List&amp;lt;int&amp;gt;(); j.Add(1); }} 특징을 보면 class 범위에는 사용할 수 없고 지역변수로만 가능.var wrong의 경우 에러가 나는 이유. 선언과 함께 초기화가 필요함따라서 wrong2도 에러 . var i, j 의 경우 Anonymous variable이고,이 경우 수정 가능. var temp의 경우 Anonymous Type으로위와 같이 여러 속성을 넣을 수 있음.class처럼보임. 근데 method는 안되는듯?이 때, 속성은 읽기 전용으로 수정 불가능. 이거 많이 사용되는건 LINQ사용할 때 라고 함. var temp2 = new[]{ new { cls = 1, name = &quot;a&quot;}, new { cls = 2, name = &quot;b&quot; }, new { cls = 1, name = &quot;c&quot;}};var temp2_list = from t in temp2 where t.cls == 1 select t.name;foreach (var item in temp2_list){ Console.WriteLine(item);} 사실 잘 모르겠다. LINQ 정리하다보면 알게되겠지뭐. Anonymous Method 이전 delegate에서는 이미 있던 method를 연결해 사용했다.만약 단순하거나 단발성 사용등일떄 이름 없이 만들수 있다. class AnonymousMethod{ public delegate void TestDelegate(); public TestDelegate td; public delegate T3 TestDelegate2&amp;lt;T1, T2, T3&amp;gt;(T1 a, T2 b); public TestDelegate2&amp;lt;int , int , string &amp;gt; td2; public AnonymousMethod() { td = delegate { Console.WriteLine(&quot;test&quot;); }; td(); td2 = delegate (int a, int b) { return (a + b).ToString(); }; Console.WriteLine(td2(1, 2)); Action act = delegate { Console.WriteLine(&quot;test2&quot;); }; act(); Action&amp;lt;int, int&amp;gt; act2 = delegate(int a, int b) { Console.WriteLine(a+b); }; act2(10, 11); Func&amp;lt;int, int, string&amp;gt; func = delegate (int a, int b) { return (a + b).ToString(); }; Console.WriteLine(func(22,45)); }} //test//3//test2//21//67 delegate를 이용하기떄문에 Action, Func도 사용 가능. 한번 만들어 놓으면해당 delegate를 쓸 수 있는곳에서는 걔속 쓸 수 있음… 1회용이 아니라 이름만 없던것.매초에 왜 1회용이라고 생각했음?이름도 이름없음인데..참고. C# 무명 메서드 (Anonymous Method)" }, { "title": "6. rebase_2", "url": "/posts/Git_Rebase_2/", "categories": "Grind, Git", "tags": "git", "date": "2020-09-13 13:00:00 +0900", "snippet": "rebase commit 관련 작업 할때 쓰더라 이전까지 그걸 썼고 이번엔 특정 시나리오 상에서 쓰일때?commit, branch, conflict 6-7(dev_1_1) /1-2-3-4-5(master) \\ A-B(dev_2_2) 주 목적은 branch병합. 예를들어 위같은 상황일 떄 dev_1과 dev_2를 합치고싶다. 두가지 경우가 발생하는데 12345AB67 또는 1234567AB 보통 5까지는 remote에 잘 올라가있고 각자 다른 두 명이 dev_1과 dev_2를 각각 작업했을때,다시 push하게되면 둘 중 하나는(늦은사람) conflict가 생김또는 굳이 remote rk dkslejfkeh 간단하게 branch만들어 따로 했던 작업들을 합치고 싶을 때도 마찬가지 해결은 merge를 이용하거나 rebase를 이용하는데 그 중 하나인 rebase를 이용한 방법rebase direction 아래와같은 방식 git rebase A Bgit checkout Bgit rebase A 둘은 같은 뜻으로 A뒤에 B븝 배치 시키거나B의 base를 A로 한다. 정도로 생각하면 될듯. ex.1 1-2-3-4-5-A-B 에서1-2-3-4-5-6-7-A-B 로. 알단 확인 $ git log --oneline 6cb35d5 (HEAD -&amp;gt; dev_2_2, dev_2) B82e9dfa A2a87176 (origin/contents_1, origin/contents, contents_1, contents) 54a123de 4130976b 324f8565 23aa9de8 1a693728 contents init73fd2f2 (origin/master, origin/HEAD, master) Initial commit 시작 git rebase dev_1_112345&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD67=======A&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 82e9dfa... A conflict수정git add .git rebase –continue 1234567A 일단 이렇게 수정해봄 이떄 continue를 하면 A에 대한 commit를 수정했다고 나온다.따라서 rebase작업은 base로 교체한 branch 의 commit까지 다 지나고 부터 시작인듯. 계속하면 12345&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD67A=======AB&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 6cb35d5... B 다시 수정하고 add, continue 결과 1234567AB$ git log --oneline 0ee0b0c (HEAD -&amp;gt; dev_2_2) B - rebase00834e3 A - rebase9dd12c6 (dev_1_1, dev_1) 786d22fb 62a87176 (origin/contents_1, origin/contents, contents_1, contents) 54a123de 4130976b 324f8565 23aa9de8 1a693728 contents init73fd2f2 (origin/master, origin/HEAD, master) Initial commit 결과를 보면 원하는데로 commit가 정렬됐고, 그에맞게 내용도 잘 수정됨.ex.2 1-2-3-4-5-6-7 에서1-2-3-4-5-A-B-6-7 로. 위랑 다 같으므로 빠르게.. $ git log --oneline 9dd12c6 (HEAD -&amp;gt; dev_1_1, dev_1) 786d22fb 62a87176 (origin/contents_1, origin/contents, contents_1, contents) 54a123de 4130976b 324f8565 23aa9de8 1a693728 contents init73fd2f2 (origin/master, origin/HEAD, master) Initial commit $ git rebase dev_2_212345&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADAB=======6&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 86d22fb... 6 12345AB6git rebase --continue6 - FIX# Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit.## interactive rebase in progress; onto 6cb35d5# Last command done (1 command done):# pick 86d22fb 6# Next command to do (1 remaining command):# pick 9dd12c6 7# You are currently rebasing branch &#39;dev_1_1&#39; on &#39;6cb35d5&#39;.## Changes to be committed:# modified: contents/contents.md#~ 12345&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADAB6=======67&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 9dd12c6... 7 12345AB67git add .git rebase --continue 7 - fix# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## interactive rebase in progress; onto 6cb35d5# Last commands done (2 commands done):# pick 86d22fb 6# pick 9dd12c6 7# No commands remaining.# You are currently rebasing branch &#39;dev_1_1&#39; on &#39;6cb35d5&#39;.## Changes to be committed:# modified: contents/contents.md#$ git log --oneline 2b497ad (HEAD -&amp;gt; dev_1_1) 7 - fix38dcc57 6 - FIX6cb35d5 (dev_2_2, dev_2) B82e9dfa A2a87176 (origin/contents_1, origin/contents, contents_1, contents) 54a123de 4130976b 324f8565 23aa9de8 1a693728 contents init73fd2f2 (origin/master, origin/HEAD, master) Initial commit res 그래서 .. 나누어져있던 branch를 다시 합칠때. git rebase A B 로 하면 A뒤에 B를 붙이는 식이고 conflict는 B시작부분 부터 발생. A까지는 쭉 진행된다. branch 를 다시 정렬하면서 commit의 위치들을 옮기게 되는데이때 commit의 위치가 바뀌는것 때문에 base가 달라진다 해서 rebase라고 하지 않았나 싶음." }, { "title": "6. Delegate", "url": "/posts/CS_6_Delegate/", "categories": "Grind, C#", "tags": "c#", "date": "2020-09-07 13:00:00 +0900", "snippet": "Delegate 이전에 Action, Func에서 봤던 형식으로이 둘이 좀더 표준화 느낌이라 했는데그럼 delegate에 대해 좀더 정리해보자. 메서드에 대한 참조를 나타내는 타입. delegate는 뜻이 대리자임. 하는짓 그 자체.method를 가리키거나 method자체를 parameter로 넘길때 쓴다함. 쨌든 method를 직접 call하는 대신이 delegate로 대신해 call 할 수 있다. delegate 선언때 return, parameter을 지정하는데실제 method가 이 delegate형식과 맞으면붙여다 쓸 수 있고, 하나 이상 붙여 쓸 수 있다.기본 일단써봄 class Program{ static void Main(string[] args) { deletgate_1 del_1 = new deletgate_1(); del_1.test(); }}class deletgate_1{ public delegate void testdel(); public testdel test; public deletgate_1() { //test = new testdel(mtd_1); test = mtd_1; test(); } public void mtd_1() { Console.WriteLine(&quot;mtd_1&quot;); }} mtd_1mtd_1 여기서 test에 mtd_1을 연결한 후 test(); 를 호출할 때마다 mtd_1이 실행됨.여기서는 deletgate_1의 ctor에서 한번 Main에서 한번. 그러니까 delegate로 연결 한 method를 직접 call하지 않고delegate를 call함으로써 연결 된 method를 사용하는 효과를 냄. 주석 처리된 부분은 원래 저렇게 써야되는것 같은데편의상(?) 아래처럼 쓰는듯하다.주석처럼 쓰더라도 test();로 콜하는건 달라지지않음. delegate는 이벤트가 처음 시작되는 애한테 쥐어줌. 하나 더 써보면 delegate는 class외부에 쓸 수 있음 class Program{ static void Main(string[] args) { deletgate_1 del_1 = new deletgate_1(); del_1.test(); }}public delegate void testdel();class deletgate_1{ public testdel test; public deletgate_1() { //test = new testdel(mtd_1); test = mtd_1; test(); } public void mtd_1() { Console.WriteLine(&quot;mtd_1&quot;); }} return, paraneters delegate return method(parameter) class Program{ static void Main(string[] args) { rtnprm rp = new rtnprm(); rp.cal = rp.add; Console.WriteLine(rp.cal(2, 1)); rp.cal = rp.sub; Console.WriteLine(rp.cal(2, 1)); }}class rtnprm{ public delegate int delcal(int a, int b); public delcal cal; public int add(int _a, int _b) { Console.WriteLine(&quot;add&quot;); return _a + _b; } public int sub(int _a, int _b) { Console.WriteLine(&quot;sub&quot;); return _a - _b; }} add3sub1 여기 delegate는 return은 int, parameter은 int, int 임.아래 add, sub도 같은 형식의 method이다.따라서 delegate는 이 둘 method를 참조 할 수 있다. delegate와 형식만 같다면위처럼 add를 하건 sub를 하건 그때그때 붙여 쓸 수 있다.Generalization 위에서 return, parameter을 일반화할 수 있음 class Program{ static void Main(string[] args) { Generalization gen = new Generalization(); gen.cal_int = gen.add; Console.WriteLine(gen.cal(1,2)); }}class Generalization{ public delegate T3 delcal&amp;lt;T1,T2,T3&amp;gt;(T1 a, T2 b); public delcal&amp;lt;int, int, double&amp;gt; cal; //public delcal&amp;lt;double&amp;gt; cal_dou; public Generalization() { } public double add(int _a, int _b) { Console.WriteLine(&quot;add&quot;); return _a + _b; }} 어디서 많이 본 그림이다?chain 위 예시에서 return, parameter조건이 다 같다.만약 항상 add, sub을 같이 불러야한다면? delegate가 나오면 자주보이는 키워드인데이 delegate에 여러개 지정해놓고 동시에(연속으로) 실행가능.위 예시에서 main만 수정하면됨 rtnprm은동일. rtnprm rp = new rtnprm();rp.cal = rp.add;rp.cal += rp.sub;Console.WriteLine(rp.cal(2,1)); addsub1 이런식으로 = 이 아닌 +=로 더하면 된다.반대로, 뺄때는 당연히 -=로 .. 결과를 보면 add, sub가 찍힌걸 보니method까진 간것같음 근데 출력은 마지막 결과값만 나옴.그래서 아래 찾아봤는데 의도는 조금 다르지만 비슷한 질문이 있음.결론만 말하자면 chain으로 사용하면 return은 void로 하고 사용하는걸 권장.아니면 다른 방법으로 하는데 그건 해당 글 참조.1 무튼 muiltcast하는 효과를 볼 수 있다.use delegate as parameter 또한 delegate자체를 parameter로 넘겨줄 수 있다. class UseDelegateAsParameter{ public delegate int delcal(int a, int b); public delcal cal; public UseDelegateAsParameter() { cal = add; test(cal); } public void test(delcal _dc) { Console.WriteLine(_dc(1, 2)); } public int add(int _a, int _b) { Console.WriteLine(&quot;add&quot;); return _a + _b; } public int sub(int _a, int _b) { Console.WriteLine(&quot;sub&quot;); return _a - _b; }} delegate?? 위 까지 보면 막상 이걸 왜쓰나 싶은데 써보면 편함. 가장 편하게 쓰는건 class간 작업할 때. static void Main(string[] args){ DelegateClass_1 dc1 = new DelegateClass_1(); DelegateClass_2 dc2 = new DelegateClass_2(); dc1.from1 = dc2.mtd_1; dc1.mtd_1(1,2);} class DelegateClass_1{ public delegate string delfrom1(int a, int b); public delfrom1 from1; public void mtd_1(int _a, int _b) { Console.WriteLine(_a + _b); Console.WriteLine(from1(_a, _b)); }}class DelegateClass_2{ public string mtd_1(int _a, int _b) { return _a.ToString() + _b.ToString(); }} 쉬운 예를 들어 위에서 class1은 받은 수를 더하고 출력,class2는 받은 수를 string로 변환후 더함.main에서 class1, class2로 각각 method를 부른 것 이 아닌class1에서 class2로 delegate만 연결 하고 class1의 method만 씀.이렇게 되면 class2의 method를 class1의 method인것처럼 쓰게됨. 가장 떠올리기 쉬운 상황은 form간 작업할 떄.서로 다른 form이 떠있을 때 data를 주고 받거나다른쪽에 있는 method를 쓸때 유연하게 쓸 수 있다. 조금 더 일반적으로는 class A와 class B가 있을 때class A에서 B를 만들지 않는 이상 접근을 위해서는생성 된 B를 받아 쓰거나 A와 B를 생성한 상위 class에서 연결 역할을 해줘야함또, class를 맴버로 갖고있는 계층구조 단계가 좀 많을 경우,예를들어 class A 안에 class B 안에 class C…class F 같은경우class A 에서 class F로 바로 access할 경우 등귀찮아질 상황들이 delegate로 간단히 해결됨.이걸 미리 만들어놓은 Action, Function으로 하면 더 좋고.참고 Using a Multicast Delegate to chain functions ↩ C# DELEGATE에 대한 정리 C# 강좌 : 제 21강 - 델리게이트 C# 델리게이트(DELEGATE) 개념 잡히는 예제 C# 강좌 19편. 델리게이트와 이벤트(Delegates and Events) C# Delegate 기본 개념과 사용법 C# delegate (콜백, 체인, 범용성) 대리자(C# 프로그래밍 가이드) 대리자 사용(C# 프로그래밍 가이드) C# delegate의 개념 Delegate - callback chain" }, { "title": "5. rebase_1", "url": "/posts/Git_Rebase_1/", "categories": "Grind, Git", "tags": "git", "date": "2020-08-30 13:00:00 +0900", "snippet": "commit 작업 중간중간 세이브 포인트 느낌. 중요함. 그래서 commit에 대해 조작하는걸 조금 더 보기로 함. 이 전까지 commit만들고, 그 commit 중 어떤 시점으로의 이동을 하는 방법을 봤다.이번엔 그 외 할 수 있는것들을 써보자. 이게 기본 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ cat contents/contents.md 1 2 3 4 5 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git log --oneline 2a87176 (HEAD -&amp;gt; contents_1, origin/contents_1, origin/contents, contents) 5 4a123de 4 130976b 3 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit rebase commit에 대한 제어(?)를 할 때 씀 제어가 정확한 표현이 될지 모르겠는데 commit message 수정, 병합, 분할, 제거, 해당 commit 작업내용의 수정 등 git rebase -i –root로 시작 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git rebase -i --root pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 pick 130976b 3 pick 4a123de 4 pick 2a87176 5 # Rebase 2a87176 onto 24f8565 (7 commands) # # Commands: # p, pick &amp;lt;commit&amp;gt; = use commit # r, reword &amp;lt;commit&amp;gt; = use commit, but edit the commit message # e, edit &amp;lt;commit&amp;gt; = use commit, but stop for amending # s, squash &amp;lt;commit&amp;gt; = use commit, but meld into previous commit # f, fixup &amp;lt;commit&amp;gt; = like &quot;squash&quot;, but discard this commit&#39;s log message # x, exec &amp;lt;command&amp;gt; = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with &#39;git rebase --continue&#39;) # d, drop &amp;lt;commit&amp;gt; = remove commit # l, label &amp;lt;label&amp;gt; = label current HEAD with a name # t, reset &amp;lt;label&amp;gt; = reset HEAD to a label # m, merge [-C &amp;lt;commit&amp;gt; | -c &amp;lt;commit&amp;gt;] &amp;lt;label&amp;gt; [# &amp;lt;oneline&amp;gt;]lo0 # . create a merge commit using the original merge commit&#39;s # . message (or the oneline, if no original merge commit was git rebase -i –root -i는 –interective로 … 상호작용? 대화형이라는데 ..잘 모르겠.. 그냥 이거 쓰래 –root는 root가 되는 commit부터 보겠다는 뜻 이전 다른 것들처럼 HEAD~3등 할 수 있는데 HEAD를 움직인 경우 그 다음 commit부터 수정가능. 대충 이렇게 알고있는데 시작할때 –root 쳐서 했던거로 기억함. pick : commit를 사용하겠다함. 근데 기본으로 다 pick되어있고.. 무슨의미인지 모르겠음 reword : commit message수정 edit : commit message수정, 근데 commit 작업 내용 수정도 가능 squash : 이전 commit 에 합침.. fixup : squash와 같은데 message는 무시함 exec : 그냥 cmd 실행인듯? break : rebase 일시정지 drop : commit 지움 label : reset : HEAD를 labal로 merge : commit merge 내용은 pick부분을 수정한다. 할 수 있는건 해보기로. reword, edit reword는 commit 수정edit는 commit 수정, 실제 내용 수정도 가능 reword 4의 commit message 를 수정해봄 수정 할 commit 지정 pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 pick 130976b 3 reword 4a123de 4 pick 2a87176 5 에디터에서 수정 4 - reword # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Author: psy_comp &amp;lt;psy0231@gmail.com&amp;gt; # Date: Fri Aug 7 14:08:04 2020 +0900 # # interactive rebase in progress; onto 9993e1b # Last commands done (6 commands done): # pick 130976b 3 # reword dd097ac 4 - reword # Next command to do (1 remaining command): # pick 9ec22fd 5 # You are currently editing a commit while rebasing branch &#39;contents_1&#39; on &#39;9993e1b&#39;. # # Changes to be committed: # modified: contents/contents.md 확인 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git log --oneline 7293f2b (HEAD -&amp;gt; contents_1) 5 3fe0ebb 4 - reword 130976b 3 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit 별거 없이 바뀌는데 처음과 다른점은 reword한 4 commit을 포함한 그 이후 commit가 id가 다 바뀜. 참고로, 맨 마지막 commit message만 수정하는경우 git commit –amend로 하면 간단함 edit 3 commit 내용 및 commit message 수정 pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 edit 130976b 3 pick 3fe0ebb 4 - reword pick 7293f2b 5 reword랑 다른점 상태가 바뀜. 또 실제 그 당시 내용으로 돌아감 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ git rebase -i --root Stopped at 130976b... 3 You can amend the commit now, with git commit --amend Once you are satisfied with your changes run git rebase --continue psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2|REBASE 5/7) $ psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2|REBASE 5/7) $ git status interactive rebase in progress; onto b74e4ed Last commands done (5 commands done): pick 24f8565 2 edit 130976b 3 (see more in file .git/rebase-merge/done) Next commands to do (2 remaining commands): pick 3fe0ebb 4 - reword pick 7293f2b 5 (use &quot;git rebase --edit-todo&quot; to view and edit) You are currently editing a commit while rebasing branch &#39;contents_2&#39; on &#39;b74e4ed&#39;. (use &quot;git commit --amend&quot; to amend the current commit) (use &quot;git rebase --continue&quot; once you are satisfied with your changes) nothing to commit, working tree clean psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2|REBASE 5/7) $ cat .git/ contents/ README.md psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2|REBASE 5/7) $ cat contents/contents.md 1 2 3 여기부터 수정 가능해짐. 내용수정 1 2 3 - fix git add . git rebase –continue 이때 해당 commit 의 commit message를 수정할수 있음. 3 - commit message fix # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Author: psy_comp &amp;lt;psy0231@gmail.com&amp;gt; # Date: Fri Aug 7 14:07:48 2020 +0900 # # interactive rebase in progress; onto 8c3afc4 # Last commands done (5 commands done): # pick 24f8565 2 # edit 130976b 3 # Next commands to do (2 remaining commands): # pick 3fe0ebb 4 - reword # pick 7293f2b 5 # You are currently splitting a commit while rebasing branch &#39;contents_2&#39; on &#39;8c3afc4&#39;. # # Changes to be committed: # modified: contents/contents.md conflict 해결. 여기부터 뒤로 전부 걸리는것같음.ㄷㄷ 매번 commit 수정하고 2,3,4를 끝까지 반복 확인 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ git log --oneline 13e1946 (HEAD -&amp;gt; contents_2) 5 abf82d6 4 - reword 7635b6a 3 - commit message fix 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ cat contents/contents.md 1 2 3 - fix 4 5 reword처럼 commit id가 다 바뀜 혹시나해서.. 붙어있는 commit 를 분할할때 이걸쓰면 됨근데 commit분할은 이거 말고도 다른 방법이 많이보이긴 한데 일단 말나온김에 써봄 아래 예시에서 3,4를 따로 분리하고자함 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ git log --oneline 1afb93f (HEAD -&amp;gt; contents_2, contents_1) 5 f5afcaa 3 and 4 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ cat contents/contents.md 1 2 3 4 5 edit로 진입, 마지막 commit로 돌아옴 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 edit f5afcaa 3 and 4 pick 1afb93f 5 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2|REBASE 5/6) $ cat contents/contents.md 1 2 3 4 마지막 commit에 있어야할 내용으로 수정 후 git add . git commit –amend 여기서는 4를 지우고 commit message로 3으로 바꿈 git rebase –continue로 진행하면 이 후 commit가 들어오는데 이걸 쓰지말고 4를 만들어야함 위 까지 하면 1,2,3까지 만들어진상태. 아래 4를 넣고 add , commit -m “4” 다음 5를 만들고 add, commit -m “5” git rebase –continue로 끝냄 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ git log --oneline 31f0cee (HEAD -&amp;gt; contents_2) 5&#39; 7df1f7c 4&#39; 4b86f26 3&#39; 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_2) $ cat contents/contents.md 1 2 3 4 5 이렇게 되면 하나였던 commit를 분리가 된건데 하다보니 좀 안좋은것같아서 branch 할때 이거랑 섞어 다시 쓰겠음 squash, fixup squash는 현재 commit를 이 전 commit를 합침fixup는 squash같이 단, 해당 commit 무시 각각 5를 4에 squash, 3을 2에 fixup 해봄squash 5를 4에 squash 하면 pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 pick 130976b 3 pick 4a123de 4 squash 2a87176 5 commit를 수정하는 에디터가 뜸. squash는 commit message를 버리지 않고 수정 가능하게 해줌 # This is a combination of 2 commits. # This is the 1st commit message: 4 # This is the commit message #2: 5 # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # Author: psy_comp &amp;lt;psy0231@gmail.com&amp;gt; # Date: Fri Aug 7 14:08:04 2020 +0900 # # interactive rebase in progress; onto 17834a7 # Last commands done (7 commands done): # pick 4a123de 4 # squash 2a87176 5 # No commands remaining. # You are currently rebasing branch &#39;contents_1&#39; on &#39;17834a7&#39;. # # Changes to be committed: # modified: contents/contents.md 잘 수정하고 저장하면 결과 보여줌 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git rebase -i --root [detached HEAD 99b7318] 4 and 5 Author: psy_comp &amp;lt;psy0231@gmail.com&amp;gt; Date: Fri Aug 7 14:08:04 2020 +0900 1 file changed, 3 insertions(+), 1 deletion(-) Successfully rebased and updated refs/heads/contents_1. psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git log --oneline 99b7318 (HEAD -&amp;gt; contents_1) 4 and 5 130976b 3 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit fixup 3을2에 fixup해봄 (위꺼에 이어) pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 fixup 130976b 3 pick 99b7318 4 and 5 squash와 다르게 이건 선택된 로그를 쓰지 않으므로 바로 끝남 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git rebase -i --root Successfully rebased and updated refs/heads/contents_1. psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git log --oneline 111bcf4 (HEAD -&amp;gt; contents_1) 4 and 5 7618668 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit squash, fixup?? 일단, 결과는 commit가 합쳐지는 것으로 같음. 다른점은 commit를 다시 쓰냐 마냐정도단, 둘다 결과 commit부터 그 뒤 commit id가 다 바뀜. 결과에 대해 조금 더 보면 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git diff 3aa9de8..7618668 diff --git a/contents/contents.md b/contents/contents.md index 56a6051..5f5fbe7 100644 --- a/contents/contents.md +++ b/contents/contents.md @@ -1 +1,3 @@ -1 \\ No newline at end of file +1 +2 +3 \\ No newline at end of file psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git diff 7618668..111bcf4 diff --git a/contents/contents.md b/contents/contents.md index 5f5fbe7..85954ea 100644 --- a/contents/contents.md +++ b/contents/contents.md @@ -1,3 +1,5 @@ 1 2 -3 \\ No newline at end of file +3 +4 +5 \\ No newline at end of file psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ 1 commit 에서 2 commit로 넘어갈 때 보면 2,3 동시애 함. 여기서 4,5로 넘어갈때도 마찬가지. 다시말해 합쳐진 두 commit는 두 commit의 실제 작업내용을 갖고있음 걍 자잘한 commmit 지울때 좋은듯.exec run cmd라는데 pick 73fd2f2 Initial commit pick a693728 contents init exec cat contents/contents.md pick 3aa9de8 1 exec cat contents/contents.md pick 24f8565 2 exec cat contents/contents.md pick 130976b 3 exec cat contents/contents.md pick 4a123de 4 exec cat contents/contents.md pick 2a87176 5 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git rebase -i --root Executing: cat contents/contents.md Executing: cat contents/contents.md Executing: cat contents/contents.md 1 Executing: cat contents/contents.md 1 2 Executing: cat contents/contents.md 1 2 3 Successfully rebased and updated refs/heads/contents_1. 이런식인데 잘 모르겠음 저렇게 쓰는것도 맞나싶고..중간부터 왜 안되는지 모르겠음drop commit 삭제 pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 pick 130976b 3 pick 4a123de 4 drop 2a87176 5 바로 끝나는데 psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git rebase -i --root Successfully rebased and updated refs/heads/contents_1. psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ git log --oneline 4a123de (HEAD -&amp;gt; contents_1) 4 130976b 3 24f8565 2 3aa9de8 1 a693728 contents init 73fd2f2 (origin/master, origin/HEAD, master) Initial commit psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test (contents_1) $ cat contents/contents.md 1 2 3 4 내용, commit 다 지워지는건가봄 중간꺼 하나더. pick 73fd2f2 Initial commit pick a693728 contents init pick 3aa9de8 1 pick 24f8565 2 drop 130976b 3 pick 4a123de 4 pick 2a87176 5 이상태에서는 conflict남 edit할 때 처럼 다 수정해줘야함. 또, drop쓸 줄을 그냥 지워도 똑같이 동작한다함.label, reset, merge ??" }, { "title": "4. reset, revert", "url": "/posts/Git_Reset_Revert/", "categories": "Grind, Git", "tags": "git", "date": "2020-06-15 13:00:00 +0900", "snippet": "commit save point 라고 생각한다. 그럼, 이번판은 망했으니 이전 save로 돌아가는것도 가능한가?가능함. 보통 두개의 예시를 많이 볼 수 있음. 좋은 설명들은 아래 참고부터.reset 초기화. 원하는 commit로 돌아가는데 그 이후 commit는 지워진다함. 세가지 옵션이 있는데 조금씩 다르다. 기본 예로 $ git log --oneline f11bb5a (HEAD -&amp;gt; reset_hard, reset_soft, reset_mixed, master) 5 e2d7109 4 da141ef 3 b24316b 2 59bb278 1 ea27983 initial commit git reset –option 로 시작하는데 git reset --option [HEAD~?] git reset --option [commit id] 이렇게 작성. hard 먼저 HEAD를 움직여 보자. $ git reset --hard HEAD~2 HEAD is now at da141ef 3 $ git status On branch reset_hard nothing to commit, working tree clean $ git log --oneline da141ef (HEAD -&amp;gt; reset_hard) 3 b24316b 2 59bb278 1 ea27983 initial commit $ cat test.md 1 2 3 원래 있던 4,5 commit 가 사라졌고 3으로 내려왔다. 그러니까 HEAD~2는 HEAD를 지금 가리키고 있는 포인트에서 2개 돌아가란 뜻. 이때 실제 commit를 만들기 위해 수정했던 파일은 그 당시로 돌아가있다.진짜 이전 save point로 돌아간느낌이든다. 작업 내용도 그 당시로 돌아가있다. 직접 commit id를 넣는방법 $ git log --oneline da141ef (HEAD -&amp;gt; reset_hard) 3 b24316b 2 59bb278 1 ea27983 initial commit $ git reset --hard b24316b HEAD is now at b24316b 2 $ git log --oneline b24316b (HEAD -&amp;gt; reset_hard) 2 59bb278 1 ea27983 initial commit $ git status On branch reset_hard nothing to commit, working tree clean HEAD가 해당 commit로 옮겨 지면서 그 이후 만들어졌던 commit 들이 지워졌다. 어차피 HEAD를 옮기면서 commit을 제어하게 되는데 위(최근)부터 내려가나 내가 원하는 commit id를 직접넣어 바로 찾거나 하는것만 다르다. 아무튼 중요한건 실제 save point였던 commit들이 지워졌다는거고, 그 commit가 지워지면 그당시 작업 내용들까지 해당 commit로 돌아간다는것이다. 작업 내용을 어느 시점으로 화끈하게 날릴때.soft 다시, 처음으로 돌아가 옵션만 바꾸고 해본다. $ git reset --soft HEAD~2 ???hard와 다르게 아무런 반응이 없다.이상할때는 log랑 status를 수시로 쳐보는게 좋다하니까.. $ git log --oneline da141ef (HEAD -&amp;gt; reset_soft) 3 b24316b 2 59bb278 1 ea27983 initial commit $ cat test.md 1 2 3 4 5 $ git status On branch reset_soft Changes to be committed: (use &quot;git restore --staged &amp;lt;file&amp;gt;...&quot; to unstage) modified: test.md 뭔가 이상하다. hrad의 경우 돌아가려는 해당commit로 완벽하게 돌아갔다. commit 한 직후로. 근데 soft는 조금 다르다. HEAD는 원하는 시점으로 옮겨졌는데 test.md파일이 mod상태로 돌아갔다. 이건 commit를 기다리는 stage상태로 돌아갔다는 말임. test.md파일 내용을 확인해 보면 내용이 다 살아있다. commit message가 5의( reset전 원본 commit 중 맨 마지막 commit) 작업 내용까지 다 살아있었다. soft는 commit만 지우고 그 작업 내용은 그대로 두는 것이다. 이후 계속 해보면 $ git commit -m &quot;new &quot; [reset_soft c546097] new 1 file changed, 3 insertions(+), 1 deletion(-) $ git log --oneline c546097 (HEAD -&amp;gt; reset_soft) new da141ef 3 b24316b 2 59bb278 1 ea27983 initial commit 실제 test.md파일 내용은 마지막 수정까지(reset soft전) 온전히 살이있다. commit만 지워지고 작업내용은 남음. 새 commit로 덮음. 세상에.. 그럼 잦은 수정에 commit까지 너저분해지면 쓸만한건가 싶다.mixed 옵션을 적지 않으면 이게 기본이라한다. 옵션을 꼭 적는습관을 길러야겠다… 다시 원본으로 돌아가서 옵션바꾸고 다시실행. $ git reset --mixed HEAD~2 Unstaged changes after reset: M test.md $ cat test.md 1 2 3 4 5 $ git log --oneline da141ef (HEAD -&amp;gt; reset_mixed) 3 b24316b (reset_hard) 2 59bb278 1 ea27983 initial commit $ git status On branch reset_mixed Changes not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git restore &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: test.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 위 soft와 비슷해 보인다. 실제 파일 내용 변경도 마지막 commit 내용을 갖고있다.다른점은 soft는 add까지 한 상태 이건 그것도 안되어있음. 계속 해보면 $ git add . $ git commit -m &quot;mixed&quot; [reset_mixed 1ae9a2d] mixed 1 file changed, 3 insertions(+), 1 deletion(-) $ git log --oneline 1ae9a2d (HEAD -&amp;gt; reset_mixed) mixed da141ef 3 b24316b (reset_hard) 2 59bb278 1 ea27983 initial commit 사실 soft와 차이는 잘 모르겠다. commit는 여전히 날라갔고 작업 내용은 여전히 남아있다.add차이만 있다 뿐이지..reset 정리 HEAD를 원하는 시점으로 옮기고 그 이후 commit는 다 지운다. HARD는 완전히 그 시점으로 돌아감. SOFT는 내용은 남기고 commit를 삭제함. 단, add까지 해놓은 상태. MIXED는 내용을 남기고 commit를 삭제함. 단, add 도 안되어있음. revert 되돌아가다 라고 나온다. 근데 아래 두 가지 경우 결과가 다르다. 5층으로 쌓은 블럭이 있다. 이 중 3층을 없애 버렸다고 했을때, 4층과 5층은 남아있어야 하는가 없어져야 하는가. 5년의 역사에서 3년째에 핵전쟁으로 4,5년까지 영향이있다. 3년째를 역사에서 지우면 4,5년에 있던 핵전쟁 피해는 있나? 하루 종일 뻘짓하다 뭔가 이상해서 확실하게 보는 방법몰라서 다시 작성함. 지금 쓰는내용은 뻘짓거리들 다 지우고 씀 먼저는 파일 하나에 대해 revert하고 있었는데 이 파일 하나에 대해 revert는 HEAD에 대해 할 때 빼놓고 다른경우 전부 conflict 걸림 그래서 5개의 파일을 만들면서 각각의 commit를 만들고 그 경우에 대해 revert해봄. case 1 $ ls test.md $ git log --oneline ea2e280 (HEAD -&amp;gt; 1) 5 ba42806 4 b8103da 3 32e5a2d 2 c8441a0 1 이렇게 commit가 있을 때 git revert HEAD 는 문제없이 함. git revert commit3 하면 conflict git revert HEAD~2 하면 conflict 근데 다른 설명에선 revert할때 딱히 conflict에 대한 설명이 없었음.. 그냥 자연스러운건가 싶었는데 아래 보면 잘 되는것같다. 내가 뭔가 이상한것같다. 아니더라도 conflict내용이 이해가 잘 안간다. 해서 예제를 바꿔서 다시 해보기로함. file 하나가 아니라 5개 의 다른 파일을 생성하고 각각생성시 commit를 씀 case 2 $ ls 1.md 2.md 3.md 4.md 5.md $ git log --oneline 2fee114 (HEAD -&amp;gt; master) 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 아래에서 두 경우 다 보기로.revert case 1 이제 다시 해보자. git revert HEAD Revert &quot;5&quot; This reverts commit 2fee114dcda180f753fa6957e2be58e90ed72002. # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # deleted: 5.md # ~ 에디터 열리면서 순조로움 $ git revert HEAD Removing 5.md [master 1c4e1c7] Revert &quot;5&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 5.md $ ls 1.md 2.md 3.md 4.md $ git log --oneline 1c4e1c7 (HEAD -&amp;gt; master) Revert &quot;5&quot; 2fee114 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 revert는 HEAD에서 했던 작업을 취소 하면서 취소 했다는 새 기록(commit)을 남긴다. reset와 다른점은 이전 commit에 대해 영향을 주지 않는 다는것이다. remote는 나중관점이니 배제하고 일단 이시점에서만 보면 특정 작업을 했다는 저장(commit)은 남기되 작업 내용 자체는 취소했으니 그 전으로도 다시 돌아갈수 있음. 여기에서 git reset –hard HEAD~1하면 처음 상태로 돌아감. reset와 달리 commit자치게 없어진게 아니라 좀 더 안전한가? reset도 soft나 mixed는 작업 내용을 남길 수 있었는데 마지막 최종작업만 남기고 commit는 날라가긴함. revert는 작업은 날리되 commit를 남김. 중간 특정 작업 여기서부터 난리였는데 reset의 경우 HEAD~? 으로 정하는 경우 지정된 HEAD이후 commit는 다 지워졌다. git revert HEAD~2 이러면 어떻게 될까 내 예상은 이랬다. 단순히 reset와 비슷할 거라는 생각으로 $ ls 1.md 2.md 3.md $ git log --oneline 1c4e1c7 (HEAD -&amp;gt; master) Revert &quot;3&quot; 2fee114 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 이런식. 다시말해, HEAD가 옮겨진 commit 3까지 작업내용은 살아있고 이후는 다 사라짐. 여전히 commit들은 다 살아있고 revert 3 commit 하나 더 추가. 그런데 아님 . 진짜 결과는 $ ls 1.md 2.md 4.md 5.md $ git log --oneline d9dd5e7 (HEAD -&amp;gt; master) Revert &quot;3&quot; 2fee114 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 이렇게 되면 위에 git revert HEAD 제외한 모든 revert에서 conflict났던게 대충 유추되는데 HEAD를 포인트까지 옮기고 지움 그리고 그 이후 commit 내용들을 그대로임 . reset와 revert조금씩 다름. 범위를 지정. 그럼 이것도 얘를들어 git revert commit4..commit2 이러면 $ ls 1.md 5.md $ git log --oneline d9dd5e7 (HEAD -&amp;gt; master) Revert &quot;4-2&quot; 2fee114 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 이것도 아님. 실제로 해보면 $ git log --oneline 2fee114 (HEAD -&amp;gt; master) 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 $ git revert d06ff1f..4cd12ca error: empty commit set passed fatal: revert failed 일단 에러난다. 위 commit 는 순서상 1 -&amp;gt; 5 순서로 쌓았는데 revert 범위를 지정할때에도 그 방향으로 해줘야 하나봄 commit4..commit2 가 아닌 쌓은 순서대로 commit2..commit4로 가야 맞다. $ git revert 4cd12ca..d06ff1f ============================================ Revert &quot;4&quot; This reverts commit d06ff1fb28551ad8c5884399ac85660be791baa0. # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # On branch master # Revert currently in progress. # # Changes to be committed: # deleted: 4.md # ~ ============================================== Revert &quot;3&quot; This reverts commit 67306628e3f506153ba2b45e52bec38864a105be. # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # On branch master # Revert currently in progress. # # Changes to be committed: # deleted: 3.md # ================================================== $ git revert 4cd12ca..d06ff1f Removing 4.md [master b719edf] Revert &quot;4&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 4.md Removing 3.md [master e5b2e77] Revert &quot;3&quot; 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 3.md $ git log --oneline e5b2e77 (HEAD -&amp;gt; master) Revert &quot;3&quot; b719edf Revert &quot;4&quot; 2fee114 5 d06ff1f 4 6730662 3 4cd12ca 2 d06b272 1 psy02@psy-company MINGW64 ~/Desktop/root/revert_2 (master) $ ls 1.md 2.md 5.md psy02@psy-company MINGW64 ~/Desktop/root/revert_2 (master) $ 이런 결과. 아디에서 봤던것처럼 순조롭게 자동으로 된다. 근데 결과가 생각과는 다르다. commit 2 작업 내용이 살아있다 실제 revert 된것도 3,4에 대해서만 나왔다. 그러니까 revert범위는 단일 commit를 지정하면 그 commit만 revert하고 범위로 지정 할 경우 commit이후..commit까지로 지정이 된다. 범위 지정은 commit순서대로 옛날commit..최근commit으로 하는데 실행은 최근commit -&amp;gt; 옛날commit순으로 됨. 이건 당연해 보이는게 해당 commit의 작업 내용을 없애는 작업은 최근부터 과거순으로 해야 되감아지기때문에. revert case 2 이걸 단일 파일 하나에서 하면 conflict나는데 .. 파일 자체의 내용이 내부에서 바뀌니까 그런건가? 근데 git help revert 내용 중에 기존 커밋이 하나 이상 있으면 관련 패치가 도입 한 변경 사항을 되돌리고 이를 기록하는 새로운 커밋을 기록하십시오. 이를 위해서는 작업 트리가 깨끗해야합니다 (HEAD 커밋의 수정 사항 없음). 라고 하는데 … 이 내용이면 revert_1의 내용이 어느정도 맞는것같음. 근데 “도입 한 변경 사항을 되돌리고” 라면 이후 변경사항도 없어지는게 맞다고 생각하면 revert_1도 아님. 그래서 지금부터 하는건 결과가 다름. 이 둘의 혼동으로 지금 뭐가 맞는지 모르겠음 5층짜리 블럭에서 3층이 없어진다면 4,5층은 있어야 하는가 사라져야 하는가. 다시, 원본으로 와서 $ git log --oneline ea2e280 (HEAD -&amp;gt; 1) 5 ba42806 4 b8103da 3 32e5a2d 2 c8441a0 1 git revert HEAD $ git revert HEAD [1 b26730a] Revert &quot;5&quot; 1 file changed, 1 insertion(+), 2 deletions(-) $ git log --oneline b26730a (HEAD -&amp;gt; 1) Revert &quot;5&quot; ea2e280 5 ba42806 4 b8103da 3 32e5a2d 2 c8441a0 1 $ cat test.md 1 2 3 4 잘 된다. 파일 내용도 고쳐졌고 HEAD이전으로 돌아가되 그게대한 commit가 남고 1~5까지의 commit도 전부 남아있다. 내가지금 reset, revert이내용만 3번쨰 쓰는게 빡치는건아닌데 계속 반복되는 의미없는것들은 설명안하고 넘어가겠음 git revert HEAD~2 psy02@psy-company MINGW64 ~/Desktop/root/revert (1) $ git revert HEAD~2 Auto-merging test.md CONFLICT (content): Merge conflict in test.md error: could not revert b8103da... 3 hint: after resolving the conflicts, mark the corrected paths hint: with &#39;git add &amp;lt;paths&amp;gt;&#39; or &#39;git rm &amp;lt;paths&amp;gt;&#39; hint: and commit the result with &#39;git commit&#39; psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ 이 전과 다르다 conflict난다. 내용을 보자. 1 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD 2 3 4 5 ======= 2 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; parent of b8103da... 3 HEAD부터 ===까지 지우고 parent 줄도 지운다 1 2 이게 남은 내용일꺼임. 저장하고 add, commit 하면 psy02@psy-company MINGW64 ~/Desktop/root/revert (1) $ git log --oneline fb189b3 (HEAD -&amp;gt; 1) revert ea2e280 5 ba42806 4 b8103da 3 32e5a2d 2 c8441a0 1 psy02@psy-company MINGW64 ~/Desktop/root/revert (1) $ cat test.md 1 2 그럼 다시 생각해보자. 원본에서 HEAD는 commit5에있었다. HEAD~2했으니 commit3을 revert했겠지 근데 “revert_파일들”에서의결과와 다르다. 전자는 3층의 블럭을 빼고 4,5층은 2층위에 쌓은 모양이면 지금은 3층부터 그 윗층을 전부 박살냈는데 이전 기억은 남겨놓은것 conflict상황에 수정을 1245이렇게 하면 이 전과 같긴한데 그래도 위 수정 필요한곳 incomming는 2만 붙어있음…. 내가 저 수정을 잘 못하는건가? 단순하게, «&amp;lt;부터 ===까지 이전내용 다시, ===부터 »&amp;gt;까지 바뀔내용으로 알고있는데 이전내용 무시하고 새 변경사항만 하면 위처럼 되는게 맞는걸로 알고있음 git revert 32e5a2d..ba42806 psy02@psy-company MINGW64 ~/Desktop/root/revert (1) $ git revert 32e5a2d..ba42806 Auto-merging test.md CONFLICT (content): Merge conflict in test.md error: could not revert ba42806... 4 hint: after resolving the conflicts, mark the corrected paths hint: with &#39;git add &amp;lt;paths&amp;gt;&#39; or &#39;git rm &amp;lt;paths&amp;gt;&#39; hint: and commit the result with &#39;git commit&#39; 1 2 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD 3 4 5 ======= 3 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; parent of ba42806... 4 1 2 3 psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ git add . psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ git commit -m &quot;revert 4?&quot; [1 b0c4762] revert 4? 1 file changed, 2 deletions(-) psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ git revert --continue Auto-merging test.md CONFLICT (content): Merge conflict in test.md error: could not revert b8103da... 3 hint: after resolving the conflicts, mark the corrected paths hint: with &#39;git add &amp;lt;paths&amp;gt;&#39; or &#39;git rm &amp;lt;paths&amp;gt;&#39; hint: and commit the result with &#39;git commit&#39; 1 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD 2 3 ======= 2 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; parent of b8103da... 3 1 2 psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ git add . psy02@psy-company MINGW64 ~/Desktop/root/revert (1|REVERTING) $ git commit -m &quot;revert 3??&quot; [1 9519ab2] revert 3?? 1 file changed, 1 deletion(-) psy02@psy-company MINGW64 ~/Desktop/root/revert (1) 총 2번의 과정을 거침. 비슷한점은 revert는 단일 commit를 선택할 때는 그 commit에 대해 작용하고 범위를 지정하면 시작 commit를 포함하지 않고 다음 commit부터 최근 범위로 지정된 commit를 포함해 작용함 또, 변화 과정을 보면 알겠지만 최근 변화분부터 거꾸로 하고있음. revert 결과 그럼 결과를 정리해보면 파일에 대해서는 commit때 작업만 revert함 내부에 대해서는 commit을 포함한 이후 전부 사라짐. 단 이 두 경우 모두 이 전 commit에 대해서는 관여를 안함 전자의 경우 핵전쟁 시점으로 돌아가서 핵전쟁을 멈췄어도 전쟁 흔적은 남아있는경우고 후자의 경우는 핵전생시점에서 전쟁을 멈추고 평화로워짐 단, 둘 다 역사교과서에는 핵전쟁 났다 써있음 다시, 위의 revert에서 처음에 가졌던 의문에 대해 생각해보면 예시가 좀 부적절했지만 대충 결과는 revert했을 떄 이 후 결과들이 독립젹인 다른 시행이면 살아있고 revert한 시점의 연속적인 작업물이 있다면 이후 작업물도 다 사라짐. reset vs revert 서로 해주는게 좀 다른데 reset는 HEAD를 움직여 새 HEAD그 이후 시점부터 수정을 함 수정 사항은 option에 따라 다른데 commit가 지워지는건 같음. revert는 HEAD를 움직여 새 HEAD가 가리키는 commit의 수정사항을 취소함. revert한 commit이후 서로 영향이 없는 작업을 경우 남아있고 그렇지 못한경우는 수정을 직접 확인해야하는듯하다. 범위를 지정했다면 범위의 가장 오래된 commit이후부터 범위 마지막을 포함한 commit까지… 아… 해당 commit내용을 되돌리는거면 다른 commit에서 생긴 내용은 건들 필요가 없고, 해당 commit에 영향을 받으면 물어보고? 근데 위 했던 테스트들이 확실이 이렇게 하는게 맞나는 잘 모르겠다. 이 둘의 동작상의 차이점은 위에 적은 식이고 둘은 어떤때 쓰이나 하는 말들이 참고했던 자료들 거의 마지막에 항상 따라다니던데 일단, 혼자쓸때는 별 문제 없어보임. 이 전으로 돌아가는구나, 작업내용이 없어지거나 유지되거나 하는정도. 근데 원격의 저장소를 쓸 때는 조금 다름. 원격 저장소로 push할 때 원격 저장소의 최신 commit까지의 내용이 같은게 내꺼에도 있어야함 원격에 1-2-3의 commit가 있다면 내가 올리는 commit는 1-2-3을 포함한 4-5 총 1-2-3-4-5가 되어야함. 그럼 예를들어 1-2-3-4-5를 push했다. reset의 경우 1-2-3으로 돌아와 1-2-3-4’-5’ 를 만들었다. 이건 push가 안된다. 3-4-5는 이미 원격에 있는데 지금 올리는 내용은 3-4’-5’라서. 이미 commit가 원격으로 push가 된 후라면 이전 commit는 수정하기 까다로워진다는것임. revert의 경우 1-2-3-4-5-3(revert)-4’-5’라고 수정을 하다면 push까지 가능하다. 이건 이 전의 commit에 영향을 주지 않으면서 돌아간 시점을 다른 commit으로 기록하기 때문에 원격과 로컬에 같은 commit부터 시작할 수 있기때문이다. fin 이거 다 하고도 이해가 되는듯 안되는듯함. 나중에 또 읽어보면서 수정할거 있음 계속 해야겠다.참고 1. reset과 revert git revert multiple-commits git revert로 커밋 되돌리기 What’s the difference between Git Revert, Checkout and Reset?" }, { "title": "3.basic", "url": "/posts/Git_Basic/", "categories": "Grind, Git", "tags": "git", "date": "2020-05-03 13:00:00 +0900", "snippet": "이후 방향 상태가 어떻고 하는 그런 자세한걸 쓰고싶은데 난 잘 모르니까 아는선에서 정리만하는걸로. 더 좋은게 있으면 추가. local -&amp;gt; remote 방향으로하면 git 자체 명령어도 보고 다음 gitlab이나 github같은 외부 저장소 쓰는 방법으로 확장도 좋을것같음.명령어$ git --helpusage: git [--version] [--help] [-C &amp;lt;path&amp;gt;] [-c &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;] [--exec-path[=&amp;lt;path&amp;gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&amp;lt;path&amp;gt;] [--work-tree=&amp;lt;path&amp;gt;] [--namespace=&amp;lt;name&amp;gt;] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index sparse-checkout Initialize and modify the sparse-checkoutexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and someconcept guides. See &#39;git help &amp;lt;command&amp;gt;&#39; or &#39;git help &amp;lt;concept&amp;gt;&#39;to read about a specific subcommand or concept.See &#39;git help git&#39; for an overview of the system. 이중에 clone, init, add, log, status, branch, commit, pull, push, switch 정도 많이 쓰고merge, rebase, diff 같은건 익숙해져야함.git init - 저장소 만들기 git init 하면 .git폴더가 하나 생성됨 git는 수정된 복사본을 생성하는 방식이 아니라 번경된 내용과 시점만 저장하는식으로 하는데 그 정보가 들어가는게 저 폴더인것같음. 요거 하면 그 전까지 일반 dir로 표시되던것에 (master)가 생김. psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test/Proj_1$ git initInitialized empty Git repository in D:/Workspace/Blog/git_test/Proj_1/.git/psy02@psy-aw MINGW64 /d/Workspace/Blog/git_test/Proj_1 (master)$ 이제부터 git에서 관리해주는거임git add Proj_1안에는 .git 폴더 하나만 있는데 여기 1.md 하나 생성하고 git status를 하면 $ git status On branch master No commits yet Untracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) 1.md nothing added to commit but untracked files present (use &quot;git add&quot; to track) 1.md는 Untracked file 이라 함. 말그대로 추적하지 않음. 이걸 git add하면 그때부터 알고있던 git의 기능을 쓸 수 있음 $ git add 1.md $ git status On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &amp;lt;file&amp;gt;...&quot; to unstage) new file: 1.md 이렇게 되면 이제 1.md에 대한 수정 등을 추적가능함. 위는 “git add 1.md” 해서 하나만 add했는데 “git add .” 으로 이렉터리 전체 다 add가능함. 반대로 여러 수정사항이 있는경우 commit 남길만한 것들만 add해서 관라가능.git commit commit는 게임으로치면 save. 외부 수업으로 배울때도 commit관련 내용이 많았는데 그만큼 중요함. 다시한번, 게임으로 치면 save. 띠리서 이 저장 기록으로 되돌릴수도 있고 저장기록을 지울수도, 그 저장기록까지의 내용을 합칠수도있음. 그 자세한건 나중에 더 쓰기로. 하고 일단 $ git commit 이거 하면 설치할때 기본 에디터로 지정해놓은걸로 넘어가고 commit는 commit message가 꼭 있어야 가능함. commit msg commit msg commit msg # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # On branch master # # Initial commit # # Changes to be committed: # new file: 1.md # ~ ~ commit msg가 commit message이고 나머지 아래가 그냥 생성된것들. 무튼 요거 저장하면 $ git commit [master (root-commit) 12ed4f4] commit msg commit msg commit msg 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 1.md $ git status On branch master nothing to commit, working tree clean 이렇게 빠짐. 그 아래 status에서 확인해보면 clean으로 정상적으로 다 끝난상태. 이걸 다시 확인하려면 $ git log commit 12ed4f4cde32d1d65d78883e3eead0fe63811fe9 (HEAD -&amp;gt; master) Author: psy_aw &amp;lt;psy0231@gmail.com&amp;gt; Date: Fri May 1 19:47:40 2020 +0900 commit msg commit msg commit msg 아까 남긴 commit message확인할 수 있다. 근데 이렇게 길게 남기는일이 아직 없어서git commit -m “commit message”이렇게 끝내는게 보통.cycle 위 까지의 과정이 아주 간단히 쓰는 보통 한 사이클이고 외부 저장소 없이 사용하는 경우임. init -&amp;gt; add -&amp;gt; commit 에서 이후 수정분에 대해 add -&amp;gt; commit 계속 하는식. 중간중간 계속 save point를 만들어 간다 생각하자. 그래서 보통 많이 볼 수 있는게 위 설명인데 처음 파일이 만들어지면 Untracked Untracked를 add하면 Staged이고 commit를 기다리는상태. staged를 commit 하면 Unmodified tkdxo == clean 상태라 나옴. 수정하면 Modified상테로 감. 어떤 변경 작업 시 그냥은 commit이 안되고 add를 선행해야 stage상태가 되어 commit를 할 수 있음. staged상태만 commit할수 있고 staged를 만드는게 add라고 생각하면 편한듯.상태 확인 명령어git status 또 많이 쓰는 명령어. 처음엔 파일 상태를 보는 건줄알았는데 지금 적업중인 상태를 본다는게 좀더 맞는듯함. 이거 중간중간 치면서 하면 좋다. git status -sgit log commit 기록 볼 수 있음 git log –onelinegit showgit shortlog참고 git git init git add git commit git status git log git-usage 깃(Git) 개념과 상황별 팁" }, { "title": "2.설치, 기본설정", "url": "/posts/Git_Install/", "categories": "Grind, Git", "tags": "git", "date": "2020-04-30 23:00:00 +0900", "snippet": "설치 난 윈도우만 쓰니까 일단. 근데 설치 과정을 쓰는게 의미가 있나 싶긴한데 .. 설치할 폴더. 나중에 한번 더 쓸데 있음. 그 외 옵션인데 Windows Exporer integration : 우클릭때 git보이게 Associate .git configuration files with the default text editor : git 구성파일 연결 Associate .sh files to be run with Bash : .sh 파일 연결 요정도면 되는듯 기본 편집기 선택. 환경변수 추가. : git 명령어 실행가능한곳 추가. Use Git from Git Bash only : Git bash에서만 Use Git from the Windows Command Prompt : 윈도우 cmd, powershell 가능 Use Git and optional Unix tools from the Windows Command Prompt : 윈도우 cmd에서 Git과 유닉스도구를 사용할 경우? 이거 그 줄바꿈 관련인것같은데 정확히는 모르겠고 그냥 했던것같음. 기억상 3번에서 옵션선택만 하고 나머지 쭉 next초기 설정 commit(저장) 할때는 어떤사람이 했는지 정보가 남는다. commit 0e22dbfed79c606256bf57271857380a070460adAuthor: psy_comp &amp;lt;psy0231@gmail.com&amp;gt;Date: Wed Apr 15 17:38:06 2020 +0900 asdfcommit a80018657e835f5bd5bf3f0050d55b82f4dba7f1Author: psy_aw &amp;lt;psy0231@gmail.com&amp;gt;Date: Mon Apr 13 21:39:52 2020 +0900 asdf 그럼 그 정보가 어딘가는 있어야겠지. 위를 보면 Author에 이름과 email이 있다 이걸 설정해줘야함. git config --global user.name=&quot;name&quot;git config --global user.email=&quot;name&quot;확인은 git config --list 통신방식 https 또는 ssh이 둘이 있어서 이 둘만 써보고 넘어감. https 위 초기 절정까지만 하고 push 하면 id/pw물어본다. 계정정보 입력하면 push되고 해당 사이트에도 등록이 됨. 세상에… ssh 이건 설정을 안하면 clone도 안된다. 일단 ~/.ssh로 이동, 공개키가 있나 본다. 아래는 없는상태.. 없을 경우 만들어주는데 공개키는 ssh-keygen.exe 를 실행해야함. 이건 설치폴더/usr/bin에 있음 생성위치, pw를 물어보고 생성되는데 그냥 넘기면 생성위치는 아까 처음 확인한 위치, pw는 없는상태로 생성. 다시 확인해본다. 생성된 공개키는 $ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local 이런식인데 이걸 github 또는 gitlab계정 setting하는곳에 ssh keys 에 등록하면 된다. 두 가지 방식 등록 방법을 써놨는데 뭐가 더 좋은건가 찾던 중 https를 더 추천한다고 함.1참고 Git 최초 설정 SSH 공개키 만들기 Why does GitHub recommend HTTPS over SSH? ↩" }, { "title": "1.Git", "url": "/posts/Git_Init/", "categories": "Grind, Git", "tags": "git", "date": "2020-04-29 16:00:00 +0900", "snippet": "Git 지금은 워낙 많이 쓰이기도 하고 opensource랑 엮여서 없으면 안되기도하고 쓰다보니 편하기도하고 좋고 자체에 대한 설명은 찾으면 쉽게 나오니 따로 안쓸생각인데 생각이 바뀌면 이 줄이 지워지고 항목이 추가되겠지.. 일단은 내가 이걸 왜썼는지, 쓰면서의 그 과정을 정리하고 그간 다른 수업받으면서 썼던 수업자료좀 첨가하고 다른 좋은 자료들있으면 스까쓸생각.시작은 이런 소스 관리해주는 것들을 VC 또는 VCS라 하는데 무튼 그런걸 처음부터 쓰고 있던건 아님. 그런게 있는지 알지도 못했고.. 지금도 몇몇 이름만 들어봤지 까보지도 않음 별 그지같은 상황이 많이 생김 수정사항이 짤짤이로 많이 생길때 근데 그 짤짤이가 한번에 들어오는게 아니라 시간마다, 날마다 들어옴 도트뎀이 상당히 귀찮음 이미 굴러가고있는애를 테스트 하려고 바꾸기가 좀 부담스러움 또는 해봐야 또 복사본만들어 하는건데 이게 좀 심해져서 실제 도는거 보다 이후 버전이 많아지면 ㄹㅇ 헷깔림. 위 사항때문에 복사본이 많이 생긴다해도, 일단은 한곳에 모아두고 한꺼번에 관리하고 싶었는데 집이나 회사나 같이보려면 서버가 있던지 클라우드를 쓰던지해야함. 그래서 외장하드랑 nas를 생각했는데 nas가 illamatic의 영향으로 이제 좀더 마음이 기울었고 그 외 방법이 있나 이런거 저런거 알아보는 중에 usb에 일단 임시로 갖고 다녔는데… 특별하게 일이 많은게 아니면 usb를 꽂고 콤퓨타는 켜놓고 다녔는데 어느날 누전으로 콤퓨타가 꺼지면서 usb 내용이 날아감. 다행이 복구 프로그램으로 살리긴했는데 이날 맨탈이 형태없이 박살나고 결심함 ‘분명 소스 관리해주는 무언가 있을것이다. 찾아보자’ 하고. 위처럼 불편한 점이 있었는데 vcs존재 자체를 모르기도 했고 그당시 주변에서는 쓰는사람이 없었거나 써봤는데 그냥 복사해 관리하는게 편하다고 하고 중구난방이었음. 확실한건 위와 같은 난리가 나기전에 피난처거 확실히 있어야 했고 이 전까지의 방법은 그 피난처가 절대 아닌건 확실했음.PTSD 간단해 보이고 해결하기 쉬워보이는 위 사례들을 좀 더 보자. 지속적인 수정이 이루어 지는 경우 보면 23일 전까지의 수정사항들은 직접 프로젝트 열어보기전까지는 모름. 23일부터는 프로젝트 이름에 직접 쓰는방식인데 이게 가장 최고로 좋은 최악의 예를 우연히 본게 있는데 이게 실존하더라…심지어 이게 ‘경로’가 아니라 그냥 폴더 하나 이름임. 그래서 그날의 수정사항들은 txt같은 파일 만들어 거기 적어놓고 다음에 열때 확인하던가 함… 프로젝트 일일이 열어서 확인하는시간만 줄어들지 해결책은 아님. 전체 프로젝트의 크기가 얼마나 되나 다른건 잘 본적이 없어서 모르겠는데 위와 같이 계속 복사하는식이라면 용량을 무한정 잡아먹게됨 한줄 수정에도 하나의 복사본이 생기는데 이건 극한의 효율을 뿜어내는것같음 또, 수정사항을 따로 적은 파일을 각각 적었다는것도 문제였던것이 예를들어 언젠가 reconnect method를 만들었던 날의 버전을 찾고싶다 위의 예시는 몇일 없는데 이미 4-5개월 지난뒤라면.. 서로 다른 수정사항들을 원본에 합쳐야 하는 경우 위의 예시처럼 23일 원본버전이 이미 돌고있고 그 뒤수정사항들이 생겨 테스트버전이 있다 가정함(net, log 수정) 역시 24일에도 수정사항이 있었고 심지어 25일에는 interface변경으로 25일꺼로 다 합쳐 다시 배포해야하는 상황이라면 23일 원본에 log 모듈수정, net 모듈수정 한걸 합치고 그걸 24일에 합치고 거기에 25일 수정사항을 합쳐야 한다. 그럼 아마 ‘25_통합’ 요딴거 하나 더 생길것임. 접근성 일단, 위 프로젝트를 다른 사람들과 공유하려면 공용서버에 올리던가 클라우드에 올리고 공유하던가… 문제는 또 위처럼 계속 복사하면 클라우드 용량도 쓸데없이 계속 잡아먹음. 근데 서버건 클라우드건 생각보다 저 자잘한 수정사항들을 항시 올리기 너무 귀찮던가 의미가 없게 느껴짐. 자동업로드? 행복해질까? 공동작업 프로젝트 자체 공유야 그냥 좀 귀찮다라고 하면 그만인데 이건좀 문제가 커짐. 위 모든 사례들이 혼자하는거면 그나마 이성적인 선에서 제어가 가능함. 근데 공동으로하면 행복회로가 다 타버림. 공동으로 작업하는경우 위 사진에서 log는 A가, net는 B가 수정했다치자. 이걸 A건 B건 다시 합쳐야 할꺼아님? 그럼 번경사항을 다 찾아가며 합쳐야함 winmerge같은거로 비교해가면서.. 아무리 봐도 아무리 생각해봐도 행복회로 태워봐도 안쓰는게 이상함. 아무튼 중요한건 git은 이런 문제를 다 해결해준다. 세상은 아직 살만하다.둥지 그래서 그런 툴이 없나 찾아보기 시작했는데 그 중 나온게 git이었음 여러개 더 있어서 비교글, 나온이유 등등 그런걸 좀 찾아봤는데 git이 탄생 이유도 그런고 만든분도 그렇고 어마어마해보여서 이거다 함. 써보려니 github가 많이보여 봤는데 대학때 탱크 게임 만들려고 이리저리 소스 찾아봤던게 여기서 봤던거더라.. 그니까 이미 오픈소스나 git의 맛은 보고 있었던거임 그게 포장지 맛이어서 그렇지. 보통 이런 일들을 몸소 겪기 전에 사람들은 다들 쓰고있더라 나도 기를쓰고 이거에 좀 익숙해지려는게 다시는 위와같은 상황들을 마주치기 싫어서. 근데 github는 내가 찾아볼 당시만해도 ms에 인수되기 전이었고 모든 repo는 public일때 무제한 업로드 가능이었나 그랬을꺼임… 살짝 고민을 했던게 떠다니는 설명상으론 git이라는게 참 좋은것같긴한데 막상 써본적도없고 일단 지르자니 자주 안쓰거나 다른 더 좋은 대안이 있으면 어쩌나 싶기도하고. 더 큰건 사실 회사 소스를 public으로 올리는것도 문제였고. 근데 gitlab는 똑같은데 private project도 무료임 일단 써보고 좋으면 다들 많이쓰는 github로 옮기던가 해볼생각으로 여길 거점으로 잡음. 지금 이걸 쓰고있는 날 기준으로 둘은 거의 다른점이 없음 gist도 gitlab에 snipet로 있었고 지금 쓰고있는 github pages도 gitlab pages로 같은 서비스가 있다한다. 뭘 쓰던 다 같아서 편한걸 쓰면 되는것같은데 나는 지금 쓰다보니 private project는 다 gitlab에 가있고 github에는 public만 올라갈듯? 사실 다른점이 있다면 gitlab가 사이트 반응이 좀 느림 외국섭으로 겜할때 살짝 밀리는 딱 그느낌. 참고 읽어볼만한 것들임. 깃 (소프트웨어) 오픈소스의 승리 git Book opentutorials GIT" }, { "title": "Markdown", "url": "/posts/Stub_Markdown/", "categories": "Grind, Stub", "tags": "markdown", "date": "2020-04-27 13:00:00 +0900", "snippet": "Markdown 마크업 언어의 일종으로, 존 그루버(John Gruber)와 아론 스워츠(Aaron Swartz)가 만들었다고 함. 아래 공식사이트도 저사람꺼인듯. 처음엔 뭔가 했는데 요즘엔 .txt보다 .md가 편하다. 쓰는곳이 많기도하고 대부분의 툴에서 알아먹기도 하고 쓰기쉬운데 이쁘게 써지기까지함. 공홈가보면 뭐 설치하고 어쩌고 내가 알던것보다 훨 복잡한것같은데 그냥 vs code깔고 행복하게 써야겠다. 써보면 편한데 쓰면서 문법 찾기가 귀찮음. 은 이 블로그 만든 목적이니 정리해보기로함. html 이랑 스까쓰는것같은데 몰라그런건. 나중에 필요하면 추가해봄. 문법은 공홈을 기본으로 하고 필요한거 그때그때 추가. 근데 로컬에서 쓰면서 볼때랑 웹에서 볼때랑 결과가 좀 다름 … 이건 왜이러는지 모르겠음단락, 헤더, 인용(Paragraphs, Headers, Blockquotes) 단락, 헤더는 비슷한 목적으로 쓰이는것같음 &amp;lt;h1 data-toc-skip&amp;gt;H1&amp;lt;/h1&amp;gt; &amp;lt;h2 data-toc-skip&amp;gt;H2&amp;lt;/h2&amp;gt; &amp;lt;h3 data-toc-skip&amp;gt;H3&amp;lt;/h3&amp;gt; #### H4 ##### H5 ###### H6 ####### plane text H1H2H3H4H5H6####### plane text 인용은 그저 인용 &amp;gt; 인용 쓸때 인용 쓸때 블록처리는 한텝 들어가면 해줌 아니면 내용 블록내용 다시 내용 내용 블록내용 다시 내용 줄바꿈은 spacebar 두번Line 말그대로 선긋기 위 header에서 H1은 지절로 따라옴 나머지는 ㄴㄴ *, - 최소 3개면 되고 띄어써도 알아먹음. * * * *** ***** - - - --------------------------------------- 강조(PHRASE EMPHASIS) Markdown uses asterisks(*) and underscores(_) to indicate spans *기울임* _기울임_ **Bold** __Bold__ ***스까*** ___스까___ 기울임 기울임 Bold Bold 스까 스까 LISTS Unordered (bulleted) lists use asterisks, pluses, and hyphens (*, +, and -) as list markers. These three markers are interchangable; this: 아래 같은식으로 위 문자 어떤걸 쓰던 지가 알아서 바꿔줌 tab으로 알아서 들어가면서 또 바뀜 * 집에 + 가고 - 싶다 - 지금 - 당장 - 빠르게 집에 가고 싶다 지금 당장 빠르게 Ordered (numbered) lists use regular numbers, followed by periods, as list markers: 1. 집에 2. 가면 3. 도타 오지게 해야지 1. ezwp 집에 가면 도타 오지게 해야지 ezwp 특이한건 번호 순서 상관없이 순차로 써짐. 사실 앞이 전부 1. 이어도 알아서 해줌 또 한 항목이 여러 문단으로 된 경우 저 렇게 써야함 위는 “도타” 랑 “오지게 해야지”랑 같은항목 다른 문단임. LINKS 그냥 써도 되고 앞에[ ]로 감싸면 별칭가능 http://example.com/ [example](http://example.com/) http://example.com/ example 다음처럼 쓰면 마우스 오버 팝업으로 쓸 문구 설정가능 http://example.com/ [example](http://example.com/ &quot;애지간치 사부작대네 씨벌년이&quot;) http://example.com/ example 참조형 링크(Reference-style links) 다른곳에 링크 써놓고 그 링크 참조할수 있음. 이렇게 하면 노출이 안되네 오옹 I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from Google than from Yahoo or MSN. title 속성은 선택 사항임. 링크 이름에는 문자, 숫자 및 공백이 포함될 수 있지만 대소 문자를 구분 하지 않음. I start my morning with a cup of coffee and [The New York Times][NY Times]. [ny times]: http://www.nytimes.com/ I start my morning with a cup of coffee and The New York Times. 문서 내 링크 - footnote 각주(footnote) 용도 공식적으로 되는건 아님(?) Bla bla &amp;lt;sup id=&quot;a1&quot;&amp;gt;[1](#f1)&amp;lt;/sup&amp;gt; &amp;lt;b id=&quot;f1&quot;&amp;gt;1&amp;lt;/b&amp;gt; Footnote content here. [↩](#a1) Bla bla 1 1 Footnote content here. ↩ Test 2 gitlab나 github에는 각각 전용 md 문법이 따로 더 있는것같은데 gitlab는 footnote하는게 있는것같음 근데 github엔없음 위 방법은 html 방법 스까다가 쓸수 있게 만든듯 애초에 이게 html호환 어쩌고 하면서 만들어져서 가능한가본데 암튼 다른 답변들은 footnote로 이동만 써있던데 이건 다시 돌아오는 링크까지 있어서 가져옴 IMAGES 링크랑 비슷함. local image ![avatar](../assets/img/sample/avatar.jpg &quot;Title&quot;) Reference-style: ![alt text][id] [id]: ../assets/img/sample/avatar.jpg &quot;Title&quot; Reference-style: 절대경로는 안되고 상대경로로 해야 알아먹음. 는 웹에서는 또 안보임…. web image ![avatar](https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png &quot;Title&quot;) Reference-style: ![alt text][id] [id]: https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png &quot;Title&quot; Reference-style: CODE 딴거만 써있길래 .. html 인것같은데 사실 여기 내용 잘 모르겠음 코드 쓸때 역따옴표? 세개 가 기본 옆에 언어 이름을 쓰면 그 언어에 맞게 하이라이팅(?) 해줌 언어 이름은 소문자로 해야함. 대문자로 해도 그냥 미리보기는 알아먹는것같은데 웹에서는 못하는것같음. (``` 그냥 snipet?? ```) 그냥 snipet?? c# (```c# private void mtd() { } ```) private void mtd() { } Table vertical bar 로 column 구분, 한줄이 row 굳이 column width 맞출 필요는 없음 쓸때는 좀 그래보여도 결과는 이쁨 | |ref |out| |:--- |:--- |:---| |변수 초기화 | 호출 전 초기화 | 상관없음 |변수 사용 | 사용 가능 | 사용 불가 |반환(!return)| 상관없음 | 있어야함   ref out 변수 초기화 호출 전 초기화 상관없음 변수 사용 사용 가능 사용 불가 반환(!return) 상관없음 있어야함 CheckBox 에디터상에서는 안보였는데 웹에서는 보임 vs code로 쓰는데 md 관련 확장을 안깔아서 안보이나 싶기도하고 암튼 유용함 - [ ] 가능 - [x] 쌉가능 가능 쌉가능 참고 공식 사이트 footnote 2 Test content here. ↩" }, { "title": "3. NLog", "url": "/posts/Logger_3/", "categories": "Project, Logger", "tags": "logger, c#", "date": "2020-04-22 16:00:00 +0900", "snippet": "NLog 시작 Serilog는 사용 못한다고 치고.. NLog를 찾기로함. 여기서 안되면 포기. public class logger_2{ public logger_2() { var target = new NLog.Targets.FileTarget(); target.Name = &quot;file_1&quot;; target.FileName = &quot;D:\\\\logs\\\\file_1.txt&quot;; target.Layout = &quot;${date:format=HH\\\\:MM\\\\:ss} ${logger} ${message}&quot;; var target_2 = new NLog.Targets.FileTarget(); target_2.Name = &quot;file_2&quot;; target_2.FileName = &quot;D:\\\\logs\\\\file_2.txt&quot;; target_2.Layout = &quot;${date:format=HH\\\\:MM\\\\:ss} ${logger} ${message}&quot;; var config = new NLog.Config.LoggingConfiguration(); config.AddTarget(target.Name, target); config.AddTarget(target_2.Name, target_2); var rule = new NLog.Config.LoggingRule(&quot;*&quot;, LogLevel.Info, target); var rule_2 = new NLog.Config.LoggingRule(&quot;*&quot;, LogLevel.Info, target_2); config.LoggingRules.Add(rule); config.LoggingRules.Add(rule_2); LogManager.Configuration = config; var _logger = LogManager.GetLogger(target.Name); _logger.Info(&quot;Logger1 is initialized&quot;); LogManager.Flush(); var _logger_2 = LogManager.GetLogger(target_2.Name); _logger_2.Info(&quot;Logger2 is initialized&quot;); }} 간단하게 쓰는 방법을 정리해 본건데 Serilog랑 쓰는건 비슷하기도 하고 간단해 보임. 근데 확실히 다른점이 보이는데 이 차이 때문에 이거 될것같음 느낌이 좋음 NLog는 target로 Log를 어떻게, 어디에 쓸지 정의하는데 이게 console, file, db인데 (Serilog도 쌉가능) 보기에 target를 여러개 만들수 있고 그걸 AddTarget해서 쓴다는게 확연히 달라보임. 단, config가 global인듯해보임. 결론만 말하면 위 방식대로 하면 안됨. 세상에ㅁ재댤;ㅣ좋ㅁㄷㄱ 원하는건 file_1.txt랑 file_2.txt가 각각 만들어지고 각각 따로 message를 찍을것 같은데 log내용이 아래같음. 13:04:31 file_1 Logger1 is initialized13:04:31 file_2 Logger2 is initialized file_1, file_2가 만들어지고 위 message가 둘 파일에 같이 찍힘. 근데 또 찾은 자료 중에 이렇게 하면 대충 된다고 하는걸 찾았는데1 내가 위에 한 방법에서 특별히 뭐 더 한것같지는 않은데 그냥 아무튼 안됨. 뭘 하던 저렇게 다른 파일을 상성하고 같은로그를 같이씀… 근데 나랑 같은 문제로 NLog에 issue남긴걸 봤는데2 3 4 저 세 뭉탱이가 다 관련되어 보임. 정확히 같은 이유로 같은 구조로 만들길 원했고 이슈 닫은걸로보아 해결한것같음… config 교체?? 그럼 상황에 따라 내가 쓰고싶은 Config를 AddTarget까지 해서 만들어 놓고 관리한다. -&amp;gt; 내가 쓰고싶은 Log에 맞는 config를 상황에 맞춰 NLog config에 덮어쓰고 Log를 쓴다 느낌이 좋음 public class Logger{ NLog.Config.LoggingConfiguration config; NLog.Logger logger; string logPath; string logName; //StackTrace st = new StackTrace(); //StackFrame sf = new StackFrame(1, true); string id; public Logger() { this.id = Guid.NewGuid().ToString(); config = new NLog.Config.LoggingConfiguration(); NLog.Targets.FileTarget logfile = new NLog.Targets.FileTarget(); logfile.FileName = &quot;D:\\\\logs\\\\file_1.txt&quot;; logfile.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; NLog.Targets.ConsoleTarget logconsole = new NLog.Targets.ConsoleTarget(); logconsole.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; NLog.Targets.DebuggerTarget de = new NLog.Targets.DebuggerTarget(); de.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; NLog.Targets.FileTarget logfile_2 = new NLog.Targets.FileTarget(); logfile_2.FileName = &quot;D:\\\\logs\\\\file_2.txt&quot;; logfile_2.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; config.AddRule(LogLevel.Trace, LogLevel.Fatal, logfile); config.AddRule(LogLevel.Trace, LogLevel.Fatal, logfile_2); config.AddRule(LogLevel.Trace, LogLevel.Fatal, de); config.AddTarget(this.id, logfile); // Apply config NLog.LogManager.Configuration = config; logger = NLog.LogManager.GetLogger(this.id); } public Logger(string _path, string _name) { this.id = Guid.NewGuid().ToString(); NLog.Targets.FileTarget logfile = new NLog.Targets.FileTarget(); logfile.FileName = Path.Combine(_path, _name+&quot;_${shortdate}.log&quot;); logfile.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; logfile.Name = this.id; NLog.Targets.ConsoleTarget logconsole = new NLog.Targets.ConsoleTarget(); logconsole.Layout = &quot;${longdate} ${level:uppercase=true:truncate=5} \\t ${message}&quot;; config = new NLog.Config.LoggingConfiguration(); config.AddRule(LogLevel.Trace, LogLevel.Fatal, logfile); config.AddTarget(this.id, logfile); // Apply config NLog.LogManager.Configuration = config; logger = NLog.LogManager.GetLogger(this.id); } public void LogFile(string _msg) { StackTrace st = new StackTrace(); LogManager.Configuration = this.config; LogManager.ReconfigExistingLoggers(); (LogManager.GetLogger(this.id)).Trace(&quot;[{0}][{1}]\\t&quot; + _msg, st.GetFrame(1).GetMethod().ReflectedType.Name, st.GetFrame(1).GetMethod().Name); } public void LogConsole() { }} 테스트 하다가 바꾼게 많이서 정확하진 않은데 대충 이런 컨셉인데 위 Logger class를 넣어두는 dictionary가 하나 더 있었을거임 key는 id고 value가 Logger class. 무튼 이건 내가 생각하는것처럼 동작함 끝임 근데 아니네 매쟏러 ;ㅐㄷㄱㅎ ;ㅐㅣㄹ 되는것처럼 보였는데 thread여러개 두고 테스트 해보면 가끔 A.txt에 쓰여져야할 Log가 B.Log에 쓰여짐 이 현상은 규칙성도 안보이고 간헐적이라 … 사실 써도 가끔 한두줄이긴해서 써도 될것같았는데(고민 많이함) 전에 쓰던것도 이렇게 넘어가다 프로그램이 뻗었겠지… Logfactory를 이용한 방법 여기까지 내용은 얼마 안되보이고 테스트 내용도 사실 별 어려운 내용은 아님 문제는 보통 이 문제에 대해 검색해보면 log level에 따른 분류는 많아도 그 외 의도적으로(나처럼) Log를 나누는 자료는 없었음 당장 이거하기위해 찾으면서 딱 한번 직접적으로 질문한거 딱 한번봄 안될꺼면 그냥 깔끔하게 안됐다면 포기했을텐데 file나누는건 성공하고 log를 모든파일에 동일하게 쓰거나(file이름만 다르지 내용은 같아짐) file가 안나눠지고 모든 내용이 한곳에 쓰인다거나, 로그가 섞여 쓰여지는등 됫듯말듯 안되니 내가좀 놓치고 있는게 아닌가 싶었음 여기까지 찾는데 널널하게 한달정도 삽질한듯. 그러다가 우연히 찾은게 하나 더 있는데 이건 어디서 찾았는지 출처가 없어짐………그사람들 복받았음좋겠다. 근데 아마 원래 쓸 수 있는 config랑 관계였나 그런거 찾다가 얻어걸린걸로 기억함… public void mtd_2(){ NLog.Config.LoggingConfiguration conf_1 = new NLog.Config.LoggingConfiguration(); var target_1 = new NLog.Targets.FileTarget(&quot;targtet_1&quot;); target_1.FileName = &quot;D:\\\\log\\\\1.txt&quot;; target_1.Layout = &quot;${longdate} ${uppercase:${level}} ${message}&quot;; conf_1.AddTarget(target_1); conf_1.AddRule(LogLevel.Info, LogLevel.Fatal, target_1); NLog.LogFactory fac_1 = new LogFactory(conf_1); NLog.Logger log_1 = fac_1.GetLogger(&quot;loger_1&quot;); log_1.Info(&quot;log 1&quot;); NLog.Config.LoggingConfiguration conf_2 = new NLog.Config.LoggingConfiguration(); var target_2 = new NLog.Targets.FileTarget(&quot;targtet_2&quot;); target_2.FileName = &quot;D:\\\\log\\\\2.txt&quot;; target_2.Layout = &quot;${longdate} ${uppercase:${level}} ${message}&quot;; conf_2.AddTarget(target_2); conf_2.AddRule(LogLevel.Info, LogLevel.Fatal, target_2); NLog.LogFactory fac_2 = new LogFactory(conf_2); NLog.Logger log_2 = fac_2.GetLogger(&quot;loger_2&quot;); log_2.Info(&quot;log 2&quot;);} 이렇게 쓰는데 이 전처럼 conf를 만들고 target를 등록하는것까지 같은데 이걸 바로 NLog에 넣는게 아니라 LogFactory를 만들어 LogFactory에서 Logger를 받아오는식임 그러니까 이 전위 단계 중 LogFactory가 한단계 더 들어감 이거 결과는 1.txt 생성, 2.txt생성 후 각각의 파일에 내용도 따로 쓴다. 내가 찾던거임. 여기까지 내가 쓰고자 하는거 기본은 만들어진것같음…last test 그럼 하나더 테스트. main class NLogMain { static void Main(string[] args) { Logger_4 log4 = new Logger_4(@&quot;D:\\logs&quot;, &quot;log_main&quot;); log4.info(&quot;in main, log init&quot;); temp temp = new temp(); temp_2 temp_2 = new temp_2(); Lib lib = new Lib(); } } class temp { Logger_4 log4 = new Logger_4(@&quot;D:\\logs&quot;, &quot;log_temp1&quot;); public temp() { try { ThreadStart threadStart = new ThreadStart(run); Thread th = new Thread(threadStart); th.Start(); } catch (Exception ex) { } } void run() { while (true) { Thread.Sleep(500); log4.info(&quot;temp1 msg&quot;); } } public void throwtest() { try { int i = 0; int ii = 1 / i; } catch (Exception e) { throw; } } } class temp_2 { Logger_4 log4 = new Logger_4(@&quot;D:\\logs&quot;, &quot;log_temp2&quot;); public temp_2() { ThreadStart threadStart = new ThreadStart(run); Thread th = new Thread(threadStart); th.Start(); } void run() { while (true) { Thread.Sleep(500); log4.info(&quot;temp2 msg&quot;); } } } lib public class Lib{ Logger_4 log_1 = new Logger_4(@&quot;D:\\logs&quot;, &quot;lib_1&quot;); Logger_4 log_2 = new Logger_4(@&quot;D:\\logs&quot;, &quot;lib_2&quot;); Logger_4 log_3 = new Logger_4(@&quot;D:\\logs&quot;, &quot;log_temp2&quot;); public Lib() { asdf(); ThreadStart threadStart = new ThreadStart(run); Thread th = new Thread(threadStart); th.Start(); } private void asdf() { log_1.info(&quot;lib1 msg&quot;); } void run() { while (true) { Thread.Sleep(500); log_1.info(&quot;lib1 msg&quot;); log_2.info(&quot;lib2 msg&quot;); log_3.info(&quot;lib3 msg&quot;); //break; } }} logger lib public class Logger_4{ private NLog.Logger logger; public Logger_4(string _path, string _name) { NLog.Config.LoggingConfiguration conf = new NLog.Config.LoggingConfiguration(); NLog.Targets.FileTarget target = new NLog.Targets.FileTarget(_name); target.FileName = Path.Combine(_path, _name + &quot;_${shortdate}.log&quot;); target.Layout = &quot;${longdate} ${uppercase:${level}} ${message}&quot;; conf.AddTarget(target); conf.AddRule(LogLevel.Trace, LogLevel.Fatal, target); NLog.LogFactory logfac = new LogFactory(conf); this.logger = logfac.GetLogger(_name); } public void info(string _msg) { this.logger.Info(_msg); }} 설명 main은 lib, temp1, temp2를 참조함. main, lib, temp1, temp2 는 loglib를 참조함. main은 main용 로그, temp1,2는 각각 로그를 남기고 lib는 lib1, lib2, lib3 log를 각각 남기는데 lib3은 temp2와 같은곳에 남긴다. 이지랄 떠는게 이렇게까진 쓸것같진 않은데 이렇게 비슷하게 쓰긴 했었음 결과는 잘 됨. config만 갈아끼우며 사용하는식처럼 log가 섞이지도 않음 . 드디어 이걸로 기본 준비는 다 끝난듯하다. 참고 How to Make NLog Create Separate Log per Service Thread &amp;#8617; Separate log file for specific class instance using NLog #796 &amp;#8617; File target &amp;#8617; EventProperties Layout Renderer &amp;#8617; " }, { "title": "2. Serilog", "url": "/posts/Logger_2/", "categories": "Project, Logger", "tags": "logger, c#", "date": "2020-04-17 16:00:00 +0900", "snippet": "뭘로할까? 일단 많이 보이는게 NLog, Serilog 라서 이 둘 중 하나 고르기로 함.Serilog 이걸 먼저 쓰고 있어서 내 목적에 맞게 쓸 수 있나 알아보기로 함. 쓰는건 간단했음. Log.Logger = new LoggerConfiguration() .WriteTo.File(@&quot;myapp\\log_3.txt&quot;) .CreateLogger();Log.Logger.Information(&quot;log3&quot;); 근데 Log.Logger이 static면 다르게 쓸 수 없을것같음.LoggerConfiguration을 mapping시켜 불러다 쓰는 것도 모르겠음한번 설정 하고 전역으로 저 config대로 쓸것같음. 그러다 찾은게 아래[^1] 인데 보면 using (var performanceCounters = new LoggerConfiguration() .WriteTo.File(@&quot;myapp\\log.txt&quot;) .CreateLogger()){ performanceCounters.Information(&quot;Performance is really good today ;-)&quot;); // Your app runs, then disposal of `performanceCounters` flushes any buffers} 이거 좀 더 살붙이면 될것같았는데근데 쓸때 마다 새로 만드는것도 그렇고무튼 좀 찜찜한데 더 알아보고 이방법이 상관없으면 쓰기로 하자. 둘다 비교하다 보니까 Log.Logger은 static인데 performanceCounters쓰는 아래 방식은 변수처리 되어있어 보니까Log.Logger 는 Serilog.Log이고 var performanceCounters는 형식이 Serilog.Core.Logger임 그래서 Serilog.Core.Logger logger_1 = new LoggerConfiguration() .WriteTo.File(@&quot;myapp\\log_4.txt&quot;) .CreateLogger();logger_1.Information(&quot;log4_1&quot;);Serilog.Core.Logger logger_2 = new LoggerConfiguration() .WriteTo.File(@&quot;myapp\\log_5.txt&quot;) .CreateLogger();logger_2.Information(&quot;log5_2&quot;); 이렇게 하면 완성.인줄 알았는데 logger_1과 logger_2는 같은 파일에 접근을 못하는것같음 같은 파일에 쓰면 뒤꺼가 씹힘logger_1 target file에 같이 쓰는게 아니라 logger_2가 아무 동작도 안하는듯해보임.file open상태로 잡고있나봄.. 또 하나 더 찾은것. map를 사용하는 방법. Log.Logger = new LoggerConfiguration() .WriteTo.Map(&quot;Name&quot;, &quot;Other&quot;, (name, wt) =&amp;gt; wt.File($&quot;./Logs/{name}_.txt&quot;, rollingInterval: RollingInterval.Day, outputTemplate: &quot;{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}]\\t {Message}{NewLine}&quot;)) .MinimumLevel.Verbose() .CreateLogger();Log.Information(&quot;Hello, {Name}!&quot;, &quot;Bob&quot;); 역시나 간단하다. Serilog는 전체적으로 간단해보여서 어지간하면 이걸로 쓰고싶었다.무튼 이것도 안된다.각각 파일별로 나누는건 가능한데 실제 로그를 찍을 때 내용에 꼭 {name} 이부분이 들어가야 {name}.log파일이 생성되고 그 안에 내용이 써진다.문제는 내용에도 {name}가 들어가게 된다.따라서 로그 내용이 yyyy-mm-dd HH:mm:ss.fff {name} “contents” 이런식임 {name}를 뺄 수 없었음. 빼면 default인 Other(위의경우)로 써짐. 결론 Serilog 사용 불가. stackoverflow 에 물어봤는데 “just use separate ILogger” 딱 이것만 친절히 답변달림. ㅆㅂ 그래서 이곳저곳 찾던 중 발견한게 NLog.참고 Create multiple log files using Serilog #72[^1]: Serilog : Log to different files" }, { "title": "1. Init", "url": "/posts/Logger_1/", "categories": "Project, Logger", "tags": "logger, c#", "date": "2020-04-16 16:00:00 +0900", "snippet": "Log 전에 다른사람이 만든 Logger쓰다가 프로그램이 뻗은적있음 이미 좋은 것들이 많았음 많이 쓰이고, 그만큼 많이 개발되어있음. 최소한의 검증이 모두 완료된 상태라고하고 쓸수있음. 적당히 바꿔 쓰자.목표 serilog, NLog 등의 Logger중 이 목표에 가능한거 베이스 lib로 만들고 최소한의 config만 할 수 있도록. 실제 위 로그들은 세세하게 config control 가능하나 그렇게까지 필요없음 로그 쓸때마다 새로 저걸 다 작성하기 번거로움 위 로그 다 .config로 따로 작성 가능하나 전부 없애고 코드상에서 하는걸로. class A는 log_1.txt, log_2.txt가 가능해야함 class B는 위의 log_1.txt에 작성 가능해야함. StackTrace 출력 어떤 class의 어떤 method에서 call했는지. 데이터 많을때 처리 가능 로그파일 날짜별 또는 날짜-크기별 분리 console, debug 출력은 사용 여부가 확실치 않으므로 기본 출력을 사용하되 사용 여부는 사용자가 설정함.참고 stack trace Separate log file for specific class instance using NLog Separate log file for specific class instance using NLog #796 File target EventProperties Layout Renderer Logging in multiple files using Nlog How to Make NLog Create Separate Log per Service Thread Results tagged with logging Search" }, { "title": "5. async/await_1 (sync/async, block/non-block)", "url": "/posts/CS_5_Async&Await_1/", "categories": "Grind, C#", "tags": "c#, sync_async, block_non-block, asynchronous", "date": "2020-03-13 15:00:00 +0900", "snippet": "Build Up Action/Func - Task - async/await왜? async라는 키워드를 자주 접하는것같은데막상 써본적은 적거나 저게 어떤식으로 동작하는지 몰라서 시작함 시작은 async/await를 바로 쓸라다가그 와중에 자주보이는 관련 키워드부터 해야지 싶어build up부터하다 이 지경이 됨sync/async , block/non-block 여기는 내가 이해한걸 토대로 작성함. 조금 엇나가는 주제일수도 있지만여기가 아니면 또 꺼낼 일이 없을것같아 정리함. 이 차례의 4개에 대해 설명을 많이 찾을수는 있는데조금씩 설명이 다르거나 이해하기 좀 어려웠음(시스템 콜이 어쩌고 이래서..) sync/async 이 둘의 차이점은 수행을 ‘누가’ 하냐의 관점인것같음 예를들어 ‘사과를 깎는다.’의 행위를내가 하면 sync, 동생한테 시키면 async. 명령 수행을 지시했던 thread에서 벗어나지 않고 수행을 하는경우 sync,명령 수행을 지시했던 thread에서 벗어나면(thread를 만들거나 thread pool이나 암튼 분기되면) async. 그래서 Task의 경우 async라고 했음. block/non-block 이 둘의 차이점은 명령 수행후 return의 관점인것같음. 먼저, 모든 method는 수행 결과를 caller한테 알린다고 가정함 이건 method return형, 유무의 문제가 아니라수행 그 자체(또는 그 method 뭉탱이)가 끝났다는 시그널 같은거 block은 이 시그널을 받고 다음으로 움직이고 non-block는 그냥 감 예를 들어 동생에게 사과를 깎게 시키고나는 깎인 사과가 나올때까지 멀뚱히 기다리면 block,마찬가지로 시키고 나는 게임하고 있다가다 깎았다고 하면(signal) 호다닥 갖고와 먹으면 non-block 그래서 이 전에 Task가 async이면서 block라고 했던 이유임.작업은 분기되어(async) 실행하는데끝날때까지 Wait으로 기다려(block)주고 그때까지 실제로 다음 실행도 안함. Task로 async/block의 경우를 볼수 있었고Socket.Receive()는 sync/block의 경우인데사실 보통 일반적으로 만드는 method의 형태이기도 하고.또 원래 목표인 async&amp;amp;await가 async/non-block인듯 하다.node.js도 일껄?Async이유 뭐든 반응성 좋게 할라고. ui, db, io, network … sync, block method들은 작업이 끝날때까지 기다려야 한다.시간이 좀 걸린다 싶을때 화면 멈춤현상이 이거때문. 이전 API(?)들은 기본적으로 sync/block 작성되었을꺼임.이전에는 딱히 문제가 없었는데 가면갈수록 비효율이라는것.그럼에도 이전 것들을 갈아치우지 않는 이유는기존에 너무 많은것들이 이미 그렇게 되어있어서 라는 답이있었는데…종류 APM(Asynchronous Programming Model)IAsyncResult 이용하는 애들.Begin, End접미사 들어가는 method인데 대충 옛날꺼 찾아보면 나옴.레거시. public class MyClass { public IAsyncResult BeginRead( byte [] buffer, int offset, int count, AsyncCallback callback, object state); public int EndRead(IAsyncResult asyncResult); } EAP(Event-based Asynchronous Pattern)Async접미사 있는 method.하나 이상의 이벤트, 이벤트 처리기 대리자 형식 및EventArg에서 파생된 형식도 필요.이것도 레거시. public class MyClass { public void ReadAsync(byte [] buffer, int offset, int count); public event ReadCompletedEventHandler ReadCompleted; } TAP(Task-based asynchronous pattern)async 및 await 사용. method에 Async접미사 붙은거.확실치는 않은데 위 두개는작업에 칠요한 method와는 별개로 필요한 부수적인게 있으나이거는 단일로 가능. 이라고 한다만.. 그래도 딴거보다는 간단함.권장되는 방법임. public class MyClass { public Task&amp;lt;int&amp;gt; ReadAsync(byte [] buffer, int offset, int count); } 참고로 위 셋의 기본형은 public class MyClass { public int Read(byte [] buffer, int offset, int count); } 아무튼 레거시 된것들 보면 좀 복잡함.맨첨에 공부하면서 봤을떄도 복잡해 보여서 넘겼던걸로 기억함.다만, 조금 연식이 된 코드들은 가끔 저게 보이는 경우도 있음.앞 두개는 자세히 안 할 예정이고 TAP만.참고 비동기 개요 비동기에 대한 자세한 설명 Futures and promises 비동기 프로그래밍 패턴 간편한 비동기 프로그래밍:async/await (1) 간편한 비동기 프로그래밍:async/await (2) 간편한 비동기 프로그래밍:async/await (3) 간편한 비동기 프로그래밍: async/await (4) .NET으로 병렬 프로그래밍 TPL(작업 병렬 라이브러리)" }, { "title": "4. Task_2", "url": "/posts/CS_4_Task_2/", "categories": "Grind, C#", "tags": "c#, task", "date": "2020-03-12 15:00:00 +0900", "snippet": "Build Up Action/Func - Task - async/awaitWaiting for one or more tasks to complete task는 일반적으로 thread pool의 thread에서 비동기적으로 실행되기 때문에task를 생성하고 시작하는 thread는 task가 인스턴스화되는 즉시 실행을 계속한다. 실행 흐름을 계속 이어 간다는뜻 경우에 따라 호출 스레드가 기본 응용 프로그램 스레드 인 경우작업이 실제로 실행되기 전에 앱이 종료 될 수 있다. Task_1에서 Wait();를 빼고 실행하면 볼 수 있음. 다른 경우에는 응용 프로그램의 논리에서호출 thread가 하나 이상의 작업이 실행을 완료 한 경우에만실행을 계속하도록 요구할 수 있다.하나 이상의 작업이 완료 될 때까지 대기하는 Wait 메서드를 호출하여호출 thread의 실행과 시작되는 비동기 작업을 동기화 할 수 있다. 단일 작업이 완료 될 때까지 기다리려면 해당 Task.Wait 메서드를 호출.Wait 메서드에 대한 호출은 단일 클래스 인스턴스가실행을 완료 할 때까지 호출 thread를 block.Wait() Wait() method로 task가 끝날 떄까지 무조건 대기 class Status{ public Status() { mtd_1(); } void mtd_1() { Random rand = new Random(); // Wait on a single task with no timeout specified. Task taskA = Task.Run(() =&amp;gt; Thread.Sleep(2000)); Console.WriteLine(&quot;taskA Status: {0}&quot;, taskA.Status); Thread.Sleep(1500); try { Console.WriteLine(&quot;taskA Status: {0}&quot;, taskA.Status); taskA.Wait(); Console.WriteLine(&quot;taskA Status: {0}&quot;, taskA.Status); } catch (AggregateException) { Console.WriteLine(&quot;Exception in taskA.&quot;); } } //taskA Status: WaitingToRun //taskA Status: Running //taskA Status: RanToCompletion} 작업이 완료 될 때까지 조건부로 기다릴 수도 있다. class WaitCondition{ public WaitCondition() { mtd_1(); } void mtd_1() { // Wait on a single task with a timeout specified. Task taskA = Task.Run(() =&amp;gt; Thread.Sleep(2000)); try { taskA.Wait(1000); // Wait for 1 second. bool completed = taskA.IsCompleted; Console.WriteLine(&quot;Task A completed: {0}, Status: {1}&quot;, completed, taskA.Status); if (!completed) Console.WriteLine(&quot;Timed out before task A completed.&quot;); } catch (AggregateException) { Console.WriteLine(&quot;Exception in taskA.&quot;); } } //Task A completed: False, Status: Running //Timed out before task A completed.} Wait(Int32)및 Wait(TimeSpan) 메서드는작업이 완료 되거나 시간 제한 간격이 경과할 때까지(둘 중 먼저 도달 하는 경우) 호출 스레드를 차단. 위에서는 2 초 동안 대기 하지만1 초 제한 시간 값을 정의 하는 task를 시작 하므로,호출 스레드는 제한 시간이 만료 될 때까지 차단 되고task 실행이 완료 되기 전까지 차단. WaitAny() 다수 task에서 하나의 끝을 기다릴떄 class WaitAny{ public WaitAny() { mtd_1(); } void mtd_1() { var tasks = new Task[3]; var rnd = new Random(); for (int ctr = 0; ctr &amp;lt;= 2; ctr++) tasks[ctr] = Task.Run(() =&amp;gt; Thread.Sleep(rnd.Next(500, 3000))); try { int index = Task.WaitAny(tasks); Console.WriteLine(&quot;Task #{0} completed first.\\n&quot;, tasks[index].Id); Console.WriteLine(&quot;Status of all tasks:&quot;); foreach (var t in tasks) Console.WriteLine(&quot; Task #{0}: {1}&quot;, t.Id, t.Status); } catch (AggregateException) { Console.WriteLine(&quot;An exception occurred.&quot;); } } //Task #1 completed first. //Status of all tasks: // Task #3: Running // Task #1: RanToCompletion // Task #4: Running} 여러 task중 끝나는 task가 나올때 까지 기다림. 등록된 task중 어떤것이든 상관없고 끝나는것만 알면 되는듯. WaitAll() 다수 task의 전체 종료를 기다릴떄 class WaitAll { public WaitAll() { mtd_1(); } void mtd_1() { // Wait for all tasks to complete. Task[] tasks = new Task[10]; for (int i = 0; i &amp;lt; 10; i++) { tasks[i] = Task.Run(() =&amp;gt; Thread.Sleep(2000)); } try { Task.WaitAll(tasks); } catch (AggregateException ae) { Console.WriteLine(&quot;One or more exceptions occurred: &quot;); foreach (var ex in ae.Flatten().InnerExceptions) Console.WriteLine(&quot; {0}&quot;, ex.Message); } Console.WriteLine(&quot;Status of completed tasks:&quot;); foreach (var t in tasks) Console.WriteLine(&quot; Task #{0}: {1}&quot;, t.Id, t.Status); } //Status of completed tasks: //Task #10: RanToCompletion //Task #9: RanToCompletion //Task #8: RanToCompletion //Task #7: RanToCompletion //Task #2: RanToCompletion //Task #5: RanToCompletion //Task #4: RanToCompletion //Task #6: RanToCompletion //Task #3: RanToCompletion //Task #1: RanToCompletion } throw 하나 이상의 작업이 완료 될 때까지 대기 하는 경우실행 중인 task에서 throw 되는 모든 예외가wait()을 호출 하는 thread로 전파됨. class Task_4{ public Task_4() { var tokenSource = new CancellationTokenSource(); var token = tokenSource.Token; var files = new List&amp;lt;Tuple&amp;lt;string, string, long, DateTime&amp;gt;&amp;gt;(); var t = new Task(() =&amp;gt; { string dir = &quot;C:\\\\Windows\\\\System32\\\\&quot;; object obj = new Object(); if (Directory.Exists(dir)) { Parallel.ForEach(Directory.GetFiles(dir), f =&amp;gt; { if (token.IsCancellationRequested) token.ThrowIfCancellationRequested(); var fi = new FileInfo(f); lock (obj) { files.Add(Tuple.Create(fi.Name, fi.DirectoryName, fi.Length, fi.LastWriteTimeUtc)); } }); } }, token); t.Start(); tokenSource.Cancel(); try { //await t; Console.WriteLine(&quot;Retrieved information for {0} files.&quot;, files.Count); } catch (AggregateException e) { Console.WriteLine(&quot;Exception messages:&quot;); foreach (var ie in e.InnerExceptions) Console.WriteLine(&quot; {0}: {1}&quot;, ie.GetType().Name, ie.Message); Console.WriteLine(&quot;\\nTask status: {0}&quot;, t.Status); } finally { tokenSource.Dispose(); } } //One or more exceptions occurred: // TaskCanceledException: 작업이 취소되었습니다. // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // TaskCanceledException: 작업이 취소되었습니다. // TaskCanceledException: 작업이 취소되었습니다. // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // TaskCanceledException: 작업이 취소되었습니다. // TaskCanceledException: 작업이 취소되었습니다. // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // TaskCanceledException: 작업이 취소되었습니다. //Status of tasks: // Task #12: RanToCompletion // Task #1: Canceled // Task #9: Faulted // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // Task #14: Canceled // Task #10: RanToCompletion // Task #2: Canceled // Task #7: Faulted // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // Task #15: Canceled // Task #11: RanToCompletion // Task #3: Canceled // Task #8: Faulted // NotSupportedException: 지정한 메서드가 지원되지 않습니다. // Task #13: Canceled} task 12 개. 이 중 3 개는 정상적으로 완료3 개는 예외를 throw.나머지 6 개 작업 중 3 개는 시작 하기 전에 취소 3은 실행 중에 취소. 예외는 WaitAll호출 method로 throw 되며try/catch 블록에 의해 처리. Other Wait 이거 할까 말까..Task.Wait 메서드Task 이번엔 return이 있는경우 class test_2{ public test_2() { Func&amp;lt;object, int&amp;gt; func; func = mtd; Task&amp;lt;int&amp;gt; t1 = new Task&amp;lt;int&amp;gt;(func,1); t1.Start(); Console.WriteLine(t1.Result); Task&amp;lt;int&amp;gt; t = Task&amp;lt;int&amp;gt;.Run(() =&amp;gt; { // Just loop. int max = 1000000; int ctr = 0; for (ctr = 0; ctr &amp;lt;= max; ctr++) { if (ctr == max / 2 &amp;amp;&amp;amp; DateTime.Now.Hour &amp;lt;= 12) { ctr++; break; } } return ctr; }); Console.WriteLine(&quot;Finished {0:N0} iterations.&quot;, t.Result); } int mtd(object _i) { return (int)_i + 1; }} 두 가지 경우를 보임. parameter 하나 넘기고 return 받는 경우(t1) paramerer없이 return 받는 경우(t) 근데 t의 경우 wait가 없는데 어떤 경우건 정상적으로 끝남 (지금까지는).run()다음 cw부분때문인것같음… 참고 Task Class Task Task 클래스" }, { "title": "3. Task_1", "url": "/posts/CS_3_Task_1/", "categories": "Grind, C#", "tags": "c#, task", "date": "2020-03-12 15:00:00 +0900", "snippet": "Build Up Action/Func - Task - async/await설명 값을 반환 하지 않고 비동기적으로 실행 되는 단일 작업을 나타냄. .NET Framework 4에서 처음 도입 된작업 기반 비동기 패턴 의 중심 구성 요소 중 하나. 일반적으로 main 스레드에서 동기적으로 실행되지 않고스레드 풀 스레드에서 비동기적으로 실행되므로Status, IsCancelled, IsCompleted, IsFaulted 속성을 사용하여작업의 상태를 결정할 수 있다. 가장 일반적으로 람다 표현식은 작업이 수행할 작업을 지정하는 데 사용된다. return을 받고싶으면 Task&amp;lt;TResult&amp;gt;사용. build up에 순서가 있지만 원래 async키워드를 쓰려는 과정에서이전 요소들을 확실히 쓰고 가고싶어서 이지경이 됐음.사용 근본 class Task_1{ public Task_1() { Action act = mtd; Task t = new Task(act); t.Start(); //t.Wait(); } void mtd() { Console.WriteLine(&quot;task_1&quot;); }} 이렇게하면 암껏도 안하고 끝난다.이유는 t.start(); 하고 main은 그대로 진행,task는 따로 진행해서 그런가봄.(비동기니까)t.wait();를 해야 mtd()까지 실행 한 결과를 볼 수 있다.별 다른 일 없으면 짝이라 보자 다른 방법 class Task_2{ delegate void dele(); public Task_2() { mtd_1(); } void mtd_1() { Action act_1 = () =&amp;gt; { Console.WriteLine(&quot;t_1&quot;); }; Task t_1 = Task.Factory.StartNew(act_1); t_1.Wait(); Action&amp;lt;object&amp;gt; act_2 = (object s1) =&amp;gt; { Console.WriteLine(&quot;{0}&quot;, s1); }; Task t_2 = new Task(act_2, &quot;t_2&quot;); t_2.Start(); t_2.Wait(); Task t_3 = Task.Run(() =&amp;gt; Console.WriteLine(&quot;t_3&quot;)); t_3.Wait(); Task t_4 = new Task(() =&amp;gt; { Console.WriteLine(&quot;t_4&quot;); }); t_4.RunSynchronously(); t_4.Wait(); Task t_5 = new Task(delegate { Console.WriteLine(&quot;t_5&quot;); }); t_5.Start(); t_5.Wait(); dele del = mtd_2; Task t_6 = new Task(new Action(del)); t_6.Start(); t_6.Wait(); } void mtd_2() { Console.WriteLine(&quot;t_6&quot;); }} t_1 원래 action에서 method를 연결 하는 대신저렇게 간단하게 쓰고 이 방법이 처음 설명에서 말하는람다식 사용해 표현하는 방법인데 이게 무명메서드인가… 원래 Task.Factory.StartNew(act_1); 요부분을 설명하려던건데이건 바로 실행임 .start()가 필요없음 t_2 parameter를 줘야 할때. 하나밖에 안됨.. Action&amp;lt;obj, obj&amp;gt; 이런식은 못받아줌Task parameter에 object로 받는거 state 하나밖에 없음.obj라 여러개여도 상관없긴함. 근데 이게 parameter넘길때 쓰는 올바른 방법인지 잘 모르겠음. t_3 parameter없고 return 없으면 사용할수 있는 방법 이것도 바로 실행 t_4 Task t4 is executed synchronously on the main threadby calling the RunSynchronously() method. Although the task was run synchronously,it is a good practice to wait for it in the event exceptionswere thrown by the task. 원래 방식으로 main thread에서 실행함. 이 작업에서 발생 된 이벤트 예외에 대기하는 것이 좋다. t_5 delegate 사용 1 t_6 delegate 사용 2 다른 delegate형은 안됨 예를들어 delegate void dele();/// dele del = mtd;Task ttt = new Task(del); 참고 Task Class Task Task 클래스" }, { "title": "2. Action/Func", "url": "/posts/CS_2_Action&Func/", "categories": "Grind, C#", "tags": "c#", "date": "2020-03-12 12:00:00 +0900", "snippet": "Build Up Action/Func - Task - async/awaitAction basic Encapsulates a method that has no parameters and does not return a value. public delegate void Action(); 그렇다고 한다. 그만알아보고 싶다.의문 delegate가 있는데 이걸 왜 만들었을까? 왜…. 왜…. 똑같잖아…사용 delegate니까 delegate랑 같겠지 해보자 class AT{ public AT() { Action act = mtd; act(); } public void mtd() { Console.WriteLine(&quot;cw&quot;); }} 원래 이랬을껄? class AT_1{ delegate void custom_del(); public AT_1() { custom_del custom = mtd; custom(); } public void mtd() { Console.WriteLine(&quot;cw AT_1&quot;); }}class AT_2{ delegate void custom_del(); custom_del custom; public AT_2() { custom += mtd; custom(); } public void mtd() { Console.WriteLine(&quot;cw AT_2&quot;); }} 조금씩 다른데 셋 다 비교해보자 AT는 제일 기본형태 action이고 AT_1은 그걸 단순히 delegate로 바꿔놓은것(둘이 같고 action이라는 이름만 써줬으니 원래? 형태로 써봄) AT_2는 내가 평소 쓰는 습관(혹시나 비교를 위해 - 했는데 같은거였네…) 이렇게 세개 놓고 보면 별 다른게 없음 실제 Action을 보면Action 부터Action&amp;lt;T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16&amp;gt; 까지미리 만들어 놓은거진보면짜 그런듯… AT_1 vs AT_2 둘이 다른줄 알았는데 선언을 어디 했냐가 다른거였네 AT_1의 custom은 = 만 되고AT_2의 custom은 +=가 되긴하는데 그게 선언위치 때문인듯 결론 이거 쓰는 와중에도 이전에 delegate로 쓰던 것들을Action으로 바꾸면 더 간결해질것같음을 느낌 Actino은 return이 void인 경우만 가능하다.return 을 받고싶으면 Func을 쓰면 된다한다. 사용 시 무명 메서드, 람다식을 사용해더 간단히 쓸 수 있는데 이것도 나중에 써보자. Action자체가 delegate void ~~ 로 쓰는거라 더 쓸내용은 없네Func 위에 썼듯이 Action사용에서 return이 필요하면 Func로 바꾸면 됨 간단하게 하고 넘어감 class Program{ static void Main(string[] args) { new FC(); }}class FC{ public FC() { Func&amp;lt;int&amp;gt; func = mtd; int a = func(); Console.WriteLine(a); Func&amp;lt;int, int&amp;gt; func_2 = mtd_2; int a_2 = func_2(1); Console.WriteLine(a_2); } int mtd() { return 0; } int mtd_2(int _i) { return _i+1; }} 항상 return은 기본으로 있음 형식만 지정하면 됨 마지막 parameter는 return이고마지막 제외한 patameter는 넘겨줄 값들 참고 더 좋은 설명들Action DelegateAction&amp;lt;T&amp;gt; DelegateFunc&amp;amp;ActionAction 안그래도 다 같이있긴하네 " }, { "title": "1. Parameters", "url": "/posts/CS_1_Parameters/", "categories": "Grind, C#", "tags": "c#", "date": "2020-03-10 20:00:00 +0900", "snippet": "intro method의 parameter에 대해. ref / out에서 계속 확장됨.. params, ref, out, in이 주요내용.params parameter를 가변개수의 변수가 있다고 지정. 1차원 배열만 가능 params뒤에는 추가로 parameter추가가 안됨.앞에는 상관없음. param키워드는 선언시 하나만 쓸 수 있음. ,로 구별해 넣으면 알아서 들어감.배열로 넣으면 그거 통으로 들어감(차원이 안늘어남) ex class Params{ public Params() { mtd_1(1, 2, 3); mtd_2(1, &quot;1&quot;, new SocketAsyncEventArgs(), 4.5F); int[] arr = { 1, 2, 3 }; mtd_1(arr); } public void mtd_1(params int[] _a) { Console.WriteLine(_a.Rank); Console.WriteLine(_a.Length); } public void mtd_2(params object[] _a) { foreach (object item in _a) { Console.WriteLine(item.GetType()); } }} //1//3//1//3//System.Int32//System.String//System.Net.Sockets.SocketAsyncEventArgs//System.Single Passing Parameters argument를 값 또는 참조로parameter에 전달한다. (call / pass) (by value / by reference) 형식 문제. value로 전달 일반적으로 기본 변수의 복사본을 method에 전달. value type의 변수에는 해당 데이터가 직접 포함. reference로 전달 ref, out등을 써야함. 변수에 대한 액세스 권한을 메서드에 전달. reference type의 변수에는 해당 데이터에 대한 참조가 포함. 구조체는 value type. 클래스 인스턴스는 reference type. reference type은 값으로 , 참조로 전달하는경우약간 차이가 있음. Pass a value type by value value type을 value로 넘김 호출된 method가parameter를 할당해다른 개체를 참조하는 경우변경 내용은 호출자에서 표시되지 않음. 호출된 method가parameter에서 참조하는 개체의상태를 수정하는 경우변경 내용은 호출자에서 표시되지 않음. ex int n = 5;System.Console.WriteLine(&quot;The value before calling the method: {0}&quot;, n); SquareIt(n); // Passing the variable by value.System.Console.WriteLine(&quot;The value after calling the method: {0}&quot;, n); // Keep the console window open in debug mode.System.Console.WriteLine(&quot;Press any key to exit.&quot;);System.Console.ReadKey(); static void SquareIt(int x)// The parameter x is passed by value.// Changes to x will not affect the original value of x.{ x *= x; System.Console.WriteLine(&quot;The value inside the method: {0}&quot;, x);}/* Output: The value before calling the method: 5 The value inside the method: 25 The value after calling the method: 5*/ Pass a value type by reference value type을 reference로 넘김 호출된 method가parameter를 할당해다른 개체를 참조하는 경우변경 내용은 호출자에서 표시되지 않음. ?????????? 반영되어야 정상아님? 호출된 method가parameter에서 참조하는 개체의상태를 수정하는 경우변경 내용은 호출자에서 표시됨. ex int n = 5;System.Console.WriteLine(&quot;The value before calling the method: {0}&quot;, n); SquareIt(ref n); // Passing the variable by reference.System.Console.WriteLine(&quot;The value after calling the method: {0}&quot;, n); // Keep the console window open in debug mode.System.Console.WriteLine(&quot;Press any key to exit.&quot;);System.Console.ReadKey(); static void SquareIt(ref int x)// The parameter x is passed by reference.// Changes to x will affect the original value of x.{ x *= x; System.Console.WriteLine(&quot;The value inside the method: {0}&quot;, x);}/* Output: The value before calling the method: 5 The value inside the method: 25 The value after calling the method: 25*/ Pass a reference type by value reference type을 value로 넘김 호출된 method가parameter를 할당해다른 개체를 참조하는 경우변경 사항은 호출자에게 표시되지 않음. 호출된 method가parameter에서 참조하는 개체의 상태를 수정하는 경우변경 사항은 호출자에게 표시됨. ex int[] arr = { 1, 4, 5 };System.Console.WriteLine(&quot;Inside Main, before calling the method, the first element is: {0}&quot;, arr[0]); Change(arr);System.Console.WriteLine(&quot;Inside Main, after calling the method, the first element is: {0}&quot;, arr[0]); static void Change(int[] pArray){ pArray[0] = 888; // This change affects the original element. pArray = new int[5] { -3, -1, -2, -3, -4 }; // This change is local. System.Console.WriteLine(&quot;Inside the method, the first element is: {0}&quot;, pArray[0]);}/* Output: Inside Main, before calling the method, the first element is: 1 Inside the method, the first element is: -3 Inside Main, after calling the method, the first element is: 888*/ 매개 변수가 arr에 대한 참조이므로배열 요소의 값을 변경가능. 그러나 method 내부에서 new로 새로 할당하면새 배열을 참조하게됨.이 때부터는 전달받았던 arr에 영향을 주지 않음. Pass a reference type by reference reference type를 reference로 넘김 호출된 method가parameter를 할당해다른 개체를 참조하는 경우변경 내용은 호출자에서 표시됨. 호출된 method가parameter에서 참조하는 개체의상태를 수정하는 경우변경 내용이 호출자에서 표시됨. ex int[] arr = { 1, 4, 5 };System.Console.WriteLine(&quot;Inside Main, before calling the method, the first element is: {0}&quot;, arr[0]); Change(ref arr);System.Console.WriteLine(&quot;Inside Main, after calling the method, the first element is: {0}&quot;, arr[0]); static void Change(ref int[] pArray){ // Both of the following changes will affect the original variables: pArray[0] = 888; pArray = new int[5] { -3, -1, -2, -3, -4 }; System.Console.WriteLine(&quot;Inside the method, the first element is: {0}&quot;, pArray[0]);}/* Output: Inside Main, before calling the method, the first element is: 1 Inside the method, the first element is: -3 Inside Main, after calling the method, the first element is: -3*/ in 참조전달 읽기전용 별다르게 할 수 있는 작업이 없는것같음. 일반적으로 in은 꼭 쓸 필요는 없음 int readonlyArgument = 44;InArgExample(readonlyArgument);Console.WriteLine(readonlyArgument); // value is still 44 void InArgExample(in int number){ // Uncomment the following line to see error CS8331 //number = 19;} in argument로 전달되는 변수는method에 전달되기 전에 초기화되어야 함. 호출된 method는argument에 값을 할당하거나 수정할 수 없음.참조전달 vs 읽기전용 참조전달의 경우 전달받은 method에서값변경이 일어날 경우결과가 원본에도 영향을 줬다. 참조전달의 경우 access 권한을 넘긴다했고readonly의 경우 수정을 못하게하는 특성일 때in은 둘 다 갖고있음. List&amp;lt;int&amp;gt; arr = new List&amp;lt;int&amp;gt;{ 1, 4, 5 };System.Console.WriteLine(&quot;Inside Main, before calling the method, the first element is: {0}&quot;, arr[0]); Change(in arr);System.Console.WriteLine(&quot;Inside Main, after calling the method, the first element is: {0}&quot;, arr[0]); static void Change(in List&amp;lt;int&amp;gt; pArray){ // Both of the following changes will affect the original variables: pArray[0] = 888; pArray.Add(9); foreach(var i in pArray){ Console.Write(&quot;{0} &quot;, i); } Console.WriteLine(); // pArray = new List&amp;lt;int&amp;gt;{ -3, -1, -2, -3, -4 }; System.Console.WriteLine(&quot;Inside the method, the first element is: {0}&quot;, pArray[0]);}/* Output: Inside Main, before calling the method, the first element is: 1 888 4 5 9 Inside the method, the first element is: 888 Inside Main, after calling the method, the first element is: 888*/ 참조형식을 참조로 전달의 예시에서ref를 in으로, array를 list로 변경. 메서드로 전달되는 list는 수정가능외부 원본도 변경. 메서드에서 전달받은 list를 새로 할당 불가. // pArray = new ...이 부분이문제. error CS8331: 읽기 전용 변수이므로변수 ‘in List&#39;에 할당할 수 없음. 값형식을 in으로 전달하는 경우에도 변경불가였음이 경우 값은 변경을 새로 할당으로 동작하는거면둘이 비슷해지는것같음. 아무튼 읽기전용은 새로 할당을 허용하지 않음.비유하면 malloc의 시작 포인터를 못바꾸는 느낌?ref 변수가 참조이거나 다른 개체의 별칭임을 나타냄.다음 과 같은 용도가 있다함. method 시그니처 및 메서드 호출에서인수를 메서드에 참조로 전달. method 시그니처에서 값을 호출자에게 참조로 반환. 멤버 본문에서 참조 반환 값이호출자가 수정하려는 참조로 로컬에 저장됨을 나타냄.또는 지역 변수가 참조로 다른 값에 액세스함을 나타냄. struct 선언에서 ref struct 또는readonly ref struct를 선언. 선언에서 ref struct 필드가 참조임을 선언. 참조로 argument 전달 값이아닌 참조로 전달. method 정의, 호출시 명시적으로 사용해야함. method로 전달되기 전에 초기화 해야함. 값, 참조형식을 참조로 전달에 해당하는듯. class Product{ public Product(string name, int newID) { ItemName = name; ItemID = newID; } public string ItemName { get; set; } public int ItemID { get; set; }} private static void ChangeByReference(ref Product itemRef){ // Change the address that is stored in the itemRef parameter. itemRef = new Product(&quot;Stapler&quot;, 99999); // You can change the value of one of the properties of // itemRef. The change happens to item in Main as well. itemRef.ItemID = 12345;} private static void ModifyProductsByReference(){ // Declare an instance of Product and display its initial values. Product item = new Product(&quot;Fasteners&quot;, 54321); System.Console.WriteLine(&quot;Original values in Main. Name: {0}, ID: {1}\\n&quot;, item.ItemName, item.ItemID); // Pass the product instance to ChangeByReference. ChangeByReference(ref item); System.Console.WriteLine(&quot;Back in Main. Name: {0}, ID: {1}\\n&quot;, item.ItemName, item.ItemID);} // This method displays the following output:// Original values in Main. Name: Fasteners, ID: 54321// Back in Main. Name: Stapler, ID: 12345 호출된 메서드에서 새 할당이 일어나면호출자가 참조하던것도 새 객체로 바뀜 참조 반환 값 ref return method가 호출자에게 참조로 반환. 호출자는 method에서 반환된 값을 수정할 수 있으며해당 변경 내용은 호출된 method의 개체 상태에 반영 public class Book{ public string Author; public string Title;} public class BookCollection{ private Book[] books = { new Book { Title = &quot;Call of the Wild, The&quot;, Author = &quot;Jack London&quot; }, new Book { Title = &quot;Tale of Two Cities, A&quot;, Author = &quot;Charles Dickens&quot; } }; private Book nobook = null; public ref Book GetBookByTitle(string title) { for (int ctr = 0; ctr &amp;lt; books.Length; ctr++) { if (title == books[ctr].Title) return ref books[ctr]; } return ref nobook; } public void ListBooks() { foreach (var book in books) { Console.WriteLine($&quot;{book.Title}, by {book.Author}&quot;); } Console.WriteLine(); }} void test(){ var bc = new BookCollection(); bc.ListBooks(); ref var book = ref bc.GetBookByTitle(&quot;Call of the Wild, The&quot;); if (book != null) book = new Book { Title = &quot;Republic, The&quot;, Author = &quot;Plato&quot; }; bc.ListBooks(); // The example displays the following output: // Call of the Wild, The, by Jack London // Tale of Two Cities, A, by Charles Dickens // // Republic, The, by Plato // Tale of Two Cities, A, by Charles Dickens} test() 반대로 이 예시에서 ref를 전부 지운경우 Call of the Wild, The, by Jack LondonTale of Two Cities, A, by Charles Dickens Call of the Wild, The, by Jack LondonTale of Two Cities, A, by Charles Dickens 가 출력됨 해당 차이는 if (book != null) book = new Book { Title = &quot;Republic, The&quot;, Author = &quot;Plato&quot; }; bc.ListBooks(); 이 부분 에서 확연한데ref를 쓰면 이 전 객체를 여전히 참조함. 보통은 new 로 새로 할당 안하고return 받은 객체에서 필요한걸 하지않음?? if (book != null) book.Title = &quot;Republic, The&quot;; book.Author = &quot;Plato&quot; ; 이런식으로… 참조 로컬 참조 지역 변수 return ref을 사용하여 반환된 값을 참조. ref 지역 변수는 ref 값으로 초기화 해야함.즉, 초기화의 오른쪽은 참조여야 한다. 참조 로컬 값의 수정 내용은method가 값을 참조로 반환하는 개체 상태에 반영. 따라서 return ref랑 짝으로 생각하고두 위치에 키워드를 써야함 변수 선언 앞 ref return 메서드 호출 앞 ref var book = ref bc.GetBookByTitle(&quot;Call of the Wild, The&quot;); 동일한 방법으로 참조로 값에 액세스할 수 있다.경우에 따라 참조로 값에 액세스하면비용이 많이 들 수 있는 복사 작업을 피함으로써 성능이 향상됨.예를 들어, 값을 참조하는 데 사용되는참조 지역 변수를 정의하는 방법. ref VeryLargeStruct reflocal = ref veryLargeStruct; Ref readonly 로컬 참조 읽기 전용 로컬은해당 시그니처에 ref readonly가 있고return ref를 사용하는 메서드 또는속성으로 반환된 값을 참조하는 데 사용. 변수는 ref readonly 지역 변수의ref 속성을 변수와 readonly 결합.변수는 할당된 스토리지에 대한 별칭이며 수정할 수 없음.ref 필드 ref struct유형에서 ref필드를 선언할 수 있다.ref 필드는 참조가 참조하는 객체보다 오래 지속되지 않도록ref struct유형에서만 유효.이 기능은 System.Span&amp;lt;T&amp;gt;와 같은 유형을 활성화. public readonly ref struct Span&amp;lt;T&amp;gt;{ internal readonly ref T _reference; private readonly int _length; // Omitted for brevity...} Span&amp;lt;T&amp;gt;는 액세스하는 데 사용되는 참조를 저장. 참조를 사용하면 Span&amp;lt;T&amp;gt; 개체가 참조하는저장소의 복사본을 만들지 않도록 할 수 있음. 복사작업 피해서 성능향상관련인가? out ref와 대부분 비슷함. out 인수로 전달되는 변수는method 호출에서 전달되기 전에초기화할 필요가 없지만호출된 method는 반환되기 전에값을 할당해야 한다.out 매개 변수 선언 out은여러 값을 반환하기 위한 일반적인 방법.비슷하게 튜플이 있음.튜플을 더 권장하는것같음. ref도 될 수 있겠지만method return 전에 out은 받은 parameter할당이강제적이기때문에 여기 나온듯out 인수를 사용하여 메서드 호출 out는 parameter로 전달할 때 초기화가 필요 없었음. string numberAsString = &quot;1640&quot;; //int number;if (Int32.TryParse(numberAsString, out var number)) Console.WriteLine($&quot;Converted &#39;{numberAsString}&#39; to {number}&quot;);else Console.WriteLine($&quot;Unable to convert &#39;{numberAsString}&#39;&quot;);// The example displays the following output:// Converted &#39;1640&#39; to 1640 out으로 굳이 뭘 만들어 보낼 필요가 없음.지금까지는 int number;를 선언하고 썼는데 필요없음.따라서 out으로 반환받을 데이터 형도 정할 필요가 없어짐.더 깔끔한 코드가 된다길래… in, ref, out공통 method의 매개 변수 목록에 사용되는 경우in, ref, out 키워드는 인수가 값이 아니라 참조로 전달됨을 나타냄. 이 키워드는 정식 매개 변수를 위해해당 인수의 별칭을 만드는데,이는 반드시 변수여야 한다.즉, 매개 변수에 대한 모든 작업이 인수에서 수행. 아무리봐도 뭔말인지 모르겠음 overload in, ref, out은 오버로드를 위한 method 시그니처의 일부로 간주되지 않음. 예를 들어 오버로드 할 두 method 모두 in, ref, out을 사용할 경우 오버로드 할 수 없음.(컴파일 에러) class CS0663_Example{ // Compiler error CS0663: &quot;Cannot define overloaded // methods that differ only on ref and out&quot;. public void SampleMethod(out int i) { } public void SampleMethod(ref int i) { }} 비정상 class RefOverloadExample{ public void SampleMethod(int i) { } public void SampleMethod(ref int i) { }} 정상 숨기기 또는 재정의와 같이 서명 일치가 필요한 다른 상황에서는 in, ref, out이 서명의 일부로 간주 in, ref, out을 사용 못하는 method async method yield return 또는 yield break를포함하는 반복기 method 확장 메서드에서 각각의 제한사항..차이점   in ref out 키워드 명시 선택 필수 필수 초기화 전달 전 전달 전 함수 안 수정 불가 가능 필수 참고 TryParse TryDequeue 메서드 매개 변수(C# 참조) C# 7 : ref local" }, { "title": "Design", "url": "/posts/NCC_Design/", "categories": "Project, NCC", "tags": "network, c#", "date": "2020-03-09 14:00:00 +0900", "snippet": "structure 추가, 수정사항 나중에 . 더 생각 안나 일단 마무리add more 외부에서 접근은 main에 한정적으로 하고싶음.. message는 사용자 전에 전부 쌓을생각 - message쌓일때마다 이벤트통지 저 쌓인 message들에대한 외부 접근…. message queue는?? message flow control(client to client / client to server etc)cautions accept use thread vs async Selectable accept condition?? if(rempte.ip == &quot;111.111.111.111&quot;){ accepted();}else{ acceptReject();} connector reconn - selectable connect 할때 실제 connect까지 시간이 상황마다 다름 위의 이유로 중복 실행 -&amp;gt; 확인 필요 KeepAlive connect check connect, disconnect, reconnect(start from S or C or both) and notify state or result if didnt receive any msg over some sec, then?? KeepAlive term before this, 5 secs term and 5 times count. That happens so often… ka and cnt both Receiver sometimes incoming messages are merged, (so receive big one message) message to packet(internal) " }, { "title": "NCC 시작", "url": "/posts/NCC-Init/", "categories": "Project, NCC", "tags": "network, c#", "date": "2020-03-04 17:00:00 +0900", "snippet": "배경 지금 하는것들 전부 네트워크 기반. 앞으로도. 매번 조금씩 달라지는게 싫음 or 귀찮음 ex) … lib로 좀 널널하게 만들고 가져다 썼으면 좋겠음 특히 A client-server-B client 구조가 많고 client 는 양 단에 각각 많음 A군은 2자리, B군은 3~4자리 양단 1:1 통신이나 src, dst는 매번 달라지고 broadcast는 없음. message길이도 다 다름. 연결이 끊기면 안되고 recon, 이전 연결에 대한 정리에 민감해야함 네트워크 끊김, 연결 지연에 오만 그지같은 상황이 많음 실제 환경에서 조금 더 상황을 구리게 씀… 이래야 포괄적으로 쓰이겠지 이전에 시도했던것들 아래 항목들은 딱히 테스트는 안해봤거나 깊이있게 하지 않았을거임 blocking socket 가장 간단, 보통 배울때 한번씩 해본거 그대로. C-S-C에서 C가 많아질수록 thread가 너무 많은데 이게 싫음 S입장에서 1C당 최소 1개식. -&amp;gt; 10, 20 개씩 양단에 연결된다면 30개 생성 근데 사실 thread가 한 app에 얼마나 많이 허용되는지 모름. 찾아봐도 딱히.. 특히 thread가 form에서 쓰일때랑 console에서 쓰일때랑 다른게 console는 꺼지면 다 소멸되는데 form에서는 form이 꺼져도 thread는 살아있는경우가 있었음 이래서 가급적 적게 쓰고싶음. 애초에 이런 리소스 정리 안한 내잘못이긴함 select 이건좀 가물가물함 아마 위에꺼를 벗어나고자 찾다가 얻어 걸림 배열같은거에 socket죽 늘어놓고 순회해 가면서 확인해서 받아오는식 이었던걸로 기억. 지금 기억엔 .. 1번 보는중인데 100번꺼가 들어오면 갈따까지 못봄 근데 우선순위가 더 높으면? .. 이론상 봤던게 그렇고 해결은 했던걸로 기억하는데 문제는 연결이 많아지고 구조가 복잡해지고 하면 안될것같음(진짜 잘 짜야될것같음) 그래서 포기. Begin-end(APM) 초창기에 block/nonblock, sync/async에 대해 알아볼일이 있었음 그러다 찾게됨(이거 정리 가능?) 이게 원하던 모델이었음 암튼 APM이 그 설명임. IAsyncResult BeginOperator -&amp;gt; EndOperator(IAsyncResult) 이런식이고 IAsyncResult은 정보를 갖고있음 BeginReceive가 예시. 근데 내가 이거 이해를 못함 처음에 참고했던게 좀 복잡했는데 당연했던게 예시를 위한 코드가 아니었고 이미 쓰이고 있던 것의 일부를 보다보니 그랬음. 내 기억으로는 “여기서 시작해서 (쭉 내려가더니) 여기서 끝나고 또 이걸 넘기고 이건 무슨 정보를 갖고있고 이런이런 처리 하고 끝.” 딱 이렇게 들림. select로 하던걸 못쓰게 되었고 이걸 빨리 쓸라는데 이해가 안됨 더 쉬은건 없나 찾게됨 [server] // [client] 예제 그러다가 좋은 핑계거리를 찾음 Asynchronous programming patterns Async(TAP) 위 핑계거리에 따르면 begin-end 는 레거시임 지금생각해보면 이거굳이 신경 안쓰고 했어도 된것같긴한데 android 할때 deprecated된거 쓰다가 나중에 다 빨간불 들어와서 바꿨던적이있는데 그 경험을 다시 하기 싫었음 절대. BeginRead 여기도 첫줄에 보듯이… 무튼 요걸 기반으로다가 한다. 재료 알았으면 하는 것들 socketasynceventargs async / await 키워드 맛집 SuperSocket SuperSocketLite FreeNet NetCoreServer High Performance Socket 그 외 계속 추가. 목표 배경에서의 문제점들이 없어야함. 구조적인건 나중에씀. NCC는 가제 lib로 만들고 외부에서 보이는 부분이 별로 없었으면함. 위 참고자료들에서 처리 흐름을 따르고 구조만 바꿨으면함.. 위에 다 핵심은 비슷하긴함. 쉽게. 각 개체는 연결이 일관적이지 않을 수 있음(?) conn/disconndp 에 대한 즉각반응, 상황에 따라 필요한 시간들이 다른데 이걸 어느정도 통일하고싶음 RemoteEndPoint에 대한 상태 짐작(?)(ex.Ping, KeepAlive) 여기서 message에 대한 검증을 하고 app로 순수 message를 줬으면함 -&amp;gt; 요거 전용 프로토콜 만들자는소리 이건 원래 그러긴 할텐데 필요해보임.. coap도 내 message에 coap입히고 udp입히고여기도 user message에 ncc입히고 tcp입히고 단, user입장에서 send/recv message는 원래 send/recv했던 message그 자체만 볼수있게. client는 그 수가 상관없이 message를 동시에 보낼 수 있음….보냄. 계속 추가 예정more 암호화 대용량 다른 프로토콜" }, { "title": "포스팅 방법", "url": "/posts/post-order/", "categories": "Blogging, Init", "tags": "getting started", "date": "2020-03-03 15:00:00 +0900", "snippet": "포스팅 순서 이전꺼에서는 그냥 기본 카테고리에 포스팅만 됨 확실하지 않은데 대충 이런것같음 tool/run (처음 한번만) add commit push tool/init tool/build in tool run은 local에서 할때 어쩌고 하는데 실행전 후 달라진걸 모르겠음 init는 프로젝트 구조 등 정리해준다함 _post에 새 카테고리 추가할때 이거하면 내가 일일이 categories등에 추가 할 필요없음. getting-started 설명에 Please note that the Recent Update list requires the latest git-log date of posts, thus make sure the changes in _posts have been committed before running this command. 이라 한거보면 커밋해야하는듯함 그래서 위 순서처럼 함. build를 해야 이게 알아먹는듯함 build안하면 포스팅 한게 아카이브에서는 보이는데 카테고리에선 안보임" }, { "title": "블로그 시작", "url": "/posts/init/", "categories": "Blogging, Init", "tags": "getting started", "date": "2020-03-03 15:00:00 +0900", "snippet": "목적 까먹을만한거 저장 블로그, 각 개별 프로젝트, 테스트용, 북마크, keep, sticky note 등등 새로 알게된것 그 중 알아야될것 들이 오만데 흩뿌려져 있음. 안까먹었음 좋겠음 아니면 찾기 쉽거나 프로젝트 진행 정리 프로젝트 진행 중 아이디어나 프로젝트 진행 상황?? 프로젝트에 직접 남기기는 지저분하고 특히 아카이브식으로 보면 좋겠음 찾는사람이 혹이나 있다면 내가했던 시간낭비를 누군가는 안했으면…원하는것 포스팅 쉽게 가능 근-본 다른 언어나 쓸데없는거 설치 필요없이 쉬운거 카테고리 정리 쉬울것 왼쪽, 오른쪽, 위 중 하나 네비 있었으면함 나중에 원하는자료 잘찾도록. 그나마 이래야 깔끔하고 한번이라도 더 봄. 원하는 테마가 있으면 좋고 … 스팀에 돈을 너무써서 테마만이라도 공짜였으면.. 확장성?과정 발단 블로그를 쓴적이 있었는데 재미없음(?) md가 쓰기 편한것같기도하고.. 구글링 하다보면 gitpage가 많이보여 써볼까 싶음… 익숙해질겸 웹 켜놓고 포스팅 보다 vscode 켜놓고있으면 보기에 좋아보일듯 만들기 쉽다며… 3의 조건이 없다 치고 직접 만들까 하고 참고 했던곳 blog.chulgil.me devyurim.github.io nolboo.kim 만들기는 쉬운것같은데 내가 원하는 layout을 만들기가 복잡할것같음 빨리 해치우고 빨리 쓰고싶음 문제 jekyll, ruby 등 이상한 단어들이 나오기 시작. 현기증나서 직접 만들기 포기. 만들어져있던거 쓰다보면 보이지 않을까? 전개 테마를 찾기 시작 jekyll-themes themes.jekyllrc jekyllthemes.org jekyllthemes.io jekyllthemes.dev 중복 많음 가격도 쓸만한데 내가 이거 익숙해지면 편한거 사다 쓸만한것같음 근데 보통 카테고리, 테그 정리없이 아래로 미친듯이 내려감 내가 아는게 없어서 그런듯. 암튼 싫음. 구글링 하다 걸리면 해당 포스팅만 보긴 하겠지만, 홈으로 가보면 너무 지저분함. 암튼 싫음. 몇몇 맘에 드는것 찾음 결정 : chirpy 1을 만족하는듯 보였음 2를 완벽히 만족. 딴건 조금씩 아쉬운점들이 있었음 4도 만족. 5는 원래 github page가 그런듯? 위기 설명에 Prerequisites Follow the Jekyll Docs to complete the installtion of basic environment (Ruby , RubyGems and Bundler). In order to use the script tools to save time, we also need to install Python(version 3.5 or abover) and ruamel.yaml. 가볍게 무시. 포스팅하면 카테고리, 테그 정리는 되는데 클릭해보면 URL을 못찾는지 PAGE를 못찾음. 지우고 다른 테마 찾는데 저거만한게 안보임 결말 저기서 시키는데로 함 해보자 잘됨 느낌상. ruby랑 python은 처음이라 좀 어색함 설치 기본 환경 설정은 Prerequisites Follow the Jekyll Docs to complete the installtion of basic environment (Ruby , RubyGems and Bundler). In order to use the script tools to save time, we also need to install Python(version 3.5 or abover) and ruamel.yaml. 라고 하는데 ruby는 어느 버전 이상이면 gems, bundler 같이 있다하고, python도 일정 버전 이상 pip가 동봉이란다. ruamel.yaml는 따로 설치하는데 python 설치된걸로 하면 안됨. powershell이건 cmd건 python dir까지 가서 해야함. 왜… 처음 설정 포크해오고 로컬에 받음, _config.yum 고침 .travis.yml 이랑 .github 지움 리포 루트에서 (ps)bundle install(이거 좀 걸림) (ps) tools/init.sh 포스팅 - (ps).\\tools\\build.sh commit push. 위 설명은 똑같이 나와있음 조금더 추가한정도." }, { "title": "Customize the Favicon", "url": "/posts/customize-the-favicon/", "categories": "Blogging, Tutorial", "tags": "favicon", "date": "2019-08-11 01:34:00 +0900", "snippet": "The favicons of Chirpy are placed in the directory assets/img/favicons/. You may want to replace them with your own. The following sections will guide you to create and replace the default favicons.Generate the faviconPrepare a square image (PNG, JPG, or SVG) with a size of 512x512 or more, and then go to the online tool Real Favicon Generator and click the button Select your Favicon image to upload your image file.In the next step, the webpage will show all usage scenarios. You can keep the default options, scroll to the bottom of the page, and click the button Generate your Favicons and HTML code to generate the favicon.Download &amp;amp; ReplaceDownload the generated package, unzip and delete the following two from the extracted files: browserconfig.xml site.webmanifestAnd then copy the remaining image files (PNG and ICO) to cover the original files in the directory assets/img/favicons/ of your Jekyll site. If your Jekyll site doesn’t have this directory yet, just create one.The following table will help you understand the changes to the favicon files: File(s) From Online Tool From Chirpy *.PNG ✓ ✗ *.ICO ✓ ✗ Note: ✓ means keep, ✗ means delete.The next time you build the site, the favicon will be replaced with a customized edition." }, { "title": "Getting Started", "url": "/posts/getting-started/", "categories": "Blogging, Tutorial", "tags": "getting started", "date": "2019-08-09 21:55:00 +0900", "snippet": "PrerequisitesFollow the instructions in the Jekyll Docs to complete the installation of Ruby, RubyGems, Jekyll, and Bundler.InstallationCreating a New SiteThere are two ways to create a new repository for this theme: Using the Chirpy Starter - Easy to upgrade, isolates irrelevant project files so you can focus on writing. Forking on GitHub - Convenient for custom development, but difficult to upgrade. Unless you are familiar with Jekyll and are determined to tweak or contribute to this project, this approach is not recommended.Option 1. Using the Chirpy StarterCreate a new repository from the Chirpy Starter and name it &amp;lt;GH_USERNAME&amp;gt;.github.io, where GH_USERNAME represents your GitHub username.Option 2. Forking on GitHubFork Chirpy on GitHub and rename it to &amp;lt;GH_USERNAME&amp;gt;.github.io. Please note that the default branch code is in development. If you want the site to be stable, please switch to the latest tag and start writing.And then execute:$ bash tools/init.sh Note: If you don’t want to deploy your site on GitHub Pages, append option --no-gh at the end of the above command.The above command will: Removes some files or directories from your repository: .travis.yml files under _posts folder docs If the option --no-gh is provided, the directory .github will be deleted. Otherwise, set up the GitHub Action workflow by removing the extension .hook of .github/workflows/pages-deploy.yml.hook, and then remove the other files and directories in the folder .github. Removes item Gemfile.lock from .gitignore. Creates a new commit to save the changes automatically.Installing DependenciesBefore running for the first time, go to the root directory of your site, and install dependencies as follows:$ bundleUsageConfigurationUpdate the variables of _config.yml as needed. Some of them are typical options: url avatar timezone langCustoming StylesheetIf you need to customize the stylesheet, copy the theme’s assets/css/style.scss to the same path on your Jekyll site, and then add the custom style at the end of the style file.Starting from v4.1.0, if you want to overwrite the SASS variables defined in _sass/addon/variables.scss, create a new file _sass/variables-hook.scss and assign new values to the target variable in it.Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sOr run the site on Docker with the following command:$ docker run -it --rm \\ --volume=&quot;$PWD:/srv/jekyll&quot; \\ -p 4000:4000 jekyll/jekyll \\ jekyll serveAfter a while, the local service will be published at http://127.0.0.1:4000.DeploymentBefore the deployment begins, check out the file _config.yml and make sure the url is configured correctly. Furthermore, if you prefer the project site and don’t use a custom domain, or you want to visit your website with a base URL on a web server other than GitHub Pages, remember to change the baseurl to your project name that starts with a slash, e.g, /project-name.Now you can choose ONE of the following methods to deploy your Jekyll site.Deploy by Using Github ActionsFor security reasons, GitHub Pages build runs on safe mode, which restricts us from using plugins to generate additional page files. Therefore, we can use GitHub Actions to build the site, store the built site files on a new branch, and use that branch as the source of the GitHub Pages service.Quickly check the files needed for GitHub Actions build: Ensure your Jekyll site has the file .github/workflows/pages-deploy.yml. Otherwise, create a new one and fill in the contents of the sample file, and the value of the on.push.branches should be the same as your repo’s default branch name. Ensure your Jekyll site has file tools/deploy.sh. Otherwise, copy it from here to your Jekyll site. Furthermore, if you have committed Gemfile.lock to the repo, and your runtime system is not Linux, don’t forget to update the platform list in the lock file: $ bundle lock --add-platform x86_64-linux After the above steps, rename your repository to &amp;lt;GH_USERNAME&amp;gt;.github.io on GitHub.Now publish your Jekyll site by: Push any commit to remote to trigger the GitHub Actions workflow. Once the build is complete and successful, a new remote branch named gh-pages will appear to store the built site files. Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar, and then in the section Source of GitHub Pages, select the /(root) directory of branch gh-pages as the publishing source. Remember to click Save before leaving. Visit your website at the address indicated by GitHub. Manually Build and DeployOn self-hosted servers, you cannot enjoy the convenience of GitHub Actions. Therefore, you should build the site on your local machine and then upload the site files to the server.Go to the root of the source project, and build your site as follows:$ JEKYLL_ENV=production bundle exec jekyll bOr build the site on Docker:$ docker run -it --rm \\ --env JEKYLL_ENV=production \\ --volume=&quot;$PWD:/srv/jekyll&quot; \\ jekyll/jekyll \\ jekyll buildUnless you specified the output path, the generated site files will be placed in folder _site of the project’s root directory. Now you should upload those files to the target server.UpgradingIt depends on how you use the theme: If you are using the theme gem (there will be gem &quot;jekyll-theme-chirpy&quot; in the Gemfile), editing the Gemfile and update the version number of the theme gem, for example: - gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.2&quot;, &quot;&amp;gt;= 3.2.1&quot;+ gem &quot;jekyll-theme-chirpy&quot;, &quot;~&amp;gt; 3.3&quot;, &quot;&amp;gt;= 3.3.0&quot; And then execute the following command: $ bundle update jekyll-theme-chirpy As the version upgrades, the critical files (for details, see the Startup Template) and configuration options will change. Please refer to the Upgrade Guide to keep your repo’s files in sync with the latest version of the theme. If you forked from the source project (there will be gemspec in the Gemfile of your site), then merge the latest upstream tags into your Jekyll site to complete the upgrade.The merge is likely to conflict with your local modifications. Please be patient and careful to resolve these conflicts. " }, { "title": "Writing a New Post", "url": "/posts/write-a-new-post/", "categories": "Blogging, Tutorial", "tags": "writing", "date": "2019-08-08 15:10:00 +0900", "snippet": "This post will guide you how to write a post on Chirpy theme. Even if you have previous experience with Jekyll, this article is worth reading, because many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase--- Note: The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:categories: [Animal, Insect]tags: [bee]Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:---author: name: Full Name link: https://example.com---Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsSimilar to TOC, the Disqus comments are loaded by default in each post, and the global switch is defined by variable comments in file _config.yml . If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesPreview imageIf you want to add an image to the top of the post contents, specify the attribute src, width, height, and alt for the image:---image: src: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: image alternative text---Except for alt, all other options are necessary, especially the width and height, which are related to user experience and web page loading performance. Later section “Image size” will also mention this.Starting from Chirpy v5.0.0, the attributes height and width support abbreviations: height → h, width → w.Image captionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_Image sizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image:![Desktop View](/assets/img/sample/mockup.png){: width=&quot;700&quot; height=&quot;400&quot; }Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=&quot;700&quot; h=&quot;400&quot; }Image positionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. For example: Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } Limitation: Once the position of the image is specified, the image caption should not be added.Image shadowThe screenshots of the program window can be considered to show the shadow effect, and the shadow will be visible in the light mode:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&amp;lt;img src=&quot;https://cdn.com/path/to/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Image pathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&amp;lt;img src=&quot;/img/path/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---Code BlockMarkdown symbols ``` can easily create a code block as follows:This is a plaintext code snippet.Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value``` Limitation: The Jekyll style highlight tag is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of the code block, you can append {: .nolineno} at the next line:```shellecho &#39;No more line numbers!&#39;```{: .nolineno}Specifying the FilenameYou may have noticed that the code language will be displayed on the left side of the header of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=&quot;path/to/file&quot; }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains &#39;Pack&#39; %} This product&#39;s title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." }, { "title": "Text and Typography", "url": "/posts/text-and-typography/", "categories": "Blogging, Demo", "tags": "typography", "date": "2019-08-08 12:33:00 +0900", "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.TitlesH1 - headingH2 - headingH3 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;Beside the lake, beneath the trees,Fluttering and dancing in the breeze.ListsOrdered list Firstly Secondly ThirdlyUnordered list Chapter Section Paragraph Task list TODO Completed Defeat COVID-19 Vaccine production Economic recovery People smile again Description list Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sunBlock Quote This line to shows the Block Quote.Tables Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Images Default (with caption)Full screen width and center alignment Shadowshadow effect (visible in light mode) Left aligned Float to left “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Float to right “A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space. A repetitive and meaningless text is used to fill the space.” Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1dMathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Inline codeThis is an example of Inline Code.Code blockCommonThis is a common code snippet, without syntax highlight and line number.Specific LanguagesConsole$ env |grep SHELLSHELL=/usr/local/bin/bashPYENV_SHELL=bashShellif [ $? -ne 0 ]; then echo &quot;The command was not successful.&quot;; #do the needful / exitfi;Specific filename@import &quot;colors/light-typography&quot;, &quot;colors/dark-typography&quot;Reverse Footnote The footnote source &amp;#8617; The 2nd footnote source &amp;#8617; " } ]
