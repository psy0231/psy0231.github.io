<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="async/await_2" /><meta property="og:locale" content="en" /><meta name="description" content="Asynchronous" /><meta property="og:description" content="Asynchronous" /><link rel="canonical" href="https://psy0231.github.io/posts/CS_10_Async&Await_2/" /><meta property="og:url" content="https://psy0231.github.io/posts/CS_10_Async&Await_2/" /><meta property="og:site_name" content="Null Section" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-24T18:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="async/await_2" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Asynchronous","headline":"async/await_2","dateModified":"2020-12-26T10:18:02+09:00","datePublished":"2020-12-24T18:00:00+09:00","url":"https://psy0231.github.io/posts/CS_10_Async&Await_2/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://psy0231.github.io/posts/CS_10_Async&Await_2/"},"@context":"https://schema.org"}</script><title>10. async/await_2 | Null Section</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Null Section"><meta name="application-name" content="Null Section"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">Null Section</a></div><div class="site-subtitle font-italic">nothing here.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/psy0231" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['psy0231','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>10. async/await_2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>10. async/await_2</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/username">SooyongPark</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2020-12-24 18:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 24, 2020, 6:00 PM +0900" >Dec 24, 2020</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8895 words"> <em>49 min</em> read</span></div></div></div><div class="post-content"><h2 id="asynchronous">Asynchronous<a href="#asynchronous" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="intro">intro<a href="#intro" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>다시 asynchronous programming를 async, await와 섞어서함.<li>따라서 본 내용은 이 전 async &amp; await 1 의 내용과<br /> 위의 async, await 와 중복되는 내용이 많은데,<br /> 이부분은 아래 링크에도 있듯이 서로 연결되어있거나 순환적임.<li>무튼, 계속 비슷한 내용들을 조금씩 다르게 설명하고있어서<br /> 정리는 아래 링크 기준 처음 4개를 기본으로 하고<br /> 다른 곳에 괜찮은 정리가 있으면 그걸 쓰는 방향으로.<li>확장식으로 설명을 하려고 하는데<br /> 겹치는부분이 많고 비슷한건 줄이고싶은데…</ul><h3 id="responsiveness--easy-to-write">responsiveness / easy to write<a href="#responsiveness--easy-to-write" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>일반적으로 모든 UI는 Main thread에서 처리하기 때문에<br /> Async는 UI thread에 액세스할 때<br /> 어떤 작업 결과를 UI에 반영할 때 특히 유용.<br /> 대충 의미만..<br /> 암튼 기본적으로 시간이 좀 오래 걸릴만한 작업에 유용해보임.<br /> 다만, 이 작업이 연속적으로 지속될 경우는<br /> Thread로 빼는게 일반적이었고.<li>동기식 애플리케이션에서<br /> 프로세스가 block되면 모두 block됨.<br /> 다시 말해 그냥 멈춘듯해 보임<li>비동기에서는 애플리케이션의 응답이 없을 때<br /> 프로세스가 실패했다고 결론을 내릴 수 있음.<br /> 이때 멈춘 또는 시간이 오래 걸리는 프로세스와 별개로<br /> UI thread는 반응하기때문에<br /> 해당 프로세스를 멈추거나 하는<br /> 다른 UI작업이 가능해짐.<li>async 및 await 키워드가 핵심.<br /> 이 두 키워드를 사용하면<br /> .NET Framework, .NET Core 또는 Windows 런타임의<br /> 리소스를 사용하여 쉽게 비동기 메서드를 만들 수 있다.<br /> async키워드를 사용하는 메서드를 비동기 메서드 라고 함.<li>.NET Framework 4.5 이상 및 .NET Core에는 async 및 await에 작동하는<br /> 많은 멤버가 포함되어 있는데 멤버 이름에 붙는 “Async” 접미사와<br /> Task 또는 Task&lt;TResult&gt;의 반환 형식인것들.<br /> 예를 들어, System.IO.Stream 클래스는<br /> 동기 메서드인 CopyTo, Read등과 함께<br /> 비동기 메서드인 CopyToAsync, ReadAsync등과 같은 메서드를 포함.<ul><li>async / await를 사용할라면<br /> 또는 관련 api를 사용하려면<br /> 위 버전 이상을 써야하는것같음.</ul><li>Windows 런타임에는<br /> Windows 앱에서 async 및 await와 함께 사용할 수 있는<br /> 많은 메서드도 포함되어 있다고 함.</ul><h2 id="what-happens-in-an-async-method">What happens in an async method<a href="#what-happens-in-an-async-method" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="example">example<a href="#example" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><img data-src="https://github.com/psy0231/psy0231.github.io/blob/main/postAssets/img/C%23/asaw2.png?raw=true" alt="Image" title="example" data-proofer-ignore/></ul><h3 id="위-예제-순서">위 예제 순서<a href="#위-예제-순서" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><p>호출하는 메서드는 <br /> GetUrlContentLengthAsync 비동기 메서드를 호출 후 대기.</p><li><p>GetUrlContentLengthAsync는 HttpClient 인스턴스를 만들고<br /> GetStringAsync 비동기 메서드를 호출하여<br /> 웹 사이트의 내용을 문자열로 다운로드.</p><li><p>GetStringAsync에서 특정 작업이 발생하여 진행이 일시 중단.<br /> 웹 사이트에서 다운로드 또는<br /> 다른 차단 작업을 수행할 때까지 기다려야 할 수 있음.<br /> 리소스를 차단하지 않기 위해 GetStringAsync는<br /> 해당 호출자인 GetUrlContentLengthAsync에 제어 권한을 양도.</p><p>GetStringAsync는 TResult가 문자열인<br /> Task&lt;TResult&gt;를 반환하고,<br /> GetUrlContentLengthAsync는<br /> getStringTask 변수에 작업을 할당.<br /> 이 작업은 작업이 완료될 때<br /> 실제 문자열 값을 생성하기 위한 코드와 함께<br /> GetStringAsync를 호출하는 지속적인 프로세스를 나타냄.</p><p>작업은 작업이 완료 될 때<br /> 실제 문자열 값을 생성하겠다는 약속과 함께<br /> GetStringAsync 호출에 대한 진행중인 프로세스를 나타냄.</p><li><p>getStringTask가 아직 대기되지 않았으므로<br /> 즉, 아직 await가 쓰이지 않았으므로<br /> GetUrlContentLengthAsync가<br /> GetStringAsync의 최종 결과에 무관한 다른 작업 가능.<br /> 이 경우는 DoIndependentWork()이 수행되는것.</p><li><p>DoIndependentWork는 작업을 수행하고<br /> 호출자에게 반환하는 동기 메서드.</p><li><p>GetUrlContentLengthAsync에는 더이상<br /> getStringTask의 결과 없이 수행할 수 있는 작업이 없음.<br /> 다음으로 GetUrlContentLengthAsync는<br /> 다운로드한 문자열의 길이를 계산하여 반환하려 하지만,<br /> 메서드가 문자열을 확인할 때까지 해당 값을 계산할 수 없음.</p><p>따라서 GetUrlContentLengthAsync는<br /> await 연산자를 사용해서 해당 프로세스를 일시 중단하고<br /> GetUrlContentLengthAsync를 호출한 메서드에 제어 권한 양도.<br /> GetUrlContentLengthAsync는 Task&lt;int&gt;를 호출자에게 반환.<br /> 작업은 다운로드한 문자열의 길이인<br /> 정수 결과를 만든다는 약속을 나타냄.</p><p>참고<br /> GetUrlContentLengthAsync가 await하기 전에<br /> GetStringAsync(및 getStringTask)가 완료되면<br /> GetUrlContentLengthAsync에서 컨트롤을 유지함.<br /> 호출된 비동기 프로세스 getStringTask가 이미 완료되었고<br /> GetUrlContentLengthAsync가<br /> 최종 결과를 기다릴 필요가 없는 경우 일시 중단한 다음<br /> GetUrlContentLengthAsync로 돌아가는 비용이 낭비됨.</p><p>호출하는 메서드(시작점의 calling method) 내에서<br /> 처리 패턴이 계속된다.<br /> 호출자가 해당 결과를 기다리거나 즉시 기다리기 전에<br /> GetUrlContentLengthAsync에서<br /> 결과에 의존하지 않는 다른 작업을 수행할 수 있음.<br /> 호출하는 메서드는 GetUrlContentLengthAsync를 기다리고 있으며<br /> GetUrlContentLengthAsync는 GetStringAsync를 기다리고 있음.</p><li><p>GetStringAsync가 완료되고 문자열 결과를 생성.<br /> GetStringAsync를 호출할 경우<br /> 문자열 결과가 예상대로 반환되지 않는다.<br /> (메서드가 이미 3단계에서 작업을 반환함. 먼저 끝난경우인듯.)<br /> 대신 문자열 결과는<br /> 메서드의 완료를 나타내는 작업인 getStringTask에 저장.<br /> await 연산자가 getStringTask에서 결과를 검색 하고<br /> 결과를 contents에 할당.</p><li><p>GetUrlContentLengthAsync에 문자열 결과가 있는 경우<br /> 메서드가 문자열 길이를 계산.<br /> 그런 다음 GetUrlContentLengthAsync 작업도 완료되고<br /> 대기 이벤트 처리기를 다시 시작.</p><p>동기와 차이점은<br /> 동기 메서드는 작업이 완료될 때 반환되지만(5단계)<br /> 비동기 메서드는 작업이 일시 중단될 때 반환.(3, 6단계)<br /> 비동기 메서드가 해당 작업을 완료하면<br /> 작업이 완료된 것으로 표시되고<br /> 결과가 있을 경우 작업에 저장.</p></ol><h3 id="특징">특징<a href="#특징" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>메서드 서명.<ul><li>async 한정자.<li>메서드 이름은 Async로 끝남.</ul><li>반환 형식.<ul><li>Task&lt;int&gt;(이 관련은 아래에서 다시).<li>method의 본문에서 GetStringAsync가 Task&lt;string&gt;을 반환.<br /> 즉, task를 await하면 string을 받게 됨(contents).</ul><li>그 외(flow)<ul><li>작업을 대기하기 전에 GetStringAsync의<br /> string을 사용하지 않는 작업을 수행할 수 있음.<br /> 이 경우에는 DoIndependentWork();<li>await에 대한 부분이 끝나면 그 뒤(이 전에 안한 부분) 이어서 실행</ul><li>await 연산자<ul><li>GetUrlContentLengthAsync를 일시 중단.<li>GetUrlContentLengthAsync는<br /> getStringTask가 완료될 때까지 계속할 수 없음.<li>반면 제어는 GetUrlContentLengthAsync의 호출자에 반환.<li>getStringTask가 완료되면 컨트롤이 다시 시작하고<br /> await 연산자가 getStringTask에서 string 결과를 검색.</ul><li>GetUrlContentLengthAsync에 GetStringAsync 호출과<br /> 해당 완료 대기 사이에 수행할 수 있는 작업이 없는 경우<br /> 다음 단일 문을 호출하고 대기하여 코드를 단순화할 수 있음.<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="kt">string</span> <span class="n">contents</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="s">"https://docs.microsoft.com/dotnet"</span><span class="p">);</span>
</pre></table></code></div></div></ul><h2 id="asynchronous-method">Asynchronous method<a href="#asynchronous-method" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="basic">basic.<a href="#basic" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>비동기 메서드는 하나 이상의 await를 포함하는데<br /> 이는 해당 Task가 완료 될 때까지 <br /> 메서드가 더 이상 계속될 수 없는 지점을 나타내고<br /> 여기에서 control은 호출자로 반환됨.<li>비동기 메서드에서는<br /> 제공된 키워드와 형식을 사용하여 수행 할 작업을 나타내면<br /> 컴파일러가 일시 중단 된 메서드의 대기 지점으로 제어가 반환 될 때<br /> 발생해야하는 작업을 추적하는 등 나머지 작업을 수행.<li>루프 및 예외 처리와 같은 일부 루틴 프로세스는<br /> 기존의 비동기 코드에서 처리하기 어려울 수 있음.<br /> 비동기 메서드에서는 동기 솔루션에서와 같이<br /> 필요한 만큼 이러한 요소를 작성하여 문제를 해결.</ul><h3 id="명명-규칙">명명 규칙<a href="#명명-규칙" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>일반적으로 대기 가능한 형식을 반환하는 메서드에는<br /> “Async”로 끝나는 이름을 사용.<br /> (예: Task, Task&lt;T&gt;, ValueTask, ValueTask&lt;T&gt;)<li>비동기 작업을 시작하지만 대기 가능한 형식을 반환하지 않는 메서드는<br /> “Async”로 끝나는 이름을 사용하지 않아야 하지만,<br /> “Begin”, “Start” 또는 일부 다른 동사로 시작하여 이 메서드가<br /> 작업 결과를 반환하거나 예외가 발생하지 않음을 알려야 함.<li>여기서 이벤트, 기본 클래스 또는 인터페이스 계약으로<br /> 다른 이름을 제안하는 규칙을 무시할 수 있음.<br /> 예를 들어, OnButtonClick과 같은<br /> 공용 이벤트 처리기의 이름을 변경할 수 없음.</ul><h3 id="thread">Thread<a href="#thread" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>비동기 메서드는 비차단 작업이 목적임.<br /> 비동기 메서드의 await 식은<br /> 대기한 작업이 실행되는 동안 현재 스레드를 차단하지 않고<br /> 메서드의 나머지를 연속으로 등록하고<br /> 제어 기능을 비동기 메서드 호출자에게 반환.<li>async 및 await 키워드로 인해 추가 스레드가 생성되지 않음.<br /> 비동기 메서드는 자체 스레드에서 실행되지 않으므로<br /> 다중 스레드가 필요없음.<br /> 메서드는 현재 동기화 컨텍스트에서 실행되고<br /> 메서드가 활성화된 경우에만 스레드에서 시간을 사용.<br /> Task.Run을 사용하여 CPU 바인딩 작업을<br /> 백그라운드 스레드로 이동할 수 있지만<br /> 백그라운드 스레드는 결과를 사용할 수 있을 때까지<br /> 기다리는 프로세스를 도와주지 않음.<li>비동기 프로그래밍에 대한 비동기 기반 접근 방법은<br /> 거의 모든 경우에 기존 방법보다 선호됨.<br /> 특히, 이 접근 방식은 코드가 더 간단하고<br /> 경합 조건을 방지할 필요가 없기 때문에<br /> I/O 바인딩 작업의 BackgroundWorker 클래스보다 효과적.<br /> 비동기 프로그래밍은 코드 실행에 대한 조합 세부 정보를<br /> Task.Run이 스레드 풀로 변환하는 작업과 구분하기 때문에<br /> Task.Run 메서드를 함께 사용하는 비동기 프로그래밍은<br /> CPU 바인딩 작업을 위한 BackgroundWorker보다 효과가 뛰어남.</ul><h3 id="return-types-and-parameters">Return types and parameters<a href="#return-types-and-parameters" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Task&lt;TResult&gt; 또는 Task를 반환하는 메서드를 선언하고 호출하는 방법.<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>  <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetTaskOfTResultAsync</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="kt">int</span> <span class="n">hours</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
      <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>

      <span class="k">return</span> <span class="n">hours</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">returnedTaskTResult</span> <span class="p">=</span> <span class="nf">GetTaskOfTResultAsync</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">intResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">returnedTaskTResult</span><span class="p">;</span>
  <span class="c1">// Single line</span>
  <span class="c1">// int intResult = await GetTaskOfTResultAsync();</span>

  <span class="k">async</span> <span class="n">Task</span> <span class="nf">GetTaskAsync</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
      <span class="c1">// No return statement needed</span>
  <span class="p">}</span>

  <span class="n">Task</span> <span class="n">returnedTask</span> <span class="p">=</span> <span class="nf">GetTaskAsync</span><span class="p">();</span>
  <span class="k">await</span> <span class="n">returnedTask</span><span class="p">;</span>
  <span class="c1">// Single line</span>
  <span class="k">await</span> <span class="nf">GetTaskAsync</span><span class="p">();</span>
</pre></table></code></div></div><li>비동기 메서드는 일반적으로 Task 또는 Task&lt;TResult&gt;를 반환. <br /> 비동기 메서드 내에서 await 연산자는<br /> 다른 비동기 메서드 호출에서 반환 된 작업에 적용.<li>반환 형식.<ul><li>Task&lt;TResult&gt; : 메서드에 연산자 형식이<br /> TResult인 Return 문이 있는 경우.<li>Task : 메서드에 반환 문이 포함되지 않았거나<br /> 피연산자가 없는 반환 문이 포함된 경우.<li>void : 비동기 이벤트 처리기를 작성하는 경우.<li>GetAwaiter 메서드가 포함된 모든 기타 형식.<br /> C# 7.0부터는 형식에 GetAwaiter 메서드가 포함된 경우<br /> 다른 반환 형식을 지정 가능.<br /> 예를들어 ValueTask&lt;TResult&gt;이고<br /> System.Threading.Tasks.Extension<br /> NuGet 패키지에서 사용할 수 있음.</ul><li>반환된 각 작업은 진행 중인 작업을 나타냄.<br /> 작업은 비동기 프로세스 상태에 대한 정보를 캡슐화하며,<br /> 결과적으로 프로세스의 최종 결과 또는 성공하지 못한 경우<br /> 프로세스가 발생시키는 예외에 대한 정보를 캡슐화.<li>비동기 메서드의 반환 형식은 void일 수 있습니다.<br /> 이 반환 형식(void)은 기본적으로 이벤트 처리기를 정의.<br /> 비동기 이벤트 처리기는 비동기 프로그램의 시작점 역할을 함.<li>void 반환 형식을 가진 비동기 메서드는 대기 불가.<br /> 또한 void를 반환하는 메서드의 호출자는<br /> 메서드가 throw 하는 예외 catch 못 함.<li>비동기 메서드는<ul><li>모든 in, ref 또는 out 매개 변수를 선언할 수 없지만,<br /> 이러한 매개 변수가 있는 메서드를 호출할 수는 있음.<li>참조 반환 값이 있는 메서드를 호출할 수 있지만<br /> 참조를 통해 값을 반환할 수 없다.</ul><li>자세한 내용과 예제는 비동기 반환 형식(C#)을 참조.<sup id="fnref:footnote1" role="doc-noteref"><a href="#fn:footnote1" class="footnote" rel="footnote">1</a></sup><li>비동기 메서드에서 예외를 처리하는 방법은 try-catch를 참조.<sup id="fnref:footnote2" role="doc-noteref"><a href="#fn:footnote2" class="footnote" rel="footnote">2</a></sup><li>Windows 런타임 프로그래밍의 비동기 API에는<br /> Task와 유사한 다음 반환 형식에 해당함.<ul><li>Task&lt;TResult&gt;에 해당하는 IAsyncOperation&lt;TResult&gt;<li>Task에 해당하는 IAsyncAction<li>IAsyncActionWithProgress&lt;TProgress&gt;<li>IAsyncOperationWithProgress&lt;TResult,TProgress&gt;</ul></ul><h3 id="관련-항목-및-샘플visual-studio">관련 항목 및 샘플(Visual Studio)<a href="#관련-항목-및-샘플visual-studio" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>async 및 await를 사용하여<br /> 병렬로 여러 웹 요청을 만드는 방법(C#) <sup id="fnref:footnote5" role="doc-noteref"><a href="#fn:footnote5" class="footnote" rel="footnote">3</a></sup><ul><li>동시에 여러 작업을 시작하는 방법.<li>비동기 샘플: 병렬로 여러 웹 요청 만들기</ul><li>비동기 반환 형식(C#) <sup id="fnref:footnote6" role="doc-noteref"><a href="#fn:footnote6" class="footnote" rel="footnote">4</a></sup><ul><li>비동기 메서드에서 반환할 수 있는 형식을 설명하고<br /> 각 형식이 언제 적절한가를 설명.</ul><li>신호 메커니즘으로 취소 토큰이 있는 작업 취소.<ul><li>비동기 솔루션에 다음과 같은 기능을 추가하는 방법.<ul><li>작업 목록 취소(C#) <sup id="fnref:footnote8" role="doc-noteref"><a href="#fn:footnote8" class="footnote" rel="footnote">5</a></sup><li>일정 기간 이후 작업 취소(C#) <sup id="fnref:footnote9" role="doc-noteref"><a href="#fn:footnote9" class="footnote" rel="footnote">6</a></sup><li>완료되면 비동기 작업 처리(C#) <sup id="fnref:footnote10" role="doc-noteref"><a href="#fn:footnote10" class="footnote" rel="footnote">7</a></sup></ul></ul><li>파일 액세스에 async 사용(C#) <sup id="fnref:footnote11" role="doc-noteref"><a href="#fn:footnote11" class="footnote" rel="footnote">8</a></sup><ul><li>async 및 await를 사용하여<br /> 파일에 액세스하는 이점을 나열하고 보여줌.</ul><li>TAP(작업 기반 비동기 패턴) <sup id="fnref:footnote12" role="doc-noteref"><a href="#fn:footnote12" class="footnote" rel="footnote">9</a></sup><ul><li>비동기 패턴에 대해 설명하고 패턴은<br /> Task 및 Task&lt;TResult&gt; 형식 기반.</ul><li>비동기 Channel 9 비디오 <sup id="fnref:footnote13" role="doc-noteref"><a href="#fn:footnote13" class="footnote" rel="footnote">10</a></sup><ul><li>비동기 프로그래밍에 대한<br /> 다양한 비디오로 연결되는 링크를 제공.<li>이었는데 링크 없어져서 다른거로 대체함.</ul></ul><h2 id="async-및-await">async 및 await<a href="#async-및-await" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>async 한정자를 사용해서 비동기 메서드로 지정하면<br /> 다음 두 기능 활성화.<ul><li>표시된 비동기 메서드는<br /> await를 사용하여 일시 중단 지점을 지정.<br /> await 연산자는<br /> 대기된 비동기 프로세스가 완료될 때까지<br /> 비동기 메서드가 해당 지점을 지나<br /> 계속할 수 없도록 컴파일러에 지시.<br /> 한편, 컨트롤이 비동기 메서드의 호출자로 반환.<br /> await 식에서 비동기 메서드를 일시 중단하더라도<br /> 메서드가 종료되지는 않으며 finally 블록이 실행되지 않음.<li>표시된 비동기 메서드는<br /> 이 메서드를 호출한 다른 메서드에 의해 대기할 수 있음.</ul><li>비동기 메서드는<ul><li>일반적으로 await 연산자를 하나 이상 가지고 있지만,<br /> await 식이 없는 경우<br /> 컴파일러 오류가 발생하지는 않지만 경고는 해줌.<li>await 연산자를 사용하여<br /> 일시 중단 시점을 표시하지 않는 경우<br /> 메서드가 async 한정자에 상관없이<br /> 동기 메서드가 실행되는 방식으로 실행.</ul></ul><h3 id="async">Async<a href="#async" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>async method라고 알려주는 정도.<ul><li>method, lambda expression, anonymous method에 사용 가능<li>async 키워드에서 수정하는 메서드에<br /> await 식 또는 문이 없는 경우<br /> 해당 메서드는 동기적으로 실행.<br /> await 문이 포함되지 않은 모든 비동기 메서드에서는<br /> 오류가 발생할 수 있으므로 컴파일러 경고 발생.<li>비동기 메서드는<br /> 첫 번째 await 식에 도달할 때까지 동기적으로 실행되며<br /> 이 시점에서 awawit 된 task가<br /> 완료 될 때까지 메서드가 일시 중단.<br /> 그 동안 제어는 메서드 호출자에게 반환.<li>async 키워드는<br /> 메서드, 람다 식, 무명 메서드를 수정할 때만 키워드로 사용.<br /> 다른 모든 컨텍스트에서는 식별자로 해석.</ul><li>return 형식<ul><li>Task,Task&lt;TResult&gt;<ul><li>번환 형식이 없고 / 있고 차이.<li>메소드를 호출하면 작업이 반환되지만,<br /> 작업이 완료되면<br /> 작업을 기다리는 모든 대기 표현은 무효로 평가된다.<br /> 이건잘…</ul><li>void<ul><li>호출자가 해당 메서드를 기다릴 수없고<br /> 성공적인 완료 또는 오류 조건을 보고하기 위해<br /> 다른 메커니즘을 구현해야하므로<br /> 이벤트 처리기 이외의 코드에는 일반적으로<br /> 비동기 method는 void return을 사용하지 않는 것이 좋다.<li>void return type은 주로<br /> 이벤트 핸들러를 정의하기 위해 사용하며,<br /> 여기에는 해당 반환 유형이 필요하다.<br /> void 반환 비동기 방법을 호출한 사람은 기다릴 수 없으며<br /> 비동기 방법이 throw하는 exception을 catch할 수 없다.</ul><li>C#7.0부터는 GetAwaiter<br /> (System.Threading.Tasks.ValueTask&lt;TResult&gt;)<ul><li>System.Threading.Tasks.ValueTask&lt;TResult&gt; 형식.<br /> NuGet 패키지 System.Threading.Tasks.Extensions를 추가하면 사용가능.<li>C# 7.0부터 GetAwaiter 메서드가 있는<br /> 다른 형식(일반적으로 값 형식)을<br /> 반환하여 성능이 중요한 코드 섹션에서 메모리 할당 최소화.</ul><li>in, ref, out을 parameter, return으로 사용 못함.<br /> 단, 이런 parameter가 있는 method는 호출 가능</ul></ul><h3 id="await">Await<a href="#await" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>await 연산자는<br /> 피연산자가 나타내는 비동기 작업이 완료 될 때까지<br /> 둘러싸는 비동기 메서드의 평가를 일시 중단.<li>비동기 작업이 완료되면<br /> await 연산자가 작업 결과 반환(있는 경우).<li>이미 완료된 작업을 나타내는 피연산자에<br /> await 연산자를 적용하면<br /> 둘러싸는 메서드를 중단하지 않고 즉시 작업 결과 반환.<li>await 연산자는<br /> 비동기 메서드를 평가하는 스레드를 차단하지 않음.<li>await 연산자가 바깥 쪽 비동기 메서드를 일시 중단하면<br /> 컨트롤이 메서드 호출자에게 반환.<li>ex<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Net.Http</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">AwaitOperator</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">downloading</span> <span class="p">=</span> <span class="nf">DownloadDocsMainPageAsync</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">Main</span><span class="p">)}</span><span class="s">: Launched downloading."</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">bytesLoaded</span> <span class="p">=</span> <span class="k">await</span> <span class="n">downloading</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">Main</span><span class="p">)}</span><span class="s">: Downloaded </span><span class="p">{</span><span class="n">bytesLoaded</span><span class="p">}</span><span class="s"> bytes."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">DownloadDocsMainPageAsync</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">DownloadDocsMainPageAsync</span><span class="p">)}</span><span class="s">: About to start downloading."</span><span class="p">);</span>

        <span class="kt">var</span> <span class="n">client</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>
        <span class="kt">byte</span><span class="p">[]</span> <span class="n">content</span> <span class="p">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetByteArrayAsync</span><span class="p">(</span><span class="s">"https://docs.microsoft.com/en-us/"</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">DownloadDocsMainPageAsync</span><span class="p">)}</span><span class="s">: Finished downloading."</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">content</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Output similar to:</span>
<span class="c1">// DownloadDocsMainPageAsync: About to start downloading.</span>
<span class="c1">// Main: Launched downloading.</span>
<span class="c1">// DownloadDocsMainPageAsync: Finished downloading.</span>
<span class="c1">// Main: Downloaded 27700 bytes.</span>
</pre></table></code></div></div><ul><li>HttpClient.GetByteArrayAsync 메서드는<br /> 완료시 바이트 배열을 생성하는<br /> 비동기 작업을 나타내는 Task&lt;byte []&gt; 인스턴스를 반환.<li>작업이 완료 될 때까지 await 연산자는<br /> DownloadDocsMainPageAsync 메서드를 일시 중단.<li>DownloadDocsMainPageAsync가 일시 중단되면<br /> 제어가 DownloadDocsMainPageAsync의 호출자인<br /> Main 메서드로 반환.<li>Main 메서드는<br /> DownloadDocsMainPageAsync 메서드에서 수행한<br /> 비동기 작업의 결과가 필요할 때까지 실행.<li>GetByteArrayAsync가 모든 바이트를 가져 오면<br /> 나머지 DownloadDocsMainPageAsync 메서드가 평가됨.<li>그 후 나머지 Main 메서드가 평가됨.</ul><li>await 연산자는 async 키워드로 수정된<br /> 메서드, 람다 식, 익명 메서드에서만 사용.<li>비동기 메서드 내에서<br /> 동기 함수 본문, Lock statement의 블록 내부,<br /> unsafe 컨텍스트에서 await 연산자를 사용할 수 없음.<li>await의 피연산자는 일반적으로<br /> Task, Task&lt;TResult&gt;, ValueTask, ValueTask&lt;TResult&gt; 인데<br /> 대기 가능한 모든 식은 가능하다함.<li>t 식의 형식이<ul><li><p>Task&lt;TResult&gt; 또는 ValueTask&lt;TResult&gt;이면</p><p>await t 식의 형식은 TResult.</p><li><p>Task 또는 ValueTask이면</p><p>await t 형식은 void.</p><li><p>두 경우 모두<br /> t가 예외를 throw하면<br /> await t는 예외를 다시 throw.</p></ul><li><p>Main 메서드의 await 연산자</p><p>C# 7.1부터 애플리케이션 진입점인 Main 메서드는<br /> Task 또는 Task&lt;int&gt;를 반환하여<br /> 해당 본문에서 await 연산자를 사용.</p><p>이전 C# 버전에서는 Main 메서드가<br /> 비동기 작업이 완료될 때까지<br /> 대기하는지 확인하기 위해<br /> 해당 비동기 메서드에서 반환되는<br /> Task&lt;TResult&gt; 인스턴스의<br /> Task&lt;TResult&gt;.Result 속성 값을 검색할 수 있음.</p><p>값을 생성하지 않는 비동기 작업의 경우<br /> Task.Wait 메서드를 호출할 수 있음.</p></ul><h2 id="asynchronous-programming">Asynchronous programming<a href="#asynchronous-programming" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="overview">Overview<a href="#overview" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>주로 I/O바인딩 또는 CPU바인딩때<br /> 사용하는것을 권장하고 있는데<br /> 실제 바인딩 영역은 몇가지 더 있는듯하나<sup id="fnref:footnote3" role="doc-noteref"><a href="#fn:footnote3" class="footnote" rel="footnote">11</a></sup><br /> 시간이 오래 걸릴가능성이 있는건 이 둘인듯.<li>아무튼 대부분의 경우<ul><li>I/O 바인딩된 코드에서는<br /> async 메서드의 내부에서<br /> Task 또는 Task&lt;T&gt;를 반환하는 작업을,<li>CPU 바인딩된 코드에서는<br /> Task.Run 메서드로<br /> 백그라운드 스레드에서 시작되는 작업을 기다린다.</ul><li>수행하는 작업이<br /> 어떤 바인딩인지 인식하는것이 중요하다고 하는데<br /> 코드의 성능에 큰 영향을 미치고<br /> 잠재적으로 특정 구문을 잘못 사용하게 될 수 있기 때문.<li>구별짓기 위해 고려해야하는 사항으로는<ol><li>코드가 데이터베이스의 데이터와 같은<br /> 무엇인가를 “기다리게” 되나?<ul><li>맞으면 I/O 바인딩된 작업.</ul><li>코드가 비용이 높은 계산을 수행하게 되나?<ul><li>맞으면 CPU 바인딩된 작업.</ul></ol><li>위 사항에 따라<ul><li>I/O 바인딩된 작업이 있을 경우<br /> Task.Run 없이 async 및 await를 사용.<br /> 작업 병렬 라이브러리를 사용하면 안 됨.<br /> 그 이유는 세부 비동기에 설명.(이건 나중에)<li>CPU 바인딩된 작업이 있고 빠른 응답이 필요할 경우<br /> async 및 await를 사용하지만<br /> Task.Run을 사용하여 또 다른 스레드에서 작업을 생성.<li>작업이 동시성 및 병렬 처리에 해당할 경우<br /> 작업 병렬 라이브러리를 사용할 것을 고려할 수도 있음.<li>또한 항상 코드 실행을 측정해야 함.<br /> 예를 들어 CPU 바인딩된 작업이 다중 스레딩시<br /> 컨텍스트 전환의 오버헤드에 비해<br /> 부담이 크지 않은 상황이 될 수 있음.<br /> 모든 선택에는 절충점이 있으니<br /> 상황에 맞는 올바른 절충점을 선택.</ul><li>무튼 이 부분에서 중요한 점은<ul><li>비동기 코드는 I/O 또는 CPU 바인딩된 코드에<br /> 둘 다 사용할 수 있지만<br /> 시나리오마다 다르게 사용.<li>비동기 코드는 백그라운드에서 수행되는 작업을<br /> 모델링하는데 사용되는 구문인 Task&lt;T&gt; 및 Task를 사용.<li>async 키워드는 본문에서<br /> await 키워드를 사용할 수 있는<br /> 비동기 메서드로 메서드를 변환.<li>await 키워드가 적용되면<br /> 이 키워드는 호출 메서드를 일시 중단하고<br /> 대기 작업이 완료할 때까지<br /> 제어 권한을 다시 호출자에게 양도.<li>await는 비동기 메서드 내부에서만 사용.</ul><li>백그라운드 수행<ul><li>비동기 작업과 관련하여 많은 작업을 수행함.<br /> Task 및 Task&lt;T&gt;의 백그라운드에서 수행되는 작업이 궁금하면<br /> 세부 비동기 문서에서 자세한 내용을 확인.<li>C#에서는 컴파일러가 해당 코드를,<br /> await에 도달할 때 실행을 양도하고<br /> 백그라운드 작업이 완료될 때<br /> 실행을 다시 시작하는 것과 같은<br /> 작업을 추적하는 상태 시스템으로 변환합니다.<li>이론적으로 보면 이 변환은 비동기 약속 모델.<sup id="fnref:footnote4" role="doc-noteref"><a href="#fn:footnote4" class="footnote" rel="footnote">12</a></sup></ul></ul><h3 id="상황에-따른-예">상황에 따른 예<a href="#상황에-따른-예" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>I/O 바인딩 예제: 웹 서비스에서 데이터 다운로드<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">readonly</span> <span class="n">HttpClient</span> <span class="n">_httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>

<span class="n">downloadButton</span><span class="p">.</span><span class="n">Clicked</span> <span class="p">+=</span> <span class="k">async</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// This line will yield control to the UI as the request</span>
    <span class="c1">// from the web service is happening.</span>
    <span class="c1">//</span>
    <span class="c1">// The UI thread is now free to perform other work.</span>
    <span class="kt">var</span> <span class="n">stringData</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="n">URL</span><span class="p">);</span>
    <span class="nf">DoSomethingWithData</span><span class="p">(</span><span class="n">stringData</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>단추가 눌릴 때 웹 서비스에서<br /> 일부 데이터를 다운로드해야 할 수 있지만<br /> UI 스레드를 차단하지 않음.</ul><li>CPU 바인딩 예제: 게임에 대한 계산 수행<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="n">DamageResult</span> <span class="nf">CalculateDamageDone</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Code omitted:</span>
    <span class="c1">//</span>
    <span class="c1">// Does an expensive calculation and returns</span>
    <span class="c1">// the result of that calculation.</span>
<span class="p">}</span>

<span class="n">calculateButton</span><span class="p">.</span><span class="n">Clicked</span> <span class="p">+=</span> <span class="k">async</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="c1">// This line will yield control to the UI while CalculateDamageDone()</span>
    <span class="c1">// performs its work. The UI thread is free to perform other work.</span>
    <span class="kt">var</span> <span class="n">damageResult</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">CalculateDamageDone</span><span class="p">());</span>
    <span class="nf">DisplayDamage</span><span class="p">(</span><span class="n">damageResult</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>단추를 누르면 화면의 많은 적에게<br /> 손상을 입힐 수 있는 모바일 게임을 작성할 때<br /> 손상 계산을 수행하는 것은 부담이 클 수 있고<br /> UI 스레드에서 이 작업을 수행하면<br /> 계산이 수행될 때 게임이 일시 중지되는 것처럼 보임.<li>이 작업을 처리하는 가장 좋은 방법은 Task.Run을 사용하여<br /> 작업을 수행하는 백그라운드 스레드를 시작하고<br /> await를 사용하여 결과를 기다리는 것.<br /> 이렇게 하면 작업이 수행되는 동안 UI가 매끄럽게 느껴질 수 있움.<li>이 코드는 단추 클릭 이벤트의 의도를 표현하고,<br /> 백그라운드 스레드를 수동으로 관리할 필요가 없고,<br /> 비차단 방식으로 작업을 수행.</ul><li>네트워크에서 데이터 추출<div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">readonly</span> <span class="n">HttpClient</span> <span class="n">_httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>

<span class="p">[</span><span class="n">HttpGet</span><span class="p">,</span> <span class="nf">Route</span><span class="p">(</span><span class="s">"DotNetCount"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetDotNetCount</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Suspends GetDotNetCount() to allow the caller (the web server)</span>
    <span class="c1">// to accept another request, rather than blocking on this one.</span>
    <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="s">"https://dotnetfoundation.org"</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Regex</span><span class="p">.</span><span class="nf">Matches</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s">@"\.NET"</span><span class="p">).</span><span class="n">Count</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>https://dotnetfoundation.org에서 HTML을 다운로드하고<br /> 문자열 “.NET”이 HTML에서 발생하는 횟수를 계산.<br /> 이 작업을 수행하고 횟수를 반환하는<br /> Web API 컨트롤러 메서드를 정의하기 위해<br /> ASP.NET을 사용.</ul><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">readonly</span> <span class="n">HttpClient</span> <span class="n">_httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HttpClient</span><span class="p">();</span>

<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">OnSeeTheDotNetsButtonClick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Capture the task handle here so we can await the background task later.</span>
    <span class="kt">var</span> <span class="n">getDotNetFoundationHtmlTask</span> <span class="p">=</span> <span class="n">_httpClient</span><span class="p">.</span><span class="nf">GetStringAsync</span><span class="p">(</span><span class="s">"https://dotnetfoundation.org"</span><span class="p">);</span>

    <span class="c1">// Any other work on the UI thread can be done here, such as enabling a Progress Bar.</span>
    <span class="c1">// This is important to do here, before the "await" call, so that the user</span>
    <span class="c1">// sees the progress bar before execution of this method is yielded.</span>
    <span class="n">NetworkProgressBar</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="n">NetworkProgressBar</span><span class="p">.</span><span class="n">Visibility</span> <span class="p">=</span> <span class="n">Visibility</span><span class="p">.</span><span class="n">Visible</span><span class="p">;</span>

    <span class="c1">// The await operator suspends OnSeeTheDotNetsButtonClick(), returning control to its caller.</span>
    <span class="c1">// This is what allows the app to be responsive and not block the UI thread.</span>
    <span class="kt">var</span> <span class="n">html</span> <span class="p">=</span> <span class="k">await</span> <span class="n">getDotNetFoundationHtmlTask</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="n">Regex</span><span class="p">.</span><span class="nf">Matches</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s">@"\.NET"</span><span class="p">).</span><span class="n">Count</span><span class="p">;</span>

    <span class="n">DotNetCountLabel</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="s">$"Number of .NETs on dotnetfoundation.org: </span><span class="p">{</span><span class="n">count</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>

    <span class="n">NetworkProgressBar</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="n">NetworkProgressBar</span><span class="p">.</span><span class="n">Visibility</span> <span class="p">=</span> <span class="n">Visibility</span><span class="p">.</span><span class="n">Collapsed</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>버튼이 눌릴 때 같은 작업을 수행하는<br /> 유니버설 Windows 앱용으로 작성된 동일한 시나리오.</ul><li>여러 작업이 완료될 때까지 대기<ul><li><p>동시에 데이터의 여러 부분을 검색해야 하는 상황이 될 수 있음.<br /> Task API에는 여러 백그라운드 작업에서<br /> 비차단 대기를 수행하는 비동기 코드를 작성할 수 있는<br /> Task.WhenAll 및 Task.WhenAny 메서드가 포함됨.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="nf">GetUserAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">userId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Code omitted:</span>
    <span class="c1">//</span>
    <span class="c1">// Given a user Id {userId}, retrieves a User object corresponding</span>
    <span class="c1">// to the entry in the database with {userId} as its Id.</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;</span> <span class="nf">GetUsersAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">userIds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">getUserTasks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Task</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;&gt;();</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">userId</span> <span class="k">in</span> <span class="n">userIds</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">getUserTasks</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nf">GetUserAsync</span><span class="p">(</span><span class="n">userId</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">getUserTasks</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>userId 집합에 대한 User 데이터를 확인하는 방법.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="nf">GetUserAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">userId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Code omitted:</span>
    <span class="c1">//</span>
    <span class="c1">// Given a user Id {userId}, retrieves a User object corresponding</span>
    <span class="c1">// to the entry in the database with {userId} as its Id.</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">User</span><span class="p">[</span><span class="k">]&gt;</span> <span class="nf">GetUsersAsync</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">userIds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">getUserTasks</span> <span class="p">=</span> <span class="n">userIds</span><span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">id</span> <span class="p">=&gt;</span> <span class="nf">GetUserAsync</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">WhenAll</span><span class="p">(</span><span class="n">getUserTasks</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>LINQ를 사용하여 보다 간결하게 작성하는 또 다른 방법.<li>코드 양은 더 적지만<br /> LINQ를 비동기 코드와 함께 사용할 때는 주의가 필요함.<li>LINQ는 연기된(지연) 실행을 사용하므로,<br /> .ToList() 또는 .ToArray() 호출을<br /> 반복하도록 생성된 시퀀스를 적용해야<br /> 비동기 호출이 foreach 루프에서 수행되면<br /> 즉시 비동기 호출이 발생.</ul></ul></ul><h3 id="caution">caution<a href="#caution" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>비동기 프로그래밍을 사용하는 경우<br /> 예기치 않은 동작을 방지할 수 있는 몇 가지 사항을 고려해아함.<li>async 메서드에는 본문에 await 키워드가 있어야 함.<ul><li>키워드가 없으면 일시 중단되지 않음.<br /> await가 async 메서드의 본문에 없으면<br /> C# 컴파일러가 경고를 생성하지만<br /> 코드는 동기 메서드인 것처럼 컴파일 및 실행됨.<br /> 이는 C# 컴파일러가 비동기 메서드에 대해 생성한 상태 시스템이<br /> 아무것도 수행하지 않기 때문에 매우 비효율.</ul><li>작성하는 모든 비동기 메서드 이름의 접미사로 “Async”를 추가.<ul><li>이 규칙을 .NET에서 사용하여<br /> 동기 및 비동기 메서드를 더 쉽게 구별.<li>코드에서 명시적으로 호출되지 않은 특정 메서드가<br /> 반드시 적용되는 것은 아님.<br /> (예: 이벤트 처리기 또는 웹 컨트롤러 메서드)<li>이러한 메서드는 코드에서 명시적으로 호출되지 않으므로<br /> 명시적으로 명명하는 것은 별로 중요하지 않음.</ul><li>async void는 이벤트 처리기에만 사용.<ul><li>이벤트에는 반환 형식이 없어서<br /> Task 및 Task&lt;T&gt;를 사용할 수 없으므로<br /> 비동기 이벤트는 async void 가능.<li>async void의 다른 사용은 TAP 모델을 따르지 않고<br /> 다음과 같이 사용이 어려울 수 있음.<ul><li>async void 메서드에서 throw된 예외는<br /> 해당 메서드 외부에서 catch될 수 없음.<li>async void 메서드는 테스트하기가 어려움.<li>호출자가 async void 메서드를<br /> 비동기로 예상하지 않을 경우<br /> 이러한 메서드는 의도하지 않은 <br /> 잘못된 결과를 일으킬 수 있음.</ul></ul><li>LINQ 식에서 비동기 람다를 사용할 경우 신중하게 스레드<ul><li>LINQ의 람다 식은 연기된 실행을 사용.<br /> 즉, 예상치 않은 시점에 코드 실행이 끝날 수 있다.<li>이 코드에 차단 작업을 도입하면<br /> 코드가 제대로 작성되지 않은 경우 교착 상태가 쉽게 발생.<br /> 또한 이 코드처럼 비동기 코드를 중첩하면<br /> 코드 실행에 대해 추론하기가 어려워짐.</ul><li>비차단 방식으로 작업을 기다리는 코드 작성<ul><li>Task가 완료될 때까지 대기하는 수단으로<br /> 현재 스레드를 차단하면<br /> 교착 상태가 발생하거나<br /> 컨텍스트 스레드가 차단되는 등<br /> 더 복잡한 오류 처리가 필요할 수 있음.<li><p>비차단 방식으로 작업 대기를 처리하는 방법에 대한 지침.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">사용 방법<th style="text-align: left">대체 방법<th style="text-align: left">수행할 작업<tbody><tr><td style="text-align: left">await<td style="text-align: left">Task.Wait 또는 Task.Result<td style="text-align: left">백그라운드 작업의 결과 검색<tr><td style="text-align: left">await Task.WhenAny<td style="text-align: left">Task.WaitAny<td style="text-align: left">작업이 완료될 때까지 대기<tr><td style="text-align: left">await Task.WhenAll<td style="text-align: left">Task.WaitAll<td style="text-align: left">모든 작업이 완료될 때까지 대기<tr><td style="text-align: left">await Task.Delay<td style="text-align: left">Thread.Sleep<td style="text-align: left">일정 기간 대기</table></div></ul><li>가능하면 ValueTask를 사용<ul><li>비동기 메서드에서 Task 개체를 반환하면<br /> 특정 경로에 성능 병목 현상이 발생할 수 있음.<br /> Task는 참조 형식이므로<br /> 이를 사용하는 것은 개체 할당을 의미.<li>async 한정자로 선언된 메서드가<br /> 캐시된 결과를 반환하거나 동기적으로 완료된 경우<br /> 코드의 성능이 중요한 섹션에서<br /> 추가 할당에 상당한 시간이 소요될 수 있음.<li>연속 루프에서 이러한 할당이 발생하면 부담이 될 수 있음.<br /> 자세한 내용은 일반화된 비동기 반환 형식을 참조.</ul><li>ConfigureAwait(false)를 사용<ul><li>일반적인 질문은<br /> “언제 Task.ConfigureAwait(Boolean) 메서드를 사용해야 하는가”.<li>이 메서드를 사용하면<br /> Task 인스턴스가 awaiter를 구성할 수 있음.<br /> 다만 잘못 설정할 경우 성능에 영향을 미칠 수 있고<br /> 심지어 교착 상태가 발생할 수도 있음.<br /> ConfigureAwait에 대한 자세한 내용은 ConfigureAwait FAQ를 참조.</ul><li>상태 저장 코드 작성 분량 감소<ul><li>전역 개체의 상태나 특정 메서드의 실행이 아닌<br /> 메서드의 반환 값에만 의존.<br /> 그 이유로는<ul><li>코드를 더 쉽게 추론할 수 있다.<li>코드를 더 쉽게 테스트할 수 있다.<li>비동기 및 동기 코드를 훨씬 더 쉽게 혼합할 수 있다.<li>일반적으로 함께 경합 상태를 피할 수 있다.<li>반환 값에 의존하면 비동기 코드를 간단히 조정할 수 있다.<li>(이점) 이 방법은 실제로 종속성 주입에도 잘 작동.</ul></ul><li>권장되는 목적은 코드에서 완전하거나<br /> 거의 완전한 참조 투명성을 달성하는 것.<br /> 이렇게 하면 확실히 예측 가능하고,<br /> 테스트 가능하고, 유지 관리 가능한<br /> 코드베이스가 생성.</ul><h2 id="참고">참고<a href="#참고" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model">작업 비동기 프로그래밍 모델</a><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/async">비동기 프로그래밍</a><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/async">async</a><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/operators/await">await</a><li><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/">async 및 await를 사용한 비동기 프로그래밍</a><li><a href="http://www.csharpstudy.com/CSharp/CSharp-async-await.aspx">C# 5.0 : async / await 키워드</a><li><a href="https://stackoverflow.com/questions/9519414/whats-the-difference-between-task-start-wait-and-async-await">What’s the difference between Task.Start/Wait and Async/Await?</a><li><a href="https://docs.microsoft.com/ko-kr/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">작업 기반 비동기 패턴</a></ul><div class="footnotes" role="doc-endnotes"><ol><li id="fn:footnote1" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/async-return-types">비동기 반환 형식(C#)</a> <a href="#fnref:footnote1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote2" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/try-catch">try-catch(C# 참조)</a> <a href="#fnref:footnote2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote5" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/">async 및 await를 사용한 비동기 프로그래밍</a> <a href="#fnref:footnote5" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote6" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/async-return-types">비동기 반환 형식(C#)</a> <a href="#fnref:footnote6" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote8" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/cancel-an-async-task-or-a-list-of-tasks">작업 목록 취소(C#)</a> <a href="#fnref:footnote8" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote9" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/cancel-async-tasks-after-a-period-of-time">일정 기간 이후 비동기 작업 취소(C#)</a> <a href="#fnref:footnote9" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote10" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/start-multiple-async-tasks-and-process-them-as-they-complete?pivots=dotnet-6-0">완료되면 비동기 작업 처리(C#)</a> <a href="#fnref:footnote10" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote11" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/async/using-async-for-file-access">비동기 파일 액세스(C#)</a> <a href="#fnref:footnote11" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote12" role="doc-endnote"><p><a href="https://docs.microsoft.com/ko-kr/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap">작업 기반 비동기 패턴</a> <a href="#fnref:footnote12" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote13" role="doc-endnote"><p><a href="https://docs.microsoft.com/en-us/shows/c-advanced/">C# Advanced</a> <a href="#fnref:footnote13" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote3" role="doc-endnote"><p><a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean">What do the terms “CPU bound” and “I/O bound” mean?</a> <a href="#fnref:footnote3" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote4" role="doc-endnote"><p><a href="https://en.wikipedia.org/wiki/Futures_and_promises">Futures and promises</a> <a href="#fnref:footnote4" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/grind/'>Grind</a>, <a href='/categories/c/'>C#</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c#</a> <a href="/tags/asynchronous/" class="post-tag no-text-decoration" >asynchronous</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=10. async/await_2 - Null Section&url=https://psy0231.github.io/posts/CS_10_Async&Await_2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=10. async/await_2 - Null Section&u=https://psy0231.github.io/posts/CS_10_Async&Await_2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=10. async/await_2 - Null Section&url=https://psy0231.github.io/posts/CS_10_Async&Await_2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Python_dict/">dict</a><li><a href="/posts/Python_Var_Type/">Variable & Data Type</a><li><a href="/posts/Docker_4_Container_Option/">Docker 4 - Container Option</a><li><a href="/posts/Docker_3_Container/">Docker 3 - Container</a><li><a href="/posts/Docker_2_Image/">Docker 2 - Image</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/asynchronous/">asynchronous</a> <a class="post-tag" href="/tags/data-type/">data type</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/logger/">logger</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS_5_Async&Await_1/"><div class="card-body"> <em class="timeago small" date="2020-03-13 15:00:00 +0900" >Mar 13, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5. async/await_1 (sync/async, block/non-block)</h3><div class="text-muted small"><p> Build Up Action/Func - Task - async/await 왜? async라는 키워드를 자주 접하는것같은데 막상 써본적은 적거나 저게 어떤식으로 동작하는지 몰라서 시작함 시작은 async/await를 바로 쓸라다가 그 와중에 자주보이는 관련 키워드부터 해야지 싶어 build up부터하다 이 지경이 됨 sync/as...</p></div></div></a></div><div class="card"> <a href="/posts/CS_11_Async&Await_3/"><div class="card-body"> <em class="timeago small" date="2021-03-30 18:00:00 +0900" >Mar 30, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>11. async/await_3 Excention 1</h3><div class="text-muted small"><p> AS/AW Example 필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 .. source text파일을 읽고 table 형태로 만들고 grid에 넣음. 실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄. 하던 과정 그대로 일단. example 1 1 2 3 4 5 6 7 8 9 10 11 12 13...</p></div></div></a></div><div class="card"> <a href="/posts/CS_12_Async&Await_4/"><div class="card-body"> <em class="timeago small" date="2021-03-31 12:00:00 +0900" >Mar 31, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>12. async/await_3 Excention 2</h3><div class="text-muted small"><p> about exception of void return. 쉽게, sync에서 먼저. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class asaw_4_sync { public void ThrowException() { ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/CS_9_Task_3/" class="btn btn-outline-primary" prompt="Older"><p>9. Task_3</p></a> <a href="/posts/enable-google-pv/" class="btn btn-outline-primary" prompt="Newer"><p>Enable Google Page Views</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://psy0231.github.io/posts/CS_10_Async&Await_2/'; this.page.identifier = '/posts/CS_10_Async&Await_2/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://https-psy0231-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">SooyongPark</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/asynchronous/">asynchronous</a> <a class="post-tag" href="/tags/data-type/">data type</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/logger/">logger</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-160640437-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-160640437-1'); }); </script>
