<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="async/await_3 Excention 1" /><meta property="og:locale" content="en" /><meta name="description" content="AS/AW Example 필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 .. source text파일을 읽고 table 형태로 만들고 grid에 넣음. 실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄. 하던 과정 그대로 일단." /><meta property="og:description" content="AS/AW Example 필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 .. source text파일을 읽고 table 형태로 만들고 grid에 넣음. 실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄. 하던 과정 그대로 일단." /><link rel="canonical" href="https://psy0231.github.io/posts/CS_11_Async&Await_3/" /><meta property="og:url" content="https://psy0231.github.io/posts/CS_11_Async&Await_3/" /><meta property="og:site_name" content="Null Section" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-30T18:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="async/await_3 Excention 1" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"AS/AW Example 필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 .. source text파일을 읽고 table 형태로 만들고 grid에 넣음. 실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄. 하던 과정 그대로 일단.","headline":"async/await_3 Excention 1","dateModified":"2021-03-30T14:27:12+09:00","datePublished":"2021-03-30T18:00:00+09:00","url":"https://psy0231.github.io/posts/CS_11_Async&Await_3/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://psy0231.github.io/posts/CS_11_Async&Await_3/"},"@context":"https://schema.org"}</script><title>11. async/await_3 Excention 1 | Null Section</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Null Section"><meta name="application-name" content="Null Section"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">Null Section</a></div><div class="site-subtitle font-italic">nothing here.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/psy0231" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['psy0231','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>11. async/await_3 Excention 1</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>11. async/await_3 Excention 1</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/username">SooyongPark</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2021-03-30 18:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 30, 2021, 6:00 PM +0900" >Mar 30, 2021</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7224 words"> <em>40 min</em> read</span></div></div></div><div class="post-content"><h2 id="asaw-example">AS/AW Example<a href="#asaw-example" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>필요해서 직접 만들었던 예시와 공부하면서 봤던 내용들이 충돌해서 ..<li><a href="https://gitlab.com/psy72006300/Test_Reference/-/tree/master/ASAW">source</a><li><img data-src="https://raw.githubusercontent.com/psy0231/psy0231.github.io/master/assets/img/C%23/asaw3.jpg" alt="Image" title="example" data-proofer-ignore/><li>text파일을 읽고 table 형태로 만들고 grid에 넣음.<br /> 실제 오래 걸리던 데이터에서 1분정도만 잡아먹게 줄이고 해봄.<li>하던 과정 그대로 일단.</ul><h3 id="example-1">example 1<a href="#example-1" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="c1">// 실제 파일을 읽고 취합 후 구조화한 후, </span>
<span class="c1">// DataTable를 return.</span>
<span class="c1">// async로 작업할 부분.</span>
<span class="n">DataTable</span> <span class="nf">datamaker</span><span class="p">(){...}</span>

<span class="c1">//datamaker를 호출하는 부분</span>
<span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">DataTable</span><span class="p">&gt;</span> <span class="nf">asyncmtd_2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DataTable</span> <span class="n">res</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

    <span class="n">res</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">DataTable</span><span class="p">&gt;.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">datamaker</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//다시, asyncmtd()를 호출하는부분</span>
<span class="k">async</span> <span class="k">void</span> <span class="nf">asyncmtd_1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">Task</span><span class="p">&lt;</span><span class="n">DataTable</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">asyncmtd_2</span><span class="p">();</span>
        <span class="n">DataTable</span> <span class="n">dt</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">asyncmtd_2</span><span class="p">();</span>
        <span class="k">this</span><span class="p">.</span><span class="n">dataGridView1</span><span class="p">.</span><span class="n">DataSource</span> <span class="p">=</span> <span class="n">dt</span><span class="p">;</span>

        <span class="c1">//throw new InvalidOperationException();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">btn_async_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">textBox1</span><span class="p">.</span><span class="nf">AppendText</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span> <span class="p">+</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="s">"yyyy-MM-dd HH:mm:ss.fff"</span><span class="p">));</span>

    <span class="nf">asyncmtd_1</span><span class="p">();</span>

    <span class="n">Task</span><span class="p">&lt;</span><span class="n">DataTable</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">asyncmtd_2</span><span class="p">();</span>
    <span class="n">DataTable</span> <span class="n">dt</span> <span class="p">=</span> <span class="k">await</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="n">dataGridView1</span><span class="p">.</span><span class="n">DataSource</span> <span class="p">=</span> <span class="n">dt</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="n">textBox1</span><span class="p">.</span><span class="nf">AppendText</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span> <span class="p">+</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="s">"yyyy-MM-dd HH:mm:ss.fff"</span><span class="p">));</span>

<span class="p">}</span>
</pre></table></code></div></div><ul><li>처음에 만든게 이런식이었는데 이렇게 된 이유는<br /> ascyn method는 task를 return하도록하고 void는 권장하지 않음.<br /> 단, event는 제외. 관련 내용은 이 전 포스팅에 있음.<li>그런데 method내부에 await가 있으면<br /> 해당 method는 무조건 async가 붙어야함 (컴파일에러)<li>asyncmtd_2는 위 조건에 따라 만들어지는데<br /> 이건 또 일반 method에서는 호출을 못함.<br /> 일반 method에서 호출을하려면 task, await를 써야하는데<br /> 이러면 method에 또 async가 붙어야 하고<br /> 또 Task를 return하게 바꾸게됨.<li>이런식으로 계속 같은 method내용을 계속 쓰게되는데<br /> 위 사항을 지켜가면서 만들면 끝이 안남.<br /> async가 번지는느낌. 결국 위처럼 void로 끝냄.<br /> 근데 void로 끝내면 일반 method처럼 호출가능.<br /> 이렇게 작성된게 asyncmethod_1.<li>단, event는 async void가 혀용된다고 했으니 이 점을 감안하면<br /> asyncmethod_2도 위처럼 호출해쓸 수 있음. <br /> 그런데 꼭 event에 의해 사용하고싶지는 않으니…</ul><h3 id="example-2">example 2<a href="#example-2" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="n">DataTable</span> <span class="nf">datamaker</span><span class="p">(){...}</span>

<span class="k">async</span> <span class="k">void</span> <span class="nf">asyncmtd_3</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>

        <span class="n">DataTable</span> <span class="n">res</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">DataTable</span><span class="p">&gt;.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">datamaker</span><span class="p">();</span>
        <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="n">dataGridView1</span><span class="p">.</span><span class="n">DataSource</span> <span class="p">=</span> <span class="n">res</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="n">textBox1</span><span class="p">.</span><span class="nf">AppendText</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">btn_async_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="n">textBox1</span><span class="p">.</span><span class="nf">AppendText</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span> <span class="p">+</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="s">"yyyy-MM-dd HH:mm:ss.fff"</span><span class="p">));</span>

    <span class="nf">asyncmtd_3</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="n">textBox1</span><span class="p">.</span><span class="nf">AppendText</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span> <span class="p">+</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="s">"yyyy-MM-dd HH:mm:ss.fff"</span><span class="p">));</span>

<span class="p">}</span>
</pre></table></code></div></div><ul><li>ex1에서 asyncmtd_2처럼 쓰는데 return을 void로 하면<br /> 다른 method처럼 호출 가능.<br /> 다만 이 경우 exceptioon이 안잡히니 void형은 권장하지 않는 거였는데<br /> 해보니 또 잘 잡힘…<br /> 일단은 이렇게 써도 되는걸로?</ul><h2 id="asyncawait---best-practices-in-asynchronous-programming">Async/Await - Best Practices in Asynchronous Programming<sup id="fnref:footnote1" role="doc-noteref"><a href="#fn:footnote1" class="footnote" rel="footnote">1</a></sup><a href="#asyncawait---best-practices-in-asynchronous-programming" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>관련해서 좀 더 설명이 있는것같아 찾아봄.<li>가이드 라인 정도로 생각하라함.</ul><h3 id="avoid-async-void">Avoid Async Void<a href="#avoid-async-void" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>비동기 메서드에는 Task, Task&lt;T&gt; 및 void의 세 가지 가능한 반환 형식이 있지만<br /> 비동기 메서드의 자연적인 반환 형식은 Task 및 Task&lt;T&gt;임.<br /> 동기 코드에서 비동기 코드로 변환 할 때,<br /> T 형식을 반환하는 모든 메서드는 Task&lt;T&gt;를 반환하는 비동기 메서드가 되고<br /> void를 반환하는 모든 메서드는 Task를 반환하는 비동기 메서드가됨.<br /> 예를들어</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">void</span> <span class="nf">MyMethod</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// Do synchronous work.</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">async</span> <span class="n">Task</span> <span class="nf">MyMethodAsync</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// Do asynchronous work.</span>
<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>void 반환 비동기 메서드에는 비동기 이벤트 처리기를 가능하게하는 특정 목적이 있다.<br /> 실제 유형을 반환하는 이벤트 처리기를 가질 수 있지만 언어에서는 제대로 작동하지 않는다.<br /> 유형을 반환하는 이벤트 핸들러를 호출하는 것은 매우 어색하며<br /> 실제로 무언가를 반환하는 이벤트 핸들러의 개념은별로 의미가 없음.<br /> 이벤트 핸들러는 자연스럽게 void를 반환하므로<br /> 비동기 이벤트 핸들러를 가질 수 있도록 비동기 메소드가 void를 반환.<br /> 그러나 async void 메서드의 일부 의미는<br /> async Task 또는 async Task&lt;T&gt; 메서드의 의미와 미묘하게 다르다.</p><li><p>Async void 메서드는 오류 처리 의미가 다르다.<br /> 비동기 작업 또는 비동기 Task&lt;T&gt; 메서드에서 예외가 throw되면<br /> 해당 예외가 캡처되어 Task 개체에 배치함.<br /> async void 메서드를 사용하면 Task 개체가 없으므로<br /> async void 메서드에서 throw 된 모든 예외는<br /> async void 메서드가 시작될 때 활성화 된 SynchronizationContext에서 직접 발생.<br /> 다음은 비동기 void 메서드에서 throw 된 exception을 catch못한 경우.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// #1</span>
<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">ThrowExceptionAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidOperationException</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">AsyncVoidExceptions_CannotBeCaughtByCatch</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="nf">ThrowExceptionAsync</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// The exception is never caught here!</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>이러한 예외는 AppDomain.UnhandledException 또는<br /> GUI / ASP.NET 응용 프로그램에 대한 유사한<br /> catch-all 이벤트를 사용하여 관찰 할 수 있지만<br /> 이러한 이벤트를 일반 예외 처리에 사용하면 유지 관리가 불가능해짐.</ul><li><p>async void 메서드는 구성 의미가 다르다고 했다.<br /> Task 또는 Task&lt;T&gt;를 반환하는 비동기 메서드는<br /> await, Task.WhenAny, Task.WhenAll 등을 사용하여 쉽게 구성 할 수 있는반면,<br /> void를 반환하는 비동기 메서드는 호출 코드에 완료를 알리는 쉬운 방법이 없다.<br /> 여러 async void 메서드를 시작하는 것은 쉽지만 완료 시점 확인이 어렵다.<br /> 비동기 void 메서드는 시작 및 완료 될 때 SynchronizationContext에 알리지만<br /> 사용자 지정 SynchronizationContext는 일반 애플리케이션 코드를 위한 복잡한 방법임.</p><li><p>Async void 메서드는 테스트하기가 어려움.<br /> 오류 처리 및 구성의 차이로 인해<br /> 비동기 void 메서드를 호출하는 단위 테스트를 작성하기가 어렵다.<br /> MSTest 비동기 테스트 지원은<br /> Task 또는 Task&lt;T&gt;를 반환하는 비동기 메서드에 대해서만 작동함.<br /> 모든 비동기 void 메서드가 완료되었을 때를 감지하고<br /> 예외를 수집하는 SynchronizationContext를 설치할 수 있지만,<br /> 비동기 void 메서드가 대신 Task를 반환하도록하는 것이 훨씬 쉽다.</p><li><p>async void 메서드는 async Task 메서드에 비해 단점이 있지만,<br /> 비동기 이벤트 처리기라는 특정 경우에 매우 유용함.<br /> 의미 체계의 차이는 비동기 이벤트 처리기에서 의미가 있다.<br /> 동기 이벤트 처리기가 작동하는 방식과 유사한<br /> SynchronizationContext에서 직접 예외를 발생시킨다.<br /> 동기식 이벤트 핸들러는 일반적으로 비공개이므로<br /> 구성하거나 직접 테스트 할 수 없다.<br /> 여기에서(?) 선호하는 접근 방식은 비동기 이벤트 처리기 코드의 최소화.<br /> 예를 들어 실제 논리가 포함 된 비동기 작업 메서드를 기다리도록한다.<br /> 다음 코드는 테스트 가능성을 희생하지 않고<br /> 이벤트 처리기에 비동기 void 메서드를 사용하는이 접근 방식의 예시.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// #2</span>
<span class="c1">// Async Void 메서드의 예외는 Catch로 포착 할 수 없다.</span>
<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">button1_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">Button1ClickAsync</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">Button1ClickAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Do asynchronous work.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>호출자가 비동기 일 것으로 예상하지 않는 경우 비동기 void 메서드는 혼란을 일으킬 수 있다.<br /> 반환 유형이 Task이면 호출자는 향후 작업을 처리하고 있음을 알고 있지만<br /> 반환 유형이 void이면 호출자는 반환 할 때까지 메서드가 완료되었다고 가정 할 수 있다.<br /> 이 문제는 예기치 않은 여러 가지 방식으로 발생할 수 있다.<br /> 인터페이스 (또는 기본 클래스)에서 void 반환 메서드의<br /> 비동기 구현(또는 재정의)을 제공하는 것은 일반적으로 잘못됨.<br /> 일부 이벤트는 반환 할 때 처리기가 완료되었다고 가정한다.<br /> 한 가지 미묘한 트랩은 비동기 람다를 Action 매개 변수를 사용하는 메서드에 전달하는 것.<br /> 이 경우 비동기 람다는 void를 반환하고 비동기 void 메서드의 모든 문제를 상속한다.<br /> 일반적으로 비동기 람다는 Task를 반환하는 대리자 형식(예 : Func&lt;Task&gt;)으로 변환 된 경우에만 사용해야한다.</p><li><p>요약하면 async void보다 async Task를 강권함.<br /> 비동기 작업 메서드를 사용하면 오류 처리, 구성 가능성 및 테스트 가능성이 더 쉬움.<br /> 이 가이드 라인의 예외는 void를 반환해야하는 비동기 이벤트 처리기이며<br /> 이 예외에는 문자 그대로 이벤트 처리기가 아니더라도 논리적으로<br /> 이벤트 처리기 인 메서드(예 : ICommand.Execute 구현)가 포함.</p></ul><h3 id="async-all-the-way">Async All the Way<a href="#async-all-the-way" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>동기식 코드를 비동기식 코드로 변환할 때<br /> 비동기식 코드가 호출될 경우 가장 잘 작동하고<br /> 다른 비동기식 코드에 의해 호출되며,<br /> 이 코드는 하향식(또는 “상향식”)으로 호출된다.<br /> 다른 사람들은 또한 비동기 프로그래밍의 확산 동작을 발견하고<br /> 이를 “전염성”이라고 부르거나 좀비 바이러스와 비교했다.<br /> 비동기 코드는 주변 코드를 비동기로 만드는 경향이 있다.</p><li><p>“Async all the way”는 결과를 신중하게 고려하지 않고<br /> 동기 코드와 비동기 코드를 혼합해서는 안된다는 의미.<br /> 특히 Task.Wait 또는 Task.Result를 호출하여<br /> 비동기 코드를 차단하는 것은 일반적으로 좋지 않다.<br /> 이는 애플리케이션의 작은 부분 만 변환하고 이를 동기 API로 래핑하여<br /> 나머지 애플리케이션이 변경 사항으로부터 격리되도록<br /> “발가락”을 비동기 프로그래밍으로 전환하는 프로그래머에게 특히 일반적인 문제다.<br /> 이는 교착 상태를 유발할 가능성이 커짐.</p><li><p>다음은 하나의 메서드가 비동기 메서드의 결과를 차단하는 간단한 예.<br /> 이 코드는 콘솔 응용 프로그램에서 잘 작동하지만<br /> GUI 또는 ASP.NET 컨텍스트에서 호출되면 교착 상태가 됨.<br /> 이 동작은 혼란 스러울 수 있는데, 특히 디버거를 단계별로 진행하는 것이<br /> 완료되지 않는 대기라는 것을 의미한다는 점을 고려할 때 특히 그렇다.<br /> 교착 상태의 실제 원인은 Task.Wait가 호출 될 때 호출 스택보다 더 높다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// #3</span>
<span class="c1">// 비동기 코드에서 차단할 때 발생하는 일반적인 교착 상태 문제</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">DeadlockDemo</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">DelayAsync</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// This method causes a deadlock when called in a GUI or ASP.NET context.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Start the delay.</span>
        <span class="kt">var</span> <span class="n">delayTask</span> <span class="p">=</span> <span class="nf">DelayAsync</span><span class="p">();</span>
        <span class="c1">// Wait for the delay to complete.</span>
        <span class="n">delayTask</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>이 교착 상태의 근본 원인은 await가 컨텍스트를 처리하는 방식 때문인데,<br /> 기본적으로 완료되지 않은 작업이 대기하면<br /> 현재 “컨텍스트”가 캡처되어 작업이 완료 될 때 메서드를 재개하는 데 사용됨.<br /> 이 “컨텍스트”는 null이 아닌 경우<br /> 현재 SynchronizationContext이며, 이 경우 현재 TaskScheduler임.<br /> GUI 및 ASP.NET 응용 프로그램에는<br /> 한 번에 하나의 코드 청크 만 실행할 수있는 SynchronizationContext가 있다.<br /> await가 완료되면 캡처 된 컨텍스트 내에서<br /> 나머지 비동기 메서드를 실행하려함.<br /> 그러나 해당 컨텍스트에는 이미 스레드가 있으며<br /> 비동기 메서드가 완료되기를(동기적으로) 기다리고 있다.<br /> 이 둘은 서로를 기다리고있어 교착 상태가 발생.</p><li><p>콘솔 응용 프로그램은이 교착 상태를 일으키지 않는다.<br /> 한 번에 하나의 청크 SynchronizationContext 대신<br /> 스레드풀 SynchronizationContext가 있으므로<br /> 대기가 완료되면 스레드풀 스레드에서 나머지 비동기 메서드를 예약한다.<br /> 메서드는 완료 할 수 있으며 반환 된 작업을 완료하며 교착 상태가 없다.<br /> 이러한 동작의 차이는 프로그래머가 테스트 콘솔 프로그램을 작성하고<br /> 부분적으로 비동기 코드가 예상대로 작동하는 것을 관찰 한 다음<br /> 동일한 코드를 GUI 또는 ASP.NET 응용 프로그램으로 이동하여<br /> 교착 상태가되는 경우 혼란 스러울 수 있dma.</p><li><p>이 문제에 대한 최선의 해결책은<br /> 코드베이스를 통해 비동기 코드가 자연스럽게 성장하도록하는 것.<br /> 이 솔루션을 따르면 비동기 코드가<br /> 진입점 (일반적으로 이벤트 처리기 또는 컨트롤러 작업)으로 확장된다.<br /> Main 메서드가 비동기 일 수 없기 때문에<br /> 콘솔 응용 프로그램은 이 솔루션을 완전히 따를 수 없다.<br /> Main 메서드가 비동기 인 경우<br /> 완료되기 전에 반환되어 프로그램이 종료 될 수 있다.<br /> 다음은 지침에 대한이 예외로 콘솔 응용 프로그램의 Main 메서드는<br /> 코드가 비동기 메서드에서 차단 될 수 있는 몇 안되는 상황 중 하나.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>  <span class="c1">// #4</span>
  <span class="c1">// Main 메서드는 Task.Wait 또는 Task.Result를 호출 할 수 있습니다.</span>
  <span class="k">class</span> <span class="nc">Program</span>
  <span class="p">{</span>
      <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
      <span class="p">{</span>
          <span class="nf">MainAsync</span><span class="p">().</span><span class="nf">Wait</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MainAsync</span><span class="p">()</span>
      <span class="p">{</span>
          <span class="k">try</span>
          <span class="p">{</span>
              <span class="c1">// Asynchronous implementation.</span>
              <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
          <span class="p">{</span>
                
              <span class="c1">// Handle exceptions.</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><li><p>코드베이스를 통해 비동기가 성장하도록<br /> 허용하는 것이 최상의 솔루션이지만,<br /> 이는 애플리케이션이 비동기 코드의<br /> 실질적인 이점을 확인하기위한<br /> 많은 초기 작업이 있음을 의미한다.<br /> 대규모 코드베이스를 비동기 코드로<br /> 점진적으로 변환하는 몇 가지 기술이 있지만<br /> 이 문서의 범위를 벗난다.<br /> 경우에 따라 Task.Wait 또는 Task.Result를 사용하면<br /> 부분 변환에 도움이 될 수 있지만<br /> 교착 상태 문제와 오류 처리 문제를 알고 있어야한다.<br /> 뒤는 오류 처리 문제를 설명하고<br /> 이 글의 뒤에서는 교착 상태 문제를 피하는 방법을 설명함.</p><li><p>모든 작업은 예외 목록을 저장한다.<br /> 태스크를 기다릴 때 첫 번째 예외가 다시 발생하므로<br /> 특정 예외 유형 (예 : InvalidOperationException)을 포착 할 수 있다.<br /> 그러나 Task.Wait 또는 Task.Result를 사용하여 Task를 동기적으로 차단하면<br /> 모든 예외가 AggregateException으로 래핑되고 throw된다.<br /> 다시 위 예시를 참조하면, <br /> MainAsync의 try/catch는 특정 예외 유형을 포착하지만,<br /> Main에 try/catch를 넣으면 항상 AggregateException을 포착한다.<br /> AggregateException이 없으면 오류 처리가 훨씬 더 쉽게 처리 할 수 있으므로<br /> MainAsync에 “global” try / catch를 넣음.</p><li><p>지금까지 비동기 코드 차단과 관련된 두 가지 문제,<br /> 즉 가능한 교착 상태와 더 복잡한 오류 처리를 보았다.<br /> 다음 예는 비동기 메서드 내에서 차단 코드를 사용할 때의 문제.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// #5</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">NotFullyAsynchronousDemo</span>
<span class="p">{</span>
    <span class="c1">// This method synchronously blocks a thread.</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">TestNotFullyAsync</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>위 방법은 완전히 비동기식이 아니다.<br /> 즉시 양보하여 불완전한 작업을 반환하지만<br /> 재개되면 실행중인 스레드를 동기적으로 차단한다.<br /> 이 메소드가 GUI 컨텍스트에서 호출되면 GUI 스레드를 차단.<br /> ASP.NET 요청 컨텍스트에서 호출되면<br /> 현재 ASP.NET 요청 스레드를 차단.<br /> 비동기 코드는 동기적으로 차단되지 않는 경우 가장 잘 작동.<br /> 다음은 동기식 작업을위한 비동기식 대체 방법.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">To Do This …<th style="text-align: left">Instead of This …<th style="text-align: left">Use This<tbody><tr><td style="text-align: left">Retrieve the result of a background task<td style="text-align: left">Task.Wait or Task.Result<td style="text-align: left">await<tr><td style="text-align: left">Wait for any task to complete<td style="text-align: left">Task.WaitAny<td style="text-align: left">await Task.WhenAny<tr><td style="text-align: left">Retrieve the results of multiple tasks<td style="text-align: left">Task.WaitAll<td style="text-align: left">await Task.WhenAll<tr><td style="text-align: left">Wait a period of time<td style="text-align: left">Thread.Sleep<td style="text-align: left">await Task.Delay</table></div><li><p>요약하면<br /> 비동기 코드와 차단 코드를 혼합하지 않아야한다.<br /> 혼합 된 비동기 및 차단 코드는 교착 상태,<br /> 더 복잡한 오류 처리 및 예기치 않은 컨텍스트 스레드 차단을 유발할 수 있다.<br /> 이 가이드 라인의 예외는 콘솔 응용 프로그램을 위한 Main 메서드 또는<br /> 고급 사용자 인 경우 부분적으로 비동기 코드베이스를 관리하는 것입니다.</p></ul><h3 id="configure-context">Configure Context<a href="#configure-context" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>이 전 내용에서 불완전한 작업이 대기 할 때<br /> 기본적으로 “컨텍스트”가 캡처되는 방법과<br /> 해당 컨텍스트를 사용하여 비동기 메서드를<br /> 다시 시작하는 방법에 대해 간단히 설명했다.<br /> #3의 예시는 컨텍스트에서 재개가<br /> 동기 차단과 충돌하여 교착 상태를 유발하는지 보였다.<br /> 이 컨텍스트 동작은 성능 문제를 일으킬 수도 있다.<br /> 비동기 GUI 애플리케이션이 커짐에 따라<br /> GUI 스레드를 컨텍스트로 사용하는<br /> 비동기 메소드의 많은 작은 부분을 찾을 수 있다.<br /> 이로 인해 “수천 장의 종이 절단”으로 인해<br /> 응답 성이 저하되므로 느려질 수 있다.<br /> (This can cause sluggishness as responsiveness suffers<br /> from “thousands of paper cuts.”)</p><li><p>이를 완화하려면 가능할 때마다 ConfigureAwait의 결과를 기다린다.<br /> 다음 예는 기본 컨텍스트 동작과 ConfigureAwait의 사용방법.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">async</span> <span class="n">Task</span> <span class="nf">MyMethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Code here runs in the original context.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="c1">// Code here runs in the original context.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span>
        <span class="n">continueOnCapturedContext</span><span class="p">:</span> <span class="k">false</span><span class="p">);</span>
    <span class="c1">// Code here runs without the original</span>
    <span class="c1">// context (in this case, on the thread pool).</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>ConfigureAwait는 적은 양의 병렬 처리를 활성화 할 수 있다.<br /> 일부 비동기 코드는 수행 할 작업으로 끊임없이<br /> 배지를 표시하는 대신 GUI 스레드와 병렬로 실행할 수 있다.</ul><li><p>성능 외에도 ConfigureAwait의 또 다른 중요한점은 <br /> 교착 상태를 피할 수 있게 한다는것.<br /> #3에서 DelayAsync의 코드 줄에<br /> “ConfigureAwait(false)”를 추가하면 교착 상태가 방지된다.<br /> 이번에는 await가 완료되면 스레드풀 컨텍스트 내에서<br /> 나머지 비동기 메서드를 실행하려한다.<br /> 메서드는 완료 할 수 있으며<br /> 반환 된 작업을 완료하며 교착 상태가 없다.<br /> 이 기술은 응용 프로그램을 동기에서 비동기로<br /> 점진적으로 변환해야하는 경우 특히 유용하다.</p><li><p>메서드 내에서 어느 시점에서 ConfigureAwait를 사용할 수 있다면<br /> 해당 시점 이후에 해당 메서드의 모든 await에 대해 사용하는 것이 좋다.<br /> 불완전한 작업이 대기하는 경우에만 컨텍스트가 캡처된다.<br /> 태스크가 이미 완료된 경우 컨텍스트가 캡처되지 않는다.<br /> 일부 작업은 다른 하드웨어 및 네트워크 상황에서<br /> 예상보다 빨리 완료 될 수 있으며,<br /> 기다리기 전에 완료되는 반환 된 작업을 정중하게 처리해야한다.<br /> #6 은 수정 된 예.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// #6 </span>
<span class="c1">// 기다리기 전에 완료되는 반환 된 작업 처리</span>
<span class="k">async</span> <span class="n">Task</span> <span class="nf">MyMethodAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Code here runs in the original context.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
    <span class="c1">// Code here runs in the original context.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">FromResult</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="n">continueOnCapturedContext</span><span class="p">:</span> <span class="k">false</span><span class="p">);</span>
    <span class="c1">// Code here runs in the original context.</span>
    <span class="kt">var</span> <span class="n">random</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">delay</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="m">2</span><span class="p">);</span> <span class="c1">// Delay is either 0 or 1</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="n">delay</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="n">continueOnCapturedContext</span><span class="p">:</span> <span class="k">false</span><span class="p">);</span>
    <span class="c1">// Code here might or might not run in the original context.</span>
    <span class="c1">// The same is true when you await any Task</span>
    <span class="c1">// that might complete very quickly.</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>컨텍스트가 필요한 메서드에서<br /> await 후에 코드가있는 경우 ConfigureAwait를 사용하면 안됨.<br /> GUI 앱의 경우 여기에는 GUI 요소를 조작하거나<br /> 데이터 바인딩 된 속성을 작성하거나<br /> Dispatcher/CoreDispatcher와 같은<br /> GUI 특정 유형에 의존하는 모든 코드가 포함된다.<br /> ASP.NET 앱의 경우 여기에는 컨트롤러 작업의 반환 문을 포함하여<br /> HttpContext.Current를 사용하거나<br /> ASP.NET 응답을 빌드하는 모든 코드가 포된다.<br /> #7 은 GUI 앱의 한 가지 일반적인 패턴을 보여준다.<br /> 비동기 이벤트 처리기가 메서드 시작시 제어를 비활성화하고<br /> 일부 대기를 수행 한 다음 처리기 끝에서 제어를 다시 활성화한다.<br /> 이벤트 핸들러는 제어를 다시 활성화해야하므로 컨텍스트를 포기할 수 없다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// #7 </span>
<span class="c1">// 비동기 이벤트 처리기가 제어를 비활성화하고 다시 활성화하도록 설정</span>

<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">button1_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">button1</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// Can't use ConfigureAwait here ...</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="c1">// Because we need the context here.</span>
        <span class="n">button1</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>각 비동기 메서드에는 고유 한 컨텍스트가 있으므로<br /> 한 비동기 메서드가 다른 비동기 메서드를 호출하면<br /> 해당 컨텍스트는 독립적입니다.<br /> #8 은 #7의 수정 버전.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// #8</span>
<span class="c1">// 각 비동기 메서드에는 고유 한 컨텍스트가 있다.</span>
<span class="k">private</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">HandleClickAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Can use ConfigureAwait here.</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="n">continueOnCapturedContext</span><span class="p">:</span> <span class="k">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">private</span> <span class="k">async</span> <span class="k">void</span> <span class="nf">button1_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">button1</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// Can't use ConfigureAwait here.</span>
        <span class="k">await</span> <span class="nf">HandleClickAsync</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="c1">// We are back on the original context for this method.</span>
        <span class="n">button1</span><span class="p">.</span><span class="n">Enabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>    
</pre></table></code></div></div><li><p>컨텍스트 프리 코드는 더 재사용이 가능하다.<br /> 컨텍스트에 민감한 코드와 컨텍스트에 구애받지 않는 코드 사이에<br /> 장벽을 만들고 컨텍스트에 민감한 코드를 최소화하도록 한다.<br /> 그림 8에서는 상황에 맞는 이벤트 핸들러에 최소한의 코드만 남겨두고<br /> 테스트 가능하고 컨텍스트가 없는 비동기 태스크 메서드에<br /> 이벤트 핸들러의 모든 핵심 로직을 배치하는 것이 좋다. ASP.NET 응용 프로그램을 작성하는 경우에도<br /> 데스크톱 응용 프로그램과 잠재적으로 공유되는 핵심 라이브러리가있는 경우<br /> 라이브러리 코드에서 ConfigureAwait를 사용하는 것이 좋습니다.</p><li><p>요약하면<br /> 가능한 경우 ConfigureAwait를 사용해야한다.<br /> 컨텍스트 프리 코드는<br /> GUI 애플리케이션의 성능이 더 우수하며<br /> 부분 비동기 코드베이스로 작업 할 때<br /> 교착 상태를 피하는 데 유용한 기술이다.<br /> 이 가이드 라인의 예외는 컨텍스트가 필요한 메서드인 경우.</p></ul><h3 id="know-your-tools">Know Your Tools<a href="#know-your-tools" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>복잡하다.<li>#9는 일반적인 문제에 대한 솔루션의 빠른 참조.</ul><div class="table-wrapper"><table><thead><tr><th style="text-align: left">문제<th style="text-align: left">해결책<tbody><tr><td style="text-align: left">코드를 실행하는 작업 만들기<td style="text-align: left">Task.Run 또는 TaskFactory.StartNew (작업의 생성자 또는 Task.Start 아님.)<tr><td style="text-align: left">작업 또는 이벤트에 대한 작업 래퍼 만들기<td style="text-align: left">TaskFactory.FromAsync 또는 TaskCompletionSource <T></T><tr><td style="text-align: left">지원 취소<td style="text-align: left">CancellationTokenSource 및 CancellationToken<tr><td style="text-align: left">진행 상황보고<td style="text-align: left">IProgress <T> 및 Progress <T></T></T><tr><td style="text-align: left">데이터 스트림 처리<td style="text-align: left">TPL 데이터 흐름 또는 Reactive Extensions<tr><td style="text-align: left">공유 리소스에 대한 액세스 동기화<td style="text-align: left">SemaphoreSlim<tr><td style="text-align: left">리소스를 비동기 적으로 초기화<td style="text-align: left">AsyncLazy <T></T><tr><td style="text-align: left">비동기식 생산자 / 소비자 구조<td style="text-align: left">TPL 데이터 흐름 또는 AsyncCollection <T></T></table></div><ul><li><p>첫 번째 문제는 작업 생성이다.<br /> 분명히 비동기 메서드는 작업을 생성 할 수 있으며<br /> 이것이 가장 쉬운 옵션입니다.<br /> 스레드 풀에서 코드를 실행해야하는 경우 Task.Run을 사용합니다.<br /> 기존 비동기 작업 또는 이벤트에 대한 작업 래퍼를 만들려면<br /> TaskCompletionSource&lt;T&gt;를 사용힌다.</p><p>다음으로 일반적인 문제는 취소 및 진행보고를 처리하는 방법으로 <br /> BCL (기본 클래스 라이브러리)에는 CancellationTokenSource / CancellationToken 및<br /> IProgress&lt;T&gt; / Progress&lt;T&gt;와 같은 문제를 해결하기 위해<br /> 특별히 고안된 형식이 포함되어 있다.<br /> 비동기 코드는 작업 생성, 취소 및 진행보고를 자세히 설명하는<br /> 작업 기반 비동기 패턴 또는 TAP ( msdn.microsoft.com/library/hh873175 )를 사용해야한다.</p><li><p>또 다른 문제는 비동기 데이터 스트림을 처리하는 방법이다.<br /> Task는 훌륭하지만 하나의 개체 만 반환하고 한 번만 완료 할 수 있다.<br /> 비동기 스트림의 경우 TPL Dataflow 또는 Reactive Extensions(Rx)를 사용할 수 있다.<br /> TPL Dataflow는 행위자 같은 느낌을주는 ‘메시’를 만든다.<br /> Rx는 더 강력하고 효율적이지만 학습 곡선이 더 어렵다.<br /> TPL Dataflow와 Rx에는 모두 비동기식 메서드가 있으며 비동기 코드에서 잘 작동힌다.</p><li><p>코드가 비동기 적이라고해서 안전하다는 의미는 아니다.<br /> 공유 리소스는 여전히 보호해야하며<br /> 잠금 내부에서 기다릴 수 없다는 사실로 인해 복잡하다.<br /> 다음은 항상 동일한 스레드에서 실행 되더라도<br /> 공유 상태가 두 번 실행되면 공유 상태를 손상시킬 수있는 비동기 코드의 예.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="k">value</span><span class="p">;</span>

<span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetNextValueAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">current</span><span class="p">);</span>

<span class="k">async</span> <span class="n">Task</span> <span class="nf">UpdateValueAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">value</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">GetNextValueAsync</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>문제는 메서드가 값을 읽고 대기시 자체를 일시 중단하고<br /> 메서드가 다시 시작될 때 값이 변경되지 않은 것으로 가정한다는 것이다.<br /> 이 문제를 해결하기 위해 SemaphoreSlim 클래스는<br /> async-ready WaitAsync 오버로드로 확장되었다.<br /> #10 은 SemaphoreSlim.WaitAsync를 보여준다.</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span label-text="C#"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>  <span class="c1">// #10</span>
  <span class="c1">// 그림 10 SemaphoreSlim은 비동기 동기화를 허용합니다.</span>
  <span class="n">SemaphoreSlim</span> <span class="n">mutex</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="k">value</span><span class="p">;</span>

  <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">GetNextValueAsync</span><span class="p">(</span><span class="kt">int</span> <span class="n">current</span><span class="p">);</span>

  <span class="k">async</span> <span class="n">Task</span> <span class="nf">UpdateValueAsync</span><span class="p">()</span>
  <span class="p">{</span>

      <span class="k">await</span> <span class="n">mutex</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">().</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>

      <span class="k">try</span>
      <span class="p">{</span>
          <span class="k">value</span> <span class="p">=</span> <span class="k">await</span> <span class="nf">GetNextValueAsync</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">finally</span>
      <span class="p">{</span>
          <span class="n">mutex</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
      <span class="p">}</span>

  <span class="p">}</span>
</pre></table></code></div></div><li>비동기 코드는 종종 캐시되고 공유되는 리소스를 초기화하는 데 사용됩니다.<br /> 이에 대한 기본 제공 유형은 없지만<br /> Stephen Toub는 Task&lt;T&gt; 및 Lazy&lt;T&gt;의 병합처럼 작동하는<br /> AsyncLazy&lt;T&gt;를 개발했습니다.<br /> 원래 유형은 그의 블로그에 설명되어 있으며<sup id="fnref:footnote2" role="doc-noteref"><a href="#fn:footnote2" class="footnote" rel="footnote">2</a></sup><sup id="fnref:footnote3" role="doc-noteref"><a href="#fn:footnote3" class="footnote" rel="footnote">3</a></sup><sup id="fnref:footnote4" role="doc-noteref"><a href="#fn:footnote4" class="footnote" rel="footnote">4</a></sup><br /> 업데이트 된 버전은 내 AsyncEx 라이브러리<sup id="fnref:footnote5" role="doc-noteref"><a href="#fn:footnote5" class="footnote" rel="footnote">5</a></sup>에서 사용할 수 있다.<li>마지막으로, 때때로 비동기 준비 데이터 구조가 필요합니다.<br /> TPL Dataflow는 비동기식 생산자 / 소비자 대기열처럼 작동하는 BufferBlock&lt;T&gt;를 제공합니다.<br /> 또는 AsyncEx는 BlockingCollection <T>의 비동기 버전 인 AsyncCollection\<T>를 제공합니다.</T></T></ul><h2 id="참고">참고<a href="#참고" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="footnotes" role="doc-endnotes"><ol><li id="fn:footnote1" role="doc-endnote"><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming">Async/Await - Best Practices in Asynchronous Programming</a> <a href="#fnref:footnote1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote2" role="doc-endnote"><p><a href="https://blog.stephencleary.com/">stephen cleary</a> <a href="#fnref:footnote2" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote3" role="doc-endnote"><p><a href="https://devblogs.microsoft.com/pfxteam/asynclazyt/">AsyncLazy</a> <a href="#fnref:footnote3" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote4" role="doc-endnote"><p><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.threading.asynclazy-1?view=visualstudiosdk-2019">AsyncLazy&lt;T&gt; Class</a> <a href="#fnref:footnote4" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:footnote5" role="doc-endnote"><p><a href="https://github.com/StephenCleary/AsyncEx">StephenCleary/AsyncEx</a> <a href="#fnref:footnote5" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/grind/'>Grind</a>, <a href='/categories/c/'>C#</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c#</a> <a href="/tags/asynchronous/" class="post-tag no-text-decoration" >asynchronous</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=11. async/await_3 Excention 1 - Null Section&url=https://psy0231.github.io/posts/CS_11_Async&Await_3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=11. async/await_3 Excention 1 - Null Section&u=https://psy0231.github.io/posts/CS_11_Async&Await_3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=11. async/await_3 Excention 1 - Null Section&url=https://psy0231.github.io/posts/CS_11_Async&Await_3/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Python_dict/">dict</a><li><a href="/posts/Python_Var_Type/">Variable & Data Type</a><li><a href="/posts/Docker_4_Container_Option/">Docker 4 - Container Option</a><li><a href="/posts/Docker_3_Container/">Docker 3 - Container</a><li><a href="/posts/Docker_2_Image/">Docker 2 - Image</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/asynchronous/">asynchronous</a> <a class="post-tag" href="/tags/data-type/">data type</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/logger/">logger</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/CS_5_Async&Await_1/"><div class="card-body"> <em class="timeago small" date="2020-03-13 15:00:00 +0900" >Mar 13, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5. async/await_1 (sync/async, block/non-block)</h3><div class="text-muted small"><p> Build Up Action/Func - Task - async/await 왜? async라는 키워드를 자주 접하는것같은데 막상 써본적은 적거나 저게 어떤식으로 동작하는지 몰라서 시작함 시작은 async/await를 바로 쓸라다가 그 와중에 자주보이는 관련 키워드부터 해야지 싶어 build up부터하다 이 지경이 됨 sync/as...</p></div></div></a></div><div class="card"> <a href="/posts/CS_10_Async&Await_2/"><div class="card-body"> <em class="timeago small" date="2020-12-24 18:00:00 +0900" >Dec 24, 2020</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>10. async/await_2</h3><div class="text-muted small"><p> Asynchronous intro 다시 asynchronous programming를 async, await와 섞어서함. 따라서 본 내용은 이 전 async &amp;amp; await 1 의 내용과 위의 async, await 와 중복되는 내용이 많은데, 이부분은 아래 링크에도 있듯이 서로 연결되어있거나 순환적임. 무튼, 계속 비슷한 내용들을...</p></div></div></a></div><div class="card"> <a href="/posts/CS_12_Async&Await_4/"><div class="card-body"> <em class="timeago small" date="2021-03-31 12:00:00 +0900" >Mar 31, 2021</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>12. async/await_3 Excention 2</h3><div class="text-muted small"><p> about exception of void return. 쉽게, sync에서 먼저. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class asaw_4_sync { public void ThrowException() { ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/enable-google-pv/" class="btn btn-outline-primary" prompt="Older"><p>Enable Google Page Views</p></a> <a href="/posts/CS_12_Async&Await_4/" class="btn btn-outline-primary" prompt="Newer"><p>12. async/await_3 Excention 2</p></a></div><div id="disqus_thread" class="pt-2 pb-2"><p class="text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script type="text/javascript"> var disqus_config = function () { this.page.url = 'https://psy0231.github.io/posts/CS_11_Async&Await_3/'; this.page.identifier = '/posts/CS_11_Async&Await_3/'; }; /* Lazy loading */ var disqus_observer = new IntersectionObserver(function (entries) { if(entries[0].isIntersecting) { (function () { var d = document, s = d.createElement('script'); s.src = 'https://https-psy0231-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); disqus_observer.disconnect(); } }, { threshold: [0] }); disqus_observer.observe(document.querySelector('#disqus_thread')); /* Auto switch theme */ function reloadDisqus() { /* Disqus hasn't been loaded */ if (typeof DISQUS === "undefined") { return; } if (document.readyState == 'complete') { DISQUS.reset({ reload: true, config: disqus_config }); } } const modeToggle = document.querySelector(".mode-toggle"); if (typeof modeToggle !== "undefined") { /* modeToggle.addEventListener('click', reloadDisqus); // not pretty for 'color-scheme' */ window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reloadDisqus); } </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">SooyongPark</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/git/">git</a> <a class="post-tag" href="/tags/asynchronous/">asynchronous</a> <a class="post-tag" href="/tags/data-type/">data type</a> <a class="post-tag" href="/tags/container/">container</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/io/">io</a> <a class="post-tag" href="/tags/logger/">logger</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-160640437-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-160640437-1'); }); </script>
