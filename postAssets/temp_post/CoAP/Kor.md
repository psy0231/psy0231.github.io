 ---
[ 검색 ] [ txt | html | pdf | bibtex ] [ 추적기 ] [ WG ] [ 이메일 ] [ Diff1 ] [ Diff2 ] [ Nits ]  

    From : draft-ietf-core-coap-18                           제안 된 표준  
    업데이트 : 7959 , 8613 , 8974                                 에라타 존재  
    IETF (Internet Engineering Task Force) Z. Shelby  
    의견 요청 : 7252 ARM  
    카테고리 : Standards Track K. Hartke  
    ISSN : 2070-1721 C. 보르 만  
                                                    Universitaet Bremen TZI  
                                                                2014 년 6 월  

---
## 0. CoAP (Constrained Application Protocol)

### 요약
- 제약된 환경의노드와 함께 사용하기 위한 특수한 웹 전송 프로토콜.  
  - 제한된  네트워크 환경 : 저전력, 손실.   
  - 노드는 ROM과 RAM의 양이 적은 8비트 마이크로컨트롤러를 사용하는 경우가 많음  
  - 제한된 네트워크는 Low-Power Wireless Personal Area Networks(6LoWPANs)를 통한  
  IPv6와 같은 패킷 오류율이 높고 일반적으로 10s의 kbit/s의 처리량을 갖는 경우가 많다.   
  - 이 프로토콜은 스마트 에너지와 빌딩 자동화 같은  
  기계 대 기계(M2M) 애플리케이션을 위해 설계되었다.      

- CoAP 기본 
  - 애플리케이션 끝점 간의 요청/응답 상호 작용 모델을 제공,  
  - 서비스와 리소스의 내장된 검색을 지원,  
  - URI와 인터넷 미디어 유형과 같은 웹의 핵심 개념을 포함한다.   
  - CoAP는 멀티캐스트 지원, 매우 낮은 오버헤드,  
  제한된 환경에 대한 단순성과 같은 특화된 요건을 충족하면서  
  웹과의 통합을 위해 HTTP와 쉽게 접속하도록 설계되었다.  


### Status of This Memo
- 이것은 인터넷 표준 추적 문서다.     
- 이 문서는 IETF(Internet Engineering Task Force)의 산물이다.  
- IETF 커뮤니티의 공감대를 대변한다.  
- 공개 검토를 받았으며,  
IESG(Internet Engineering Steering Group)에 의해 출판 승인을 받았다.  
- 인터넷 표준에 대한 추가 정보는 RFC 5741의 섹션 2에서 이용할 수 있다.     
- 이 문서의 현재 상태, 에라타 및  
이에 대한 피드백을 제공하는 방법에 대한 정보는  
http://www.rfc-editor.org/info/rfc7252에서 확인할 수 있다.

### 저작권 고지

    Copyright (c) 2014 IETF Trust 및
    문서 작성자. 판권 소유.

    이 문서는 BCP 78 및 IETF Trust 's Legal의 적용을받습니다.
    IETF 문서와 관련된 조항
    ( http://trustee.ietf.org/license-info )
    이 문서의 출판. 이 문서를 검토하십시오
    신중하게 귀하의 권리와 제한을 설명하므로
    이 문서에. 이 문서에서 추출 된 코드 구성 요소는
    섹션 4.e에 설명 된대로 단순화 된 BSD 라이선스 텍스트를 포함합니다.
    신뢰 법률 조항을 준수하며 보증없이 제공됩니다.
    단순화 된 BSD 라이센스에 설명되어 있습니다.

### 목차

    1 . 소개. . . . . . . . . . . . . . . . . . . . . . . .   5 
      1.1 . 특징. . . . . . . . . . . . . . . . . . . . . . . .   5 
      1.2 . 용어. . . . . . . . . . . . . . . . . . . . . . .   6 
    2 . 제한된 애플리케이션 프로토콜. . . . . . . . . . . . . .  (10) 
      2.1 . 메시징 모델. . . . . . . . . . . . . . . . . . . . .  11 
      2.2 . 요청 / 응답 모델. . . . . . . . . . . . . . . . .  12 
      2.3 . 중개자 및 캐싱. . . . . . . . . . . . . . .  (15) 
      2.4 . 리소스 검색. . . . . . . . . . . . . . . . . . .  15
    3 . 메시지 형식. . . . . . . . . . . . . . . . . . . . . . .  15 
      3.1 . 옵션 형식. . . . . . . . . . . . . . . . . . . . . .  17 
      3.2 . 옵션 값 형식. . . . . . . . . . . . . . . . . .  19 
    4 . 메시지 전송. . . . . . . . . . . . . . . . . . . .  20 
      4.1 . 메시지 및 끝점. . . . . . . . . . . . . . . . .  20 
      4.2 . 안정적으로 전송 된 메시지. . . . . . . . . . . . . .  21 
      4.3 . 신뢰성없이 전송 된 메시지. . . . . . . .  23 
      4.4 . 메시지 상관 관계. . . . . . . . . . . . . . . . . . .  24
      4.5 . 메시지 중복 제거. . . . . . . . . . . . . . . . . .  24 
      4.6 . 메시지 크기. . . . . . . . . . . . . . . . . . . . . .  25 
      4.7 . 혼잡 제어. . . . . . . . . . . . . . . . . . .  26 
      4.8 . 전송 매개 변수. . . . . . . . . . . . . . . . .  27 
        4.8.1 . 매개 변수 변경. . . . . . . . . . . . . . .  27 
        4.8.2 . 전송 매개 변수에서 파생 된 시간 값. .  28 
    5 . 요청 / 응답 의미론. . . . . . . . . . . . . . . . .  31 
      5.1 . 요청. . . . . . . . . . . . . . . . . . . . . . . .  31
      5.2 . 응답. . . . . . . . . . . . . . . . . . . . . . . .  31 
        5.2.1 . 편승. . . . . . . . . . . . . . . . . . . . .  33 
        5.2.2 . 별도의. . . . . . . . . . . . . . . . . . . . . .  33 
        5.2.3 . 확인 불가. . . . . . . . . . . . . . . . . . .  34 
      5.3 . 요청 / 응답 일치. . . . . . . . . . . . . . . .  34 
        5.3.1 . 토큰. . . . . . . . . . . . . . . . . . . . . . . .  34 
        5.3.2 . 요청 / 응답 일치 규칙. . . . . . . . . . .  35
      5.4 . 옵션. . . . . . . . . . . . . . . . . . . . . . . . .  36 
        5.4.1 . 중요 / 선택적. . . . . . . . . . . . . . . . . .  37 
        5.4.2 . Proxy Unsafe 또는 Safe-to-Forward 및 NoCacheKey. . .  38 
        5.4.3 . 길이 . . . . . . . . . . . . . . . . . . . . . . .  38 
        5.4.4 . 기본값. . . . . . . . . . . . . . . . . . .  38 
        5.4.5 . 반복 가능한 옵션. . . . . . . . . . . . . . . . .  39 
        5.4.6 . 옵션 번호. . . . . . . . . . . . . . . . . . .  39 
      5.5 . 페이로드 및 표현. . . . . . . . . . . . . .  40 
        5.5.1. 표현. . . . . . . . . . . . . . . . . . .  40 
        5.5.2 . 진단 페이로드. . . . . . . . . . . . . . . . .  41 
        5.5.3 . 선택된 표현. . . . . . . . . . . . . . .  41 
        5.5.4 . 콘텐츠 협상. . . . . . . . . . . . . . . . .  41 
      5.6 . 캐싱. . . . . . . . . . . . . . . . . . . . . . . . .  42 
        5.6.1 . 신선도 모델. . . . . . . . . . . . . . . . . . .  43 
        5.6.2 . 검증 모델. . . . . . . . . . . . . . . . . .  43 
      5.7 . 프록 싱. . . . . . . . . . . . . . . . . . . . . . . .  44 
        5.7.1. 프록시 작업. . . . . . . . . . . . . . . . . . .  44 
        5.7.2 . 정방향 프록시. . . . . . . . . . . . . . . . . . .  46 
        5.7.3 . 리버스 프록시. . . . . . . . . . . . . . . . . . .  46 
      5.8 . 방법 정의. . . . . . . . . . . . . . . . . . .  47 
        5.8.1 . 가져 오기 . . . . . . . . . . . . . . . . . . . . . . . . .  47 
        5.8.2 . 게시하다 . . . . . . . . . . . . . . . . . . . . . . . .  47 
        5.8.3 . PUT. . . . . . . . . . . . . . . . . . . . . . . . .  48 
        5.8.4 . 삭제. . . . . . . . . . . . . . . . . . . . . . .  48 
      5.9. 응답 코드 정의. . . . . . . . . . . . . . . .  48 
        5.9.1 . 성공 2.xx. . . . . . . . . . . . . . . . . . . .  48 
        5.9.2 . 클라이언트 오류 4.xx. . . . . . . . . . . . . . . . . .  50 
        5.9.3 . 서버 오류 5.xx. . . . . . . . . . . . . . . . . .  51 
      5.10 . 옵션 정의. . . . . . . . . . . . . . . . . . .  52 
        5.10.1 . Uri-Host, Uri-Port, Uri-Path 및 Uri-Query. . . .  53 
        5.10.2 . Proxy-Uri 및 Proxy-Scheme. . . . . . . . . . . . .  54 
        5.10.3 . 콘텐츠 형식. . . . . . . . . . . . . . . . . . .  55 
        5.10.4. 동의하기 . . . . . . . . . . . . . . . . . . . . . . .  55 
        5.10.5 . 최대 연령. . . . . . . . . . . . . . . . . . . . . .  55 
        5.10.6 . ETag. . . . . . . . . . . . . . . . . . . . . . . .  56 
        5.10.7 . 위치 경로 및 위치 쿼리. . . . . . . . . .  57 
        5.10.8 . 조건부 요청 옵션. . . . . . . . . . . .  57 
        5.10.9 . Size1 옵션. . . . . . . . . . . . . . . . . . . .  59 
    6 . CoAP URI. . . . . . . . . . . . . . . . . . . . . . . . . .  59 
      6.1 . coap URI 체계. . . . . . . . . . . . . . . . . . . . .  59 
      6.2. coaps URI 체계. . . . . . . . . . . . . . . . . . . .  60 
      6.3 . 정규화 및 비교 규칙. . . . . . . . . . .  61 
      6.4 . URI를 옵션으로 분해. . . . . . . . . . . . . .  61 
      6.5 . 옵션에서 URI 작성. . . . . . . . . . . . . . .  62 
    7 . 발견. . . . . . . . . . . . . . . . . . . . . . . . . .  64 
      7.1 . 서비스 검색. . . . . . . . . . . . . . . . . . . .  64 
      7.2 . 리소스 검색. . . . . . . . . . . . . . . . . . .  64 
        7.2.1 . 'ct'속성. . . . . . . . . . . . . . . . . . .  64
    8 . 멀티 캐스트 CoAP. . . . . . . . . . . . . . . . . . . . . . .  65 
      8.1 . 메시징 계층. . . . . . . . . . . . . . . . . . . . .  65 
      8.2 . 요청 / 응답 계층. . . . . . . . . . . . . . . . .  66 
        8.2.1 . 캐싱. . . . . . . . . . . . . . . . . . . . . . .  67 
        8.2.2 . 프록 싱. . . . . . . . . . . . . . . . . . . . . .  67 
    9 . CoAP 보안. . . . . . . . . . . . . . . . . . . . . . . .  68 
      9.1 . DTLS 보안 CoAP. . . . . . . . . . . . . . . . . . . .  69 
        9.1.1 . 메시징 계층. . . . . . . . . . . . . . . . . . .  70
        9.1.2 . 요청 / 응답 계층. . . . . . . . . . . . . . .  71 
        9.1.3 . 끝점 ID. . . . . . . . . . . . . . . . . .  71 
    10 . CoAP와 HTTP 간의 교차 프로토콜 프록시. . . . . . . .  74 
      10.1 . CoAP-HTTP 프록시. . . . . . . . . . . . . . . . . . .  75 
        10.1.1 . 가져 오기 . . . . . . . . . . . . . . . . . . . . . . . .  76 
        10.1.2 . PUT. . . . . . . . . . . . . . . . . . . . . . . .  77 
        10.1.3 . 삭제. . . . . . . . . . . . . . . . . . . . . . .  77 
        10.1.4 . 게시하다 . . . . . . . . . . . . . . . . . . . . . . . .  77 
      10.2. HTTP-CoAP 프록시. . . . . . . . . . . . . . . . . . .  77 
        10.2.1 . 옵션 및 추적. . . . . . . . . . . . . . . . .  78 
        10.2.2 . 가져 오기 . . . . . . . . . . . . . . . . . . . . . . . .  78 
        10.2.3 . HEAD. . . . . . . . . . . . . . . . . . . . . . . .  79 
        10.2.4 . 게시하다 . . . . . . . . . . . . . . . . . . . . . . . .  79 
        10.2.5 . PUT. . . . . . . . . . . . . . . . . . . . . . . .  79 
        10.2.6 . 삭제. . . . . . . . . . . . . . . . . . . . . . .  80 
        10.2.7 . 연결. . . . . . . . . . . . . . . . . . . . . .  80 
    11. 보안 고려 사항. . . . . . . . . . . . . . . . . . .  80 
      11.1 . 프로토콜 구문 분석 및 URI 처리. . . . . . . .  80 
      11.2 . 프록 싱 및 캐싱. . . . . . . . . . . . . . . . . .  81 
      11.3 . 증폭 위험. . . . . . . . . . . . . . . . .  81 
      11.4 . IP 주소 스푸핑 공격. . . . . . . . . . . . . .  83 
      11.5 . 교차 프로토콜 공격. . . . . . . . . . . . . . . . .  84 
      11.6 . 제약 노드 고려 사항. . . . . . . . . . . .  86 
    12 . IANA 고려 사항. . . . . . . . . . . . . . . . . . . . .  86 
      12.1. CoAP 코드 레지스트리. . . . . . . . . . . . . . . . . .  86 
        12.1.1 . 방법 코드. . . . . . . . . . . . . . . . . . . .  87 
        12.1.2 . 응답 코드. . . . . . . . . . . . . . . . . . .  88 
      12.2 . CoAP 옵션 번호 레지스트리. . . . . . . . . . . . . .  89 
      12.3 . CoAP 콘텐츠 형식 레지스트리. . . . . . . . . . . . .  91 
      12.4 . URI 체계 등록. . . . . . . . . . . . . . . .  93 
      12.5 . 보안 URI 체계 등록. . . . . . . . . . . . .  94 
      12.6 . 서비스 이름 및 포트 번호 등록. . . . . . .  95 
      12.7. 안전한 서비스 이름 및 포트 번호 등록. . . .  96 
      12.8 . 멀티 캐스트 주소 등록. . . . . . . . . . . . .  97 
    13 . 감사의 말. . . . . . . . . . . . . . . . . . . . . .  97 
    14 . 참조. . . . . . . . . . . . . . . . . . . . . . . . .  98 
      14.1 . 표준 참조. . . . . . . . . . . . . . . . . .  98 
      14.2 . 유익한 참조. . . . . . . . . . . . . . . . . 100 
    부록 A . 예. . . . . . . . . . . . . . . . . . . . . . 104 
    부록 B . URI 예. . . . . . . . . . . . . . . . . . . . 110


## 1 . Introduction

- 인터넷에서의 웹 서비스 (웹 API)의 사용은  
대부분의 애플리케이션에서 보편적으로 사용되고 있으며,  
웹의 기본인 Representational State Transfer(REST) 아키텍처를 따름.

- CoRE (Constrained RESTful Environments)
  - 가장 제한된 노드/네트워크에 적합한 형태로   
  REST 아키텍처를 실현하는 것이 목표.  
    - node : RAM과 ROM이 제한된 8비트 마이크로컨트롤러
    - network : 6LoWPAN, [RFC4944]
  - 6LoWPAN과 같은 제한된 네트워크는  
  IPv6 패킷을 작은 링크 계층 프레임으로 조각화하는 기능을 지원하지만,  
  이로 인해 패킷 전송 가능성이 크게 감소합니다.  
  - CoAP의 설계 목표 중 하나는   
  메시지 오버헤드를 작게 유지하여 단편화의 필요성을 제한하는 것.

- CoAP의 주요 목표 중 하나는  
  제한된 환경의 특별한 요구 사항을 고려한 애플리케이션을 위한
  일반적(범용적) 웹 프로토콜을 설계하는 것입니다.  
  - 특히 에너
  - 빌딩 자동화   
  - 기타 기계 대 기계(M2M)   
  
- CoAP의 목표 
  - HTTP 을 맹목적으로 압축하는 것이 아님  
  - HTTP와 공통적이지만 M2M 애플리케이션에 최적화된 REST의 서브셋을 실현하는 것.   
  - 간단한 HTTP 인터페이스를 보다 컴팩트한 프로토콜로 개조하는 데 사용될 수 있음  
  - 더 중요한 것은 CoAP가 내장된 검색, 멀티캐스트 지원,  
  비동기 메시지 교환과 같은 M2M을 위한 기능도 제공한다는 점이다.  

- 본 문서는 멀티캐스트 지원, 매우 낮은 오버헤드 및 제한된 환경 및  
M2M 애플리케이션에 대한 단순성과 같은 전문 요구사항을 충족하면서  
기존 웹과의 통합을 위해 HTTP로 쉽게 변환하는  
CoAP(Contracted Application Protocol)를 명시한다.

### 1.1 . Features
- 제한된 환경에서 M2M 요구 사항을 충족하는 웹 프로토콜 환경
-  유니 캐스트 및 멀티 캐스트 요청을 지원하는  
선택적 안정성을 가진 UDP [ RFC0768 ] 바인딩 
- 비동기 메시지 교환.
- 낮은 헤더 오버 헤드 및 구문 분석 복잡성.
- URI 및 콘텐츠 유형 지원.
- 간단한 프록시 및 캐싱 기능.
- 상태 비저장 HTTP 매핑  
  - 동일한 방식으로 HTTP를 통해 CoAP 리소스에 대한 액세스를 제공하는 프록시를 구축  
  - 또는 CoAP를 통해 HTTP 단순 인터페이스를 대체하여 실현하도록 허용
- DTLS (Datagram Transport Layer Security)에 대한 보안 바인딩[ RFC6347 ].

### 1.2 . Terminology

- 다음 키워드는 모두 대문자(CAPS)로 표시되는 경우   
[RFC2119]에 설명된 대로 해석해야 한다.
- 또한 이 단어들은 규범 적 의미가 없는 소문자로 이 문서에 나타날 수 있음.
   - MUST / REQUIRED / SHALL

         사양의 절대 요구 사항입니다.

   - MUST NOT / SHALL NOT

         사양의 절대 금지입니다.

   - SHOULD / RECOMMENDED 

         특정 상황에서 특정 항목을 무시하는 타당한 이유가 있을 수 있지만  
         다른 과정을 선택하기 전에 전체 의미를 이해하고 신중하게 검토해야 합니다.

   -SHOULD NOT / NOT RECOMMENDED

         특정 행동이 허용되거나 심지어 유용할 때 특정 상황에서 유효한 이유가 있을 수 있지만  
         이 레이블에 설명된 행동을 구현하기 전에 전체 의미를 이해하고 사례를 신중하게 검토해야 함을 의미합니다. .

   -MAY / OPTION

         항목이 실제로 선택 사항임을 의미합니다.  
         한 공급업체는 특정 시장에서 필요로 하거나 공급업체가 제품을 향상시킨다고 느끼는 반면  
         다른 공급업체는 동일한 품목을 생략할 수 있기 때문에 품목을 포함하도록 선택할 수 있습니다.  
         특정 옵션을 포함하지 않는 구현은 기능이 감소하더라도 옵션을 포함하는 다른 구현과 상호 운용할 수 있도록 준비해야 합니다(MUST).  
         같은 맥락에서 특정 옵션을 포함하는 구현은 다른 구현과 상호 운용할 수 있도록 준비해야 합니다(MUST).  
         해당 옵션은 포함하지 않습니다(물론 옵션이 제공하는 기능은 제외).
   
- [RFC2616]에서 논의된 모든 용어와 개념을 숙지할 것을 요구한다.  
  - "resource","representation", "cache", and "fresh" 등
  - HTTP RFC 7230을 RFC 7235로 업데이트하기 전에 완료된 이 규격은  
  이전 버전인 RFC 2616을 특별히 참조합니다.

- 또한 이 규격은 다음과 같은 용어를 정의한다. 
  - Endpoint
    - CoAP 프로토콜에 참여하는 엔티티.  
    - host는 인터넷 표준 사용과 일치하지만  
    구어적으로 endpoint는 "node"
    - UDP 포트 번호와 보안 연결을 포함할 수 있는  
    전송 계층 멀티플렉싱 정보에 의해 추가적으로 식별된다( 섹션 4.1 ).
  
  - sender 
    - 메시지의 시작 끝점. 
    - source endpoint.

  - Recipient 
    - 메시지의 대상 끝점. 
    - destination endpoint

  - Client
    - 요청의 시작 끝점. 
    - 응답의 목적지 끝점

  - Server
    - 요청의 대상 끝점입니다. 
    - 응답 시작 끝점

  - Origin Server
    - 특정 리소스가 있거나 생성 될 서버.

  - Intermediary
    - 서버 및 클라이언트 역할을하는 CoAP 끝점 원본 서버 
    - 추가 중개자를 통해 가능. 
    - 공통 중개자의 형태는 프록시입니다. 
    - 여러 종류의 프록시는이 사양에서 설명합니다.

  - Proxy
    - 주로 요청을 전달하고 응답을 다시 릴레이하는 중개자
    - 네임스페이스 변환 / 프로세스에서 프로토콜 변환으로 caching을 수행할 수 있음
    - 일반적인 의미에서 Proxy와는 대조적으로  
    Proxy은 일반적으로 특정 응용 프로그램 의미론을 구현하지 않는다.
    - 요청 전달의 전체 구조에서의 위치에 근거하여,  
    두 가지 일반적인 형태의 대리인이 있는데,  
    forward-proxy와 reverse-proxy.
    - 경우에 따라 단일 엔드포인트가 오리진 서버,  
    포워드프록시 또는 역프록시 역할을 할 수 있으며,  
    각 요청의 특성에 따라 전환 동작이 발생할 수 있다.

  - Forward-Proxy
    - 클라이언트가 일반적으로 로컬 구성 규칙을 통해  
    클라이언트를 대신하여 요청을 수행하도록 선택한 엔드포인트  
    - 필요한 번역을 수행한다.   
    - 일부 변환은 "coap" URI에 대한 프록시 요청과 같이 최소화된 반면,  
    다른 요청은 완전히 다른 애플리케이션 계층 프로토콜로 변환하거나 변환해야 할 수 있다.
    
  - reverse-proxy
    - 하나 이상의 다른 서버를 대표하고  
    이러한 서버를 대신하여 요청을 충족하는 엔드포인트 
    - 필요한 번역을 수행한다.   
    - Forward-proxy와는 달리,  
    클라이언트는 자신이 reverse-proxy와 통신하고 있다는 것을 모를 수 있다  
    reverse-proxy는 대상 자원의 오리진 서버인 것처럼 요청을 수신한다.

  - CoAP-CoAP Proxy
    - CoAP 요청에서 CoAP 요청으로 매핑하는 프록시
    - 서버와 클라이언트 측 모두에서 CoAP 프로토콜을 사용.
    - 교차 프록시와 대조됩니다.

  - Cross-Proxy
    - 프로토콜 간 프록시,  
    - CoAP-to-HTTP 프록시 또는 HTTP-CoAP 프록시처럼  
    서로 다른 프로토콜 사이를 번역하는 프록시다.   
    - 이 규격은  CoAP-to-CoAP 프록시의 매우 구체적인 요구를 제시하지만  
    cross-proxies에서는 더 많은 변화가 가능하다.

  - Confirmable Message
    - 일부 메시지에는 승인이 필요하다.  
    이러한 메시지를 "Confirmable"이라고 한다.   
    - 패킷이 손실되지 않을 경우 각 Confirmable 메시지는  
    Acknowledgement 유형 또는 Reset 유형의 반환 메시지를  
    정확히 한 개씩 도출한다.

  - Non-confirmable Message
    - 일부 다른 메시지에는 승인이 필요하지 않다.   
    - 이것은 특히 센서의 반복 판독과 같이  
    응용 프로그램 요건에 대해  
    정기적으로 반복되는 메시지에 적용된다. 
  
  - Acknowledgement Message
    - 특정 Confirmable 메시지가 도착했음을 인정한다.  
    - Confirmable 메시지에 캡슐화된 요청의 성패를 나타내지 않지만,  
    Piggybacked Response(아래 참조)도 포함될 수 있다.
  
  - Reset Message
    - 특정 메시지(Con / non-Con)가 수신되었음을 나타내지만  
    제대로 처리할 수 있는 일부 컨텍스트가 누락되어 있다.   
    - 이 조건은 일반적으로 수신 노드가 재부팅되고  
    메시지 해석에 필요한 일부 상태를 잊어버렸을 때 발생한다.   
    - Reset(재설정) 메시지를 유발하는 것(예: 확인 가능한 빈 메시지 전송)은  
    엔드포인트의 활성("CoAP ping")을 저렴하게 확인하는 데도 유용하다.  

  - Piggybacked Response
    - CoAP 승인(ACK) 메시지에 바로 포함  
    - 이 응답 요청서를 수령했음을 승인하기 위해 전송(섹션 5.2.1). 
    
  - Separate Response
    - 요청을 포함하는 Confirmable message가 빈 메시지로 인식될 때  
    별도의 메시지 교환으로 전송된다(제5.2.2절).
    - 예: 서버가 바로 답변을 가지고 있지 않기 때문에  

  - Empty Message
    - 코드가 0.00 인 메시지  
    - 요청도 응답도 아닙니다.
    - 빈 메시지에는 4 바이트 헤더만 있음.

  - Critical Option
    - 메시지를 적절하게 처리하려면  
    엔드포인트에서 최종적으로 메시지를 수신해야 하는 옵션(5.4.1절)  
    - 중요 옵션의 구현은 "Option"이라는 이름이 암시하듯이  
    일반적으로 선택 사항이라는 점에 주의.  
    - 지원되지 않는 Critical Option은 오류 응답 또는 메시지의 요약 거부로 이어진다.

  - Elective Option
    - 이해를 못하는 엔드포인트에서 무시하려는 옵션.   
    - 옵션을 이해하지 않더라도 메시지를 처리하는 것은 허용된다(5.4.1절).

  - Unsafe Option
    - 메시지를 안전하게 전달하기 위해  
    메시지를 수신하는 프록시가 이해해야 하는 옵션(5.4.2절)   
    - 모든 critical option이 unsafe option인 것은 아니다.

  - Safe-to-Forward Option
    - 이해를 못하는 프록시가 안전하게 전달할 수 있는 옵션.   
    - 옵션을 이해하지 않더라도 메시지를 전달하는 것은 허용된다(5.4.2절)

  - Resource Discovery
    - CoAP 클라이언트가 서버의 호스팅 된 리소스 목록을 쿼리하는 프로세스
    - 예 : 섹션 7에 정의 된 링크

  - Content-Format
    - 특정 매개 변수가 제공될 가능성이 있는  
    인터넷 미디어 유형과  
    "CoAP Content-Formats" 레지스트리에 의해 정의된  
    숫자 식별자로 식별되는  
    콘텐츠 코드 (종종 ID 콘텐츠 코드)의 조합.   
    - 자원표현의 이러한 특성의 조합보다  
    숫자 식별자에 초점이 덜 집중되어 있을 때,  
    이것을 "representation format"이라고도 한다. 

- 제한된 노드 및 제한된 노드 네트워크에 대한 추가 용어는 [RFC7228]에서 확인할 수 있다.
- 이 규격에서 "바이트"라는 용어는 "옥텟"의 동의어로 현재 관습적인 의미로 사용된다.
- 프로토콜의 모든 멀티바이트 정수는 네트워크 바이트 순서로 해석된다.     
- 산술을 사용하는 경우, 연산자 "**"가 지수를 나타내는 것을 제외하고,  
이 규격은 프로그래밍 언어 C에서 익숙한 표기법을 사용한다.

## 2 . Constrained Application Protocol
- CoAP의 상호작용 모델은 HTTP의 클라이언트/서버 모델과 유사하다.   
  - 그러나 기계와 기계 간의 상호작용으로 인해  
  일반적으로 CoAP 구현이 클라이언트와 서버 역할 모두에서 작동하게 된다.   
  - CoAP 요청은 HTTP의 요청과 동일하며,  
  클라이언트가 서버의 리소스(URI에 의해 식별됨)에 대한 작업을 요청하기 위해 전송한다.   
  - 그런 다음 서버는 응답 코드를 사용하여 응답을 보내며,  
  이 응답은 자원 표현을 포함할 수 있다.

- HTTP와 달리, CoAP는 UDP와 같은 데이터그램 지향 전송을 통해  
이러한 인터체인지들을 비동기적으로 다룬다.  
  - 이것은 선택적 신뢰성을 지원하는 메시지 계층을 이용하여  
  논리적으로 행해진다(지수적 백오프).   
  - CoAP는 확인 가능, 확인 불가, 승인, 재설정 등  
  4가지 유형의 메시지를 정의한다.  
  - 이러한 메시지 중 일부에 포함된 메서드 코드와 응답 코드는  
  요청 또는 응답을 전달하도록 한다.   
  - 네 가지 유형의 메시지의 기본 교환은  
  요청/응답 상호작용과 어느 정도 직교한다. 
  - 요청은 확인 가능한 메시지와 확인 불가능한 메시지로 전달될 수 있으며,  
  응답은 확인 메시지에서 piggybacked처럼 전달될 수 있다.     

- CoAP는 논리적으로 2계층 접근법,  
UDP와 상호작용의 비동기적 특성을 처리하는 데 사용되는 CoAP 메시징 계층,  
방법 및 응답 코드를 사용하는 요청/응답 상호작용을 사용하는 것으로 생각할 수 있다(그림 1 참조).  
그러나 CoAP는 단일 프로토콜이며, 메시징 및 요청/응답이 CoAP 헤더의 기능일 뿐입니다.


      +----------------------+
      |      Application     |
      +----------------------+
      +----------------------+  \
      |  Requests/Responses  |  |
      |----------------------|  | CoAP
      |       Messages       |  |
      +----------------------+  /
      +----------------------+
      |          UDP         |
      +----------------------+

      그림 1 : CoAP의 추상 계층화

### 2.1.  Messaging Model
- 엔드포인트 간 UDP를 통한 메시지 교환.   

- CoAP는 짧은 고정 길이 이진 헤더(4바이트)를 사용하며,  
그 뒤에 컴팩트 이진 옵션과 페이로드가 뒤따를 수 있습니다. 
이 메시지 형식은 요청과 응답에 의해 공유된다.   
CoAP 메시지 형식은 섹션 3에 명시되어 있다.   
각 메시지에는 중복 탐지 및 선택적 신뢰성에 사용되는 메시지 ID가 포함되어 있다.   
(메시지 ID는 소형이며, 16비트 크기는 기본 프로토콜 매개변수를 사용하여  
한 엔드포인트에서 다른 엔드포인트로 초당 최대 250개의 메시지를 가능하게 한다.)

- 메시지를 확인 가능 (CON)으로 표시하여 신뢰성을 제공합니다. ㅏ
   확인 가능한 메시지는 기본 시간 제한을 사용하여 재전송됩니다.
   재전송 사이의 지수 백 오프, 수신자가
   동일한 메시지 ID를 사용하여 확인 메시지 (ACK)를 보냅니다.
   이 예, 0x7d34) 해당 끝점에서; 그림 2를 참조하십시오.
   수신자가 확인 가능한 메시지를 전혀 처리 할 수없는 경우
   (즉, 적절한 오류 응답을 제공 할 수도 없음)
   승인 대신 재설정 메시지 (RST)로 응답
   (ACK).
- 메시지를 Confirmable(CON)로 표시하면 신뢰성이 제공됩니다.  
확인 가능한 메시지는  
수신자가 해당 끝점에서 동일한 메시지 ID (이 예에서는 0x7d34)의 확인 메시지 (ACK)를 보낼 때까지,  
재전송 간에 기본 시간 초과 및 지수 백오프를 사용하여 재전송됩니다.  
그림 2를 참조하십시오.  
수신자가 확인 가능 메시지를 전혀 처리할 수 없는 경우(즉, 적절한 오류 응답을 제공할 수도 없음),  
수신자는 승인(ACK) 대신 재설정 메시지(RST)로 응답합니다.

            Client              Server
               |                  |
               |   CON [0x7d34]   |
               +----------------->|
               |                  |
               |   ACK [0x7d34]   |
               |<-----------------+
               |                  |

      Figure 2: Reliable Message Transmission

-  신뢰할 수 있는 메시지 전송  
(예: 센서 데이터 스트림에서 각 단일 측정)  
이 필요 없는 메시지는 확인할 수 없는 메시지(NON)로 전송될 수 있다.  
이러한 항목은 승인되지 않았지만 중복 탐지에 대한 메시지 ID(이 예에서는 0x01a0)가 있다.  
그림 3을 참조하십시오.   
수신인이 확인할 수 없는 메시지를 처리할 수 없는 경우,  
수신인은 재설정 메시지(RST)로 회신할 수 있다. 


            Client              Server
               |                  |
               |   NON [0x01a0]   |
               +----------------->|
               |                  |

      Figure 3: Unreliable Message Transmission

- CoAP 메시지에 대한 자세한 내용은 섹션 4 참조.

- CoAP는 UDP를 통해 실행되고 멀티캐스트 IP 대상 주소의 사용도 지원하므로  
멀티캐스트 CoAP 요청이 가능합니다.  
섹션 8은 멀티캐스트 주소와 응답 정체를 피하기 위한 예방책과 함께  
CoAP 메시지의 적절한 사용에 대해 논의한다.

- 섹션 9에서 CoAP에 대해 보안 없음에서  
인증서 기반 보안에 이르기까지  
몇 가지 보안 모드가 정의되어 있습니다.  
이 문서에서는 프로토콜 보안을 위한 DTLS 바인딩을 지정합니다.  
CoAP에서의 IPsec 사용은 [IPsec-CoAP]에서 다룹니다.

### 2.2.  Request/Response Model
- CoAP 요청 및 응답 의미 체계는  
각각 메서드 코드 또는 응답 코드를 포함하는 CoAP 메시지로 전달됩니다.  
URI 및 페이로드 미디어 유형과 같은  
선택적 (또는 기본) 요청 및 응답 정보는 CoAP 옵션으로 전달됩니다.  
토큰은 기본 메시지와 독립적으로 요청에 대한 응답을 일치시키는 데 사용됩니다 (섹션 5.3).  
(토큰은 메시지 ID와는 별개의 개념입니다.)

- 요청은 Confirmable (CON) 또는 Non-confirmable (NON) 메시지로 전달되며,  
즉시 사용 가능한 경우 Confirmable 메시지에 전달 된 요청에 대한 응답은  
결과 Acknowledgment (ACK) 메시지로 전달됩니다.  
이를 섹션 5.2.1에 자세히 설명 된 피기 백 응답이라고합니다.  
(피기 백 된 응답을 전달하는 Acknowledgment 메시지가 손실되면  
클라이언트가 요청을 재전송하므로 피기 백 된 응답을 별도로 승인 할 필요가 없습니다.)  
피기 백 된 응답이있는 기본 GET 요청에 대한 두 가지 예가 그림 4에 나와 있습니다.  
4.04 (찾을 수 없음) 응답이 발생합니다.

      Client              Server       Client              Server
         |                  |             |                  |
         |   CON [0xbc90]   |             |   CON [0xbc91]   |
         | GET /temperature |             | GET /temperature |
         |   (Token 0x71)   |             |   (Token 0x72)   |
         +----------------->|             +----------------->|
         |                  |             |                  |
         |   ACK [0xbc90]   |             |   ACK [0xbc91]   |
         |   2.05 Content   |             |  4.04 Not Found  |
         |   (Token 0x71)   |             |   (Token 0x72)   |
         |     "22.5 C"     |             |   "Not found"    |
         |<-----------------+             |<-----------------+
         |                  |             |                  |

          Figure 4: Two GET Requests with Piggybacked Responses
          
- 서버가 Confirmable 메시지에 포함 된 요청에  
즉시 응답 할 수없는 경우  
클라이언트가 요청 재전송을 중지 할 수 있도록  
단순히 Empty Acknowledgment 메시지로 응답합니다.  
응답이 준비되면 서버는 새로운 Confirmable 메시지로 응답을 보냅니다  
(그런 다음 클라이언트가 확인해야 함).  
이를 그림 5에 설명하고 섹션 5.2.2에서 자세히 설명하는 "별도 응답"이라고합니다.


          Client              Server
              |                  |
              |   CON [0x7a10]   |
              | GET /temperature |
              |   (Token 0x73)   |
              +----------------->|
              |                  |
              |   ACK [0x7a10]   |
              |<-----------------+
              |                  |
              ... Time Passes  ...
              |                  |
              |   CON [0x23bb]   |
              |   2.05 Content   |
              |   (Token 0x73)   |
              |     "22.5 C"     |
              |<-----------------+
              |                  |
              |   ACK [0x23bb]   |
              +----------------->|
              |                  |

Figure 5: A GET Request with a Separate Response

- 요청이 확인 불가능한 메시지로 전송되면  
서버가 확인 가능한 메시지를 대신 보낼 수 있지만  
새 확인 불가능 메시지를 사용하여 응답이 전송됩니다.  
이러한 유형의 교환은 그림 6에 나와 있습니다. 

                        Client              Server
                           |                  |
                           |   NON [0x7a11]   |
                           | GET /temperature |
                           |   (Token 0x74)   |
                           +----------------->|
                           |                  |
                           |   NON [0x23bc]   |
                           |   2.05 Content   |
                           |   (Token 0x74)   |
                           |     "22.5 C"     |
                           |<-----------------+
                           |                  |

       Figure 6: A Request and a Response Carried in Non-confirmable
                                 Messages

- CoAP는 5.8 절에 지정된 의미를 사용하여  
HTTP와 유사한 방식으로 GET, PUT, POST 및 DELETE 메서드를 사용합니다.  
(CoAP 방법의 세부적인 의미는 HTTP 방법과 "거의 다르지 않다"[HHGTTG]  
HTTP 경험에서 가져온 직관은 일반적으로 잘 적용되지만  
실제로 현재 사양을 읽을 가치가있는 충분한 차이가 있습니다.)

- 기본 4 가지 이상의 방법은 별도의 사양으로 CoAP에 추가 할 수 있습니다.  
새로운 메서드는 반드시 요청과 응답을 쌍으로 사용할 필요는 없습니다.  
기존 메소드의 경우에도 단일 요청이 멀티 캐스트 요청 (섹션 8)  
또는 관찰 옵션 [OBSERVE]를 사용하여 여러 응답을 생성 할 수 있습니다.

- 클라이언트가 이미 URI를 구문 분석하고  
이를 호스트, 포트, 경로 및 쿼리 구성 요소로 분할하여  
효율성을 위해 기본값을 사용하므로  
서버의 URI 지원이 단순화됩니다.  
응답 코드는 섹션 5.9에 정의 된대로 몇 가지 CoAP 특정 코드가 추가 된  
HTTP 상태 코드의 작은 하위 집합과 관련됩니다.

### 2.3. Intermediaries and Caching

- 이 프로토콜은 요청을 효율적으로 수행하기 위해 응답 캐싱을 지원합니다.  
CoAP 응답과 함께 전달되는 freshness 및 유효성 정보를 사용하여  
간단한 캐싱이 활성화됩니다.  
캐시는 엔드 포인트 또는 중개자에 위치 할 수 있습니다.  
캐싱 기능은 섹션 5.6에 지정되어 있습니다.

- 프록 싱은 제한된 네트워크에서  
네트워크 트래픽 제한, 성능 개선, 절전 장치의 리소스 액세스 및 보안상의 이유로 유용합니다.  
다른 CoAP 끝점을 대신하는 요청의 프록시는 프로토콜에서 지원됩니다.  
프록시를 사용하는 경우 요청할 리소스의 URI가 요청에 포함되고  
대상 IP 주소는 프록시의 주소로 설정됩니다.  
프록시 기능에 대한 자세한 내용은 섹션 5.7을 참조하십시오.

- CoAP는 REST 아키텍처 [REST]에 따라 설계되어  
HTTP 프로토콜과 유사한 기능을 보여 주므로  
CoAP에서 HTTP로, HTTP에서 CoAP로 매핑하는 것이 매우 간단합니다.  
이러한 매핑은 CoAP를 사용하여 HTTP REST 인터페이스를 구현하거나  
HTTP와 CoAP간에 변환하는 데 사용할 수 있습니다.  
이 변환은 메서드 또는 응답 코드, 미디어 유형 및 옵션을  
해당 HTTP 기능으로 변환하는 크로스 프로토콜 프록시  
( "크로스 프록시")에 의해 수행 될 수 있습니다.  
섹션 10에서는 HTTP 매핑에 대해 자세히 설명합니다.

### 2.4. Resource Discovery
- 시스템 간 상호 작용에 중요  
- CoRE 링크 형식 [RFC6690]을 사용하여 지원
   - 섹션 7에 설명
   
## 3. Message Format
- 기본적으로 UDP를 통해 전송되는 압축 메시지 교환을 기반으로합니다  
  - 각 CoAP 메시지가 하나의 UDP 데이터 그램의 데이터 섹션을 차지.  
- DTLS (Datagram Transport Layer Security) 사용가능 (섹션 9.1 참조).  
- SMS, TCP 또는 SCTP와 같은 다른 전송에도 사용할 수 있습니다.
  - 이 경우는 문서의 범위를 벗어난 사양임.  
- UDP-lite [RFC3828] 및 UDP 제로 체크섬 [RFC6936]은 CoAP에서 지원하지 않습니다.

- CoAP 메시지는 
  - 간단한 이진 형식으로 인코딩됩니다.  
  - 메시지 형식은 고정 크기 4 바이트 헤더로 시작.  
  - 그 다음에는 가변 길이 토큰 값이옵니다.  
    - 길이는 0-8 바이트입니다.

  - 토큰 값 뒤에는 옵션 시퀀스 
    - TLV (Type-Length-Value) 형식  
    - 0 개 이상.  

  - 그 뒤 페이로드 
    - 선택적임 
    - 데이터 그램의 나머지를 차지.

                          1               2               3               4
          0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |Ver| T |  TKL  |      Code     |          Message ID           |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |   Token (if any, TKL bytes) ...
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |   Options (if any) ...
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |1 1 1 1 1 1 1 1|    Payload (if any) ...
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                                Figure 7: Message Format

- 헤더의 필드 정의.
  - Version (Ver) : 
    - 2 비트 부호없는 정수.  
    - CoAP 버전 번호를 나타냅니다.  
    - 이 사양의 구현은이 필드를 1 (01 바이너리)로 설정해야합니다.  
    - 다른 값은 향후 버전을 위해 예약되어 있습니다.  
    - 알 수 없는 버전 번호가 있는 메시지는 자동으로 무시되어야 합니다(MUST).

  - Type (T) : 
    - 2 비트 부호없는 정수.  
    - 해당 메시지의 유형을 나타냄  
      - Confirmable (0), 
      - Non-confirmable (1),  
      - Acknowledgement (2) 
      - Reset (3)  
    - 의미는 섹션 4에 정의

  - Token Length (TKL) : 
    - 4 비트 부호없는 정수.  
    - 0-8 바이트 : 가변 길이의 토큰 필드 길이  
    - 9-15 바이트 : 
      - 예약되어 있고 
      - 전송되지 않아야하며 
      - 메시지 형식 오류로 처리되어야합니다.

  - Code : 
    - 8비트 부호없는 정수,   
    - "c.dd"로 문서화되며 
      - "c"
        - 3 비트 (최상위 비트)
        - 0에서 7까지의 숫자입니다.  
      - "dd"
        - 5 비트 세부 정보 (최하위 비트)  
        - 00에서 31까지의 두 자리입니다.  
    - 클래스 
      - request  (0), 
      - success response (2),  
      - client error response (4) 
      - server error response (5)  
      - 다른 모든 클래스 값은 예약되어 있습니다.  
    - 특별한 경우 Code 0.00은 Empty 메시지를 나타냅니다.  
    - 요청의 경우 코드 필드는 요청 방법을 나타냅니다. 
    - 응답의 경우 응답 코드.  
    - 가능한 값은 CoAP 코드 레지스트리에 정의(섹션 12.1).  
    - 요청 및 응답의 의미는 섹션 5에 정의.              
       
  - 메시지 ID : 
    - 네트워크 바이트 순서의 16 비트 부호없는 정수입니다.  
    - 메시지 중복을 감지
    - 메시지 유형을 일치시키는데 사용
      - Acknowledgement/Reset 메시지를 Confirmable/Non-confirmable 로.  
    - 메시지 ID를 생성하고 메시지를 일치시키는 규칙은 섹션 4에 정의.

- Token
  - 헤더 뒤에는 토큰.  
  - 토큰 길이 필드(TKL)에 지정된대로 0-8 바이트.  
  - 토큰 값은 요청과 응답을 연관시키는 데 사용.  
  - 토큰을 생성하고 요청과 응답을 연관시키는 규칙은 섹션 5.3.1에 정의.

- Option
  - 헤더와 토큰 뒤에는 
  - 0 개 이상(섹션 3.1).   
  - 옵션 뒤에는 다음이 올 수 있음 
    - 메시지 끝, 
    - 다른 옵션  
    - 페이로드 마커 
    - 페이로드.

- 페이로드
  - 헤더, 토큰, 옵션 (있는 경우)의 뒤 
  - 선택적.  
  - 길이가 0이 아닌 경우 옵션의 끝과 페이로드의 시작을 나타내는 고정 된 1 바이트 페이로드 마커 (0xFF)가 접두사로 붙습니다.  
  - 페이로드 데이터가 
    - 있는경우 (= 길이가 0이 아닌경우)
      - 페이로드 마커 생김
        - 페이로드 접두사
        - 옵션의 끝과 페이로드의 시작을 나타냄
        - 고정 된 1 바이트 : 0xFF
      - 마커 뒤에서 UDP 데이터 그램의 끝까지 확장됩니다
      - 페이로드 길이는 데이터 그램 크기에서 계산됩니다.4
    - 없는경우 (= 길이가 0 인경우) 
      - 페이로드 마커가 없음 
      - 만약 뒤에 마커가 있으면 메시지 형식 오류로 처리되어야함.

- 구현 참고 사항 : 

  바이트 값 0xFF는 옵션 길이 또는 값 내에서도 발생할 수 있으므로  
  0xFF에 대한 간단한 바이트 단위 스캔은 페이로드 마커를 찾는 실행 가능한 기술이 아닙니다.  
  바이트 0xFF는 다른 옵션의 시작이 발생할 수있는 경우에만 페이로드 마커의 의미를 갖습니다.

### 3.1.  Option Format
- 메시지에 있는 여러 옵션을 정의    
  - 정의된 CoAP 옵션의 옵션 번호  
  - 옵션 값의 길이  
  - 옵션 값 자체를 지정.

- 옵션 번호를 직접 지정하는 대신  
인스턴스가 옵션 번호 순서대로 나타나야 하며  
인스턴스 간에 델타 인코딩이 사용됩니다.  
각 인스턴스의 옵션 번호는  
메시지의 해당 델타 및 이전 인스턴스의 옵션 번호의 합으로 계산됩니다.  
메시지의 첫 번째 인스턴스의 경우  
옵션 번호가 0인 이전 옵션 인스턴스가 가정됩니다.  
델타 0을 사용하여 동일한 옵션의 인스턴스를 여러 개 포함할 수 있습니다.

- 옵션 번호
  - "CoAP 옵션 번호" : 섹션 12.2 참조  
  - 옵션의 의미는 섹션 5.4를 참조하십시오.

        0   1   2   3   4   5   6   7   8
        +---------------+---------------+
        |               |               |
        |  Option Delta | Option Length |   1 byte
        |               |               |
        +---------------+---------------+
        \                               \
        /         Option Delta          /   0-2 bytes
        \          (extended)           \
        +-------------------------------+
        \                               \
        /         Option Length         /   0-2 bytes
        \          (extended)           \
        +-------------------------------+
        \                               \
        /                               /
        \                               \
        /         Option Value          /   0 or more bytes
        \                               \
        /                               /
        \                               \
        +-------------------------------+

              Figure 8: Option Format

- 옵션의 필드 정의.
  - 옵션 델타 : 
    - 4 비트 부호없는 정수.  
    - 0에서 12 사이의 값은 옵션 델타를 나타냅니다.  
    - 특수 구조를 위해 세 가지 값이 예약되어 있습니다.
      - 13 : 
        - 초기 바이트 뒤
        - 8 비트 부호없는 정수   
        - 옵션 델타에서 13을 뺀 값
      - 14 : 
        - 네트워크 바이트 순서 
        - 16비트 부호 없는 정수는 초기 바이트를 따르며  
        - 옵션 델타에서 269를 뺀 값을 나타냅니다.
      - 15 : 
        - 페이로드 마커 용으로 예약.   
        - 필드가 이 값으로 설정되어 있지만  
        전체 바이트가 페이로드 마커가 아닌 경우  
        이는 메시지 형식 오류로 처리되어야 합니다.
    - 결과 옵션 델타
      - 이 옵션의 옵션 번호와 이전 옵션의 옵션 번호의 차이로 사용됩니다.  
        - 또는 첫 번째 옵션의 경우 0
      - 옵션 번호는 이 옵션과 그 이전의 모든 옵션 델타 값을 단순히 합산하여 계산.
  
  - 옵션 길이 : 
    - 4 비트 부호없는 정수.  
    - 0에서 12 사이의 값은 옵션 값의 길이(바이트).  
    - 특수 구조를 위해 세 가지 값이 예약되어 있습니다.
      - 13 :  
        - 옵션 값 앞
        - 8 비트 부호없는 정수  
        - 옵션 길이에서 13을 뺀 값을 나타냅니다.
      - 14 : 
        - 네트워크 바이트 순서의  
        - 16 비트 부호없는 정수가 옵션 값이며  
        - 옵션 길이에서 269를 뺀 값을 나타냅니다.
      - 15 : 
        - 향후 사용을 위해 예약.  
        - 필드가 이 값으로 설정되면 메시지 형식 오류로 처리되어야합니다.

  - 값 : 정확히 Option Length 바이트의 시퀀스입니다.  
  옵션 값의 길이와 형식은 가변 길이 값을 정의 할 수있는 각 옵션에 따라 다릅니다.  
  이 문서에 사용 된 형식은 섹션 3.2를 참조하십시오.  
  다른 문서에 정의 된 옵션은 다른 옵션 값 형식을 사용할 수 있습니다.

  - 값: 
    - 정확히 Option Length 바이트의 시퀀스입니다. 
    - 옵션 값의 길이와 형식은 가변 길이 값을 정의할 수 있는 각 옵션에 따라 다릅니다. 
    - 이 문서에 사용된 형식은 섹션 3.2를 참조하십시오. 
    - 다른 문서에 정의된 옵션은 다른 옵션 값 형식을 사용할 수 있습니다(MAY).

### 3.2.  Option Value Formats
- 이 문서에 정의 된 옵션은 다음 옵션 값 형식을 사용합니다.
  - 비어 있음 : 길이가 0 인 바이트 시퀀스입니다.
  - opaque : 불투명 한 바이트 시퀀스.
  - uint : 
    - Option Length 필드에 지정된 바이트 수를 사용하여   
    네트워크 바이트 순서로 표현되는 음이 아닌 정수입니다.

    - 옵션 정의는 허용 가능한 바이트 수를 지정할 수 있습니다.  
    - 선택할 수 있는 경우 
      - 송신자는 가능한 한 적은 바이트로 정수를 나타내야 합니다.
        - 즉 선행 0바이트  
      - 예를 들어 
        - 숫자 0은 빈 옵션 값(바이트의 0 길이 시퀀스)으로 표시되고  
        - 숫자 값 1은 1로 단일 바이트로 표시됩니다.
          - (가장 중요한 비트 첫 번째 표기법에서 비트 조합 00000001)  
      - 수신인은 선행 0바이트의 값을 처리할 준비가 되어 있어야 합니다.

    - 구현 참고 사항: 
    
      송신자에게 허용되는 예외적인 동작은  
      템플릿에서 고정 크기 옵션을 사용하는  
      고도로 제한된 템플릿 구현(예: 하드웨어 구현)을 위한 것입니다.

  - string : 
    - 유니코드 문자열
      - UTF-8 [RFC3629]를 사용
      - Net-Unicode [RFC5198] 형식으로 인코딩  
    - 여기서와 CoAP 프로토콜에서 UTF-8 인코딩을 사용하는 다른 모든 위치에서는  
    인코딩된 문자열을 직접 사용하고  
    CoAP 프로토콜 구현에 의해 불투명 바이트 문자열로 비교할 수 있습니다.  
    CoAP 구현 내에서 표준화를 수행할 필요가 없으며,  
    표준화된 것으로 알려지지 않은 유니코드 문자열이  
    CoAP 프로토콜 외부의 소스에서 가져오는 경우는 제외됩니다.   
    또한 ASCII 문자열(특수 제어 문자를 사용하지 않음)은  
    항상 유효한 UTF-8 Net-Unicode 문자열입니다.

## 4.  Message Transmission
- CoAP 끝점간에 비동기 적으로 교환.  
  - CoAP 요청 및 응답을 전송하는 데 사용  
  - 그 의미는 섹션 5에 정의되어 있습니다.

- 안정성
  - CoAP는 UDP와 같은 신뢰할 수없는 전송  
    - CoAP 메시지가 순서없이 도착하거나  
    - 중복 된 것처럼 보이거나 
    - 예고없이 누락 될 수 있습니다.  
  - CoAP는 TCP와 같은 전송의  
  전체 기능 집합을 다시 만들려고하지 않고  
  다음과 같은 가벼운 안정성 메커니즘을 구현.  
    - Confirmable 메시지에 대한  
    지수적 백오프를 통해 간단한 중지 및 대기 재전송 신뢰성.
    - Confirmable 및 Non-confirmable 메시지 모두에 대한 중복 감지.

### 4.1. Messages and Endpoints
- CoAP 메시지의 원본 또는 대상입니다.  
  - 끝점의 특정 정의는 CoAP에 사용되는 전송에 따라 다릅니다.  
  - 이 사양에 정의 된 전송의 경우  
  사용 된 보안 모드에 따라  
  엔드 포인트가 식별됩니다 (섹션 9 참조).  
    - 보안이 없으면 엔드 포인트는  
    IP 주소와 UDP 포트 번호로만 식별됩니다.  
    - 다른 보안 모드를 사용하면  
    보안 모드에 정의 된대로 엔드 포인트가 식별됩니다.

- 다양한 유형의 메시지가 있습니다.  
메시지 유형은 CoAP 헤더의 유형 필드에서 지정합니다.

- 메시지 유형과 별도로 메시지는 요청,  
응답을 전달하거나 비어있을 수 있습니다.  
이는 CoAP 헤더의 요청 / 응답 코드 필드에 의해 신호를받으며  
요청 / 응답 모델과 관련이 있습니다.  
필드에 가능한 값은 CoAP 코드 레지스트리 (섹션 12.1)에서 유지됩니다.

- 비어있는 메시지에는 0.00으로 설정된 코드 필드가 있습니다.  
토큰 길이 필드는 0으로 설정되어야하며  
데이터 바이트는 메시지 ID 필드 뒤에 있으면 안됩니다.  
바이트가있는 경우 메시지 형식 오류로 처리해야합니다.

### 4.2.  Messages Transmitted Reliably
- 메시지의 안정적인 전송은  
CoAP 헤더에서 메시지를 Confirmable으로 표시하여 시작됩니다.  
Confirmable  메시지는 재설정 메시지를 유도하는 데만 사용되지 않는 한  
항상 요청 또는 응답을 전달합니다. 이 경우 비어 있습니다.  
수신자는 (a) 확인 메시지로 확인 가능한 메시지를 확인하거나  
(b) 메시지가 비어있는 상황을 포함하여  
수신자가 메시지를 적절하게 처리 할 컨텍스트가없는 경우  
또는 예약 된 클래스 (1 , 6 또는 7)   
메시지 형식인 경우 메시지를 거부한다.  
확인 가능한 메시지를 거부하면  
일치하는 재설정 메시지를 전송하고  
그렇지 않으면 무시하면됩니다.  
확인 메시지는 확인 가능한 메시지의 메시지 ID를 반영해야하며  
응답을 전달하거나 비어 있어야합니다 (섹션 5.2.1 및 5.2.2 참조).  
재설정 메시지는 확인 가능한 메시지의 메시지 ID를 반영해야하며 비어 있어야합니다.  
승인 또는 재설정 메시지 거부  
(승인이 요청 또는 예약 된 클래스가있는 코드를 전달하거나  
재설정 메시지가 비어 있지 않은 경우 포함)는  
자동으로 무시함으로써 영향을받습니다.  
일반적으로 확인 및 재설정 메시지의 수신자는  
확인 또는 재설정 메시지로 응답하지 않아야합니다.

- Confirmable 재전송
  - 발신자가
  - acknowledgement(또는 Reset 메시지)을 수신하거나 시도가 부족할 때까지
  - 간격은 기하 급수적으로(지수적으로) 증가 

- 재전송
  - 타임 아웃과 재전송 카운터에 의해 제어됩니다.
    - CoAP 엔드 포인트가 승인 (또는 재설정)을 기다리는 동안 전송하는  
    각 확인 가능 메시지에 대해 추적해야하는 두 가지  
  - 새로운 Confirmable 메시지의 경우 
    - 초기 타임 아웃은  
      - (ACK_TIMEOUT)과 (ACK_TIMEOUT * ACK_RANDOM_FACTOR)   
      사이의 임의 기간(종종 정수 초가 아님)으로 설정되고(섹션 4.8 참조)  
    - 재전송 카운터는 0으로 설정됩니다.  
  - timeout이 트리거되고 재전송 카운터가 MAX_RETRANSMIT 미만이면  
    - 메시지가 재전송되고 
    - 재전송 카운터가 증가하고 
    - 시간 초과가 두 배가됩니다.  
  - 메시지 전송 
    - 성공
      - 엔드 포인트가 시간 내에 승인을 받으면 전송이 성공한 것으로 간주
    - 실패
      - 재전송 카운터가 시간 초과시  
        - MAX_RETRANSMIT에 도달하거나  
        - 끝 점이 재설정 메시지를 수신하면  
      - 메시지 전송 시도가 취소되고  
      - 응용 프로그램 프로세스에 실패가 통보됩니다.  

- 정확성
  - 이 사양은 위의 이진 지수 백 오프 알고리즘을 구현하는 데 사용되는  
  클록의 정확성에 대한 강력한 요구 사항을 만들지 않습니다.
  - 특히 엔드 포인트는  
    - sleep 일정으로 인해 특정 재전송에 늦을 수 있으며  
    - 다음 일정을 따라 잡을 수 있습니다.
    - 그러나 다른 재전송 전 최소 간격은 ACK_TIMEOUT이며,  
    - (재) 전송의 전체 시퀀스는 송신자가 전송 기회를 놓칠 수 있더라도  
    MAX_TRANSMIT_SPAN의 범위 내에 있어야합니다 (섹션 4.8.2 참조).

- Confirmable 메시지를 보낸 CoAP 끝점은  
MAX_RETRANSMIT 카운터 값에 도달하기 전에도  
ACK를 얻으려는 시도를 포기할 수 있습니다.  
예를 들어, 애플리케이션이 더 이상 응답이 필요하지 않아 요청을 취소했거나  
CON 메시지가 도착했다는 다른 표시가 있는 경우.  
특히, CoAP 요청 메시지는 별도의 응답을 유도했을 수 있으며,  
이 경우 요청자에게 ACK 만 손실되었으며  
요청의 재전송은 아무 목적도 없다는 것이 분명합니다.  
그러나 응답자는 요청자의이 교차 계층 동작에 의존해서는 안됩니다.  
즉, 요청자에 의해 확인 가능한 응답이 이미 승인 된 경우에도  
요청에 대한 ACK를 생성하는 상태를 유지해야합니다.

- 재전송을 포기하는 또 다른 이유는 ICMP  
오류 수신 때문일 수 있습니다.  
ICMP 오류를 고려하고 잠재적 인 스푸핑 공격을 완화하려면  
구현시 메시지 유형 및 코드, 메시지 ID 및 토큰과 같은 CoAP 헤더 정보와  
포트 번호를 포함하여 ICMP 메시지의 원본 데이터 그램에 대한 정보를 확인해야합니다.  
UDP 서비스 API의 제한으로 인해  
이것이 가능하지 않은 경우 ICMP 오류를 무시해야합니다 (SHOULD).   
너무 큰 패킷 오류 [RFC4443] 
(IPv4 [RFC0792]에 대한 "조각화 필요 및 DF 설정")는 제대로 발생할 수 없으며  
섹션 4.6의 구현 참고 사항을 따르는 경우 무시해야합니다 (SHOULD).  
그렇지 않으면 경로 MTU 발견 알고리즘 [RFC4821]에 피드해야합니다.  
Source Quench 및 Time Exceeded ICMP 메시지는 무시해야합니다 (SHOULD).  
호스트, 네트워크, 포트 또는 프로토콜에 도달 할 수없는 오류  
또는 매개 변수 문제 오류는 적절한 확인 후  
애플리케이션에 전송 실패를 알리는 데 사용될 수 있습니다.

### 4.3.  Messages Transmitted without Reliability
- 일부 메시지에는 승인이 필요하지 않습니다.  
이는 최종 성공으로 충분한 센서의 반복 판독과 같이  
애플리케이션 요구 사항에 대해  
정기적으로 반복되는 메시지의 경우 특히 그렇습니다.

- 보다 가벼운 대안으로 메시지를 확인 불가능으로 표시하여  
메시지를 덜 안정적으로 전송할 수 있습니다.  
확인 불가능한 메시지는 항상 요청 또는 응답을 전달하며 비어 있으면 안됩니다.  
확인 불가능한 메시지는 수신자가 확인하지 않아야합니다.  
수신자는 메시지가 비어 있거나 예약 된 클래스 (1, 6 또는 7)가있는 코드를 사용하거나  
메시지 형식 오류가있는 경우를 포함하여  
메시지를 제대로 처리 할 컨텍스트가없는 경우 메시지를 거부해야합니다.  
확인 불가능한 메시지를 거부하는 것은  
일치하는 재설정 메시지를 보내는 것을 포함 할 수 있으며  
재설정 메시지를 제외하고 거부 된 메시지는 조용히 무시되어야합니다.

- CoAP 수준에서는 확인 불가능한 메시지가 수신되었는지 여부를 발신자가 감지 할 수있는 방법이 없습니다.  
발신자는 MAX_TRANSMIT_SPAN 내에서 확인 불가능한 메시지의 여러 사본을 전송하도록 선택할 수 있습니다  
(특히 4.7 절의 조항에 의해 제한, 특히 응답이 수신되지 않는 경우 PROBING_RATE에 의해 제한됨),  
그렇지 않으면 네트워크가 전송중인 메시지를 복제 할 수 있습니다.  
수신자가 메시지에 대해 한 번만 작동 할 수 있도록 하려면  
확인 불가능한 메시지도 메시지 ID도 지정합니다.  
(이 메시지 ID는 확인 가능한 메시지의 메시지 ID와 동일한 숫자 공간에서 가져옵니다.)

- 섹션 4.2 및 4.3을 요약하면  
표 1에서와 같이 네 가지 메시지 유형을 사용할 수 있습니다.  
"*"는 조합이 정상 작동에서 사용되지 않고 재설정 메시지  
( "CoAP ping")를 유도하는 데만 사용됨을 의미합니다.

      +----------+-----+-----+-----+-----+
      |          | CON | NON | ACK | RST |
      +----------+-----+-----+-----+-----+
      | Request  | X   | X   | -   | -   |
      | Response | X   | X   | X   | -   |
      | Empty    | *   | -   | X   | X   |
      +----------+-----+-----+-----+-----+

        Table 1: Usage of Message Types

### 4.4.  Message Correlation
- Acknowledgment 또는 Reset 메시지는  
해당 엔드 포인트의 추가 주소 정보와 함께  
메시지 ID를 통해 확인 가능 메시지 또는 확인 불가능 메시지와 관련됩니다.  
메시지 ID는 확인 가능 또는 확인 불가능 메시지를 보낸 사람이 생성하고  
CoAP 헤더에 포함 된 16 비트 부호없는 정수입니다.  
메시지 ID는 수신인이 확인 또는 재설정 메시지에 반영해야합니다.

- 동일한 메시지 ID는 EXCHANGE_LIFETIME (섹션 4.8.2) 내에서  
(동일한 엔드 포인트와 통신 할 때) 재사용되지 않아야합니다.

- 구현 참고 : 메시지 ID를 생성하기 위해 여러 구현 전략을 사용할 수 있습니다.  
가장 간단한 경우, CoAP 엔드 포인트는  
단일 메시지 ID 변수를 유지하여 메시지 ID를 생성합니다.  
이 변수는 대상 주소 또는 포트에 관계없이  
새 확인 가능 또는 확인 불가능 메시지가 전송 될 때마다 변경됩니다.  
많은 수의 트랜잭션을 처리하는 엔드 포인트는  
예를 들어 접두사 또는 대상 주소 당 여러 메시지 ID 변수를 유지할 수 있습니다.  
(일부 수신 엔드 포인트는 주소가 지정된 유니 캐스트 및 멀티 캐스트 패킷을 구별하지 못할 수 있으므로  
메시지 ID를 생성하는 엔드 포인트는 이들이 겹치지 않도록해야합니다.)  
프로토콜에 대한 성공적인 오프패스 공격의 가능성을 줄이기 위해  
변수의 초기 값(예: 시작 시)을 무작위로 설정할 것을 강력히 권장합니다.

- 확인 또는 재설정 메시지가  
확인 가능 또는 확인 불가능 메시지와 일치하려면  
확인 또는 재설정 메시지의 메시지 ID 및 소스 끝 점이  
확인 가능 또는 확인 불가능 메시지의 메시지 ID 및 대상 끝점과 일치해야합니다.

### 4.5.  Message Deduplication
- 수신자는 예를 들어, 첫 번째 타임아웃 전에 승인이 누락되거나 원래 발신인에게 도달하지 않았을 때, ExCHANGE_LIFETIME(제4.8.2) 내에서 동일한 확인 가능한 메시지(메시지 ID 및 소스 엔드포인트로 표시됨)를 여러 번 수신할 수 있다.  
수신자는 동일한 Acknowledgment 또는 Reset 메시지를 사용하여 Confirmable 메시지의 각 중복 사본을 확인해야하지만 메시지의 모든 요청 또는 응답을 한 번만 처리해야합니다 (SHOULD).   
이 규칙은 Confirmable 메시지가 멱 등성 (섹션 5.1 참조)이거나  
멱 등성 방식으로 처리 될 수있는 요청을 전송하는 경우 완화 될 수 있습니다.  
완화 된 메시지 중복 제거의 예 :
  - 서버는 동일한 응답 (4.2 절)으로 멱 등성 요청의 모든 재전송에 응답해야하는 요구 사항을 완화할 수 있으므로  
  메시지 ID에 대한 상태를 유지할 필요가 없습니다.  
  예를 들어, 구현은 중복 처리로 인해 발생하는 노력이 이전 응답을 추적하는 것보다 비용이 적게 드는 경우  
  GET, PUT 또는 DELETE 요청의 중복 전송을 별도의 요청으로 처리하려고 할 수 있습니다.
  - 제한된 서버는 응용 프로그램 시맨틱이 이 절충안을 유리하게 만드는 경우  
  특정 비멱 등성 요청에 대해이 요구 사항을 완화하려고 할 수도 있습니다.  
  예를 들어 POST 요청의 결과가 서버에서 일시적인 상태를 생성 한 경우  
  동일한 요청의 이전 전송이 이미 처리되었는지 여부를 추적하는 것보다  
  요청에 대해 이러한 노력을 여러 번 발생시키는 것이 비용이 적게 듭니다.  
- 수신자는 NON_LIFETIME (섹션 4.8.2) 내에서  
동일한 비 확인 메시지 (메시지 ID 및 소스 엔드 포인트로 표시됨)를 여러 번받을 수 있습니다.  
메시지의 특정 의미를 기반으로 완화 될 수있는 일반적인 규칙으로  
수신자는 중복 된 확인 불가능한 메시지를 조용히 무시하고  
메시지의 모든 요청 또는 응답을 한 번만 처리해야합니다 (SHOULD).

### 4.6.  Message Size
- 특정 링크 계층은 CoAP 메시지를 링크 계층 패킷에 맞출 수있을만큼  
작게 유지하는 데 유용하지만 (섹션 1 참조) 이는 구현 품질의 문제입니다.  
CoAP 사양 자체는 메시지 크기에 대한 상한 만 제공합니다.  
IP 패킷보다 큰 메시지는 원하지 않는 패킷 조각화를 초래합니다.  
적절하게 캡슐화 된 CoAP 메시지는 단일 IP 패킷 (즉, IP 단편화 방지)에 적합해야하며  
분명히 단일 IP 데이터 그램에 적합해야합니다.  (단일 UDP 페이로드에 적합)
경로 MTU가 목적지에 대해 알려지지 않은 경우  
1280 바이트의 IP MTU가 가정되어야합니다 (SHOULD).  
헤더 크기에 대해 알 수없는 경우 적절한 상한은 메시지 크기에 대해 1152 바이트이고  
페이로드 크기에 대해 1024 바이트입니다.

- 구현 참고 사항 : CoAP의 메시지 크기 매개 변수 선택은  
IPv6 및 오늘날의 대부분의 IPv4 경로에서 잘 작동합니다.  
(그러나 IPv4에서는 IP 조각화가 없는지 절대적으로 보장하기가 더 어렵습니다.
비정상적인 네트워크에서 IPv4 지원을 고려하는 경우  
구현시 576 바이트와 같이보다 보수적 인 IPv4 데이터 그램 크기로 제한 할 수 있습니다.
[RFC0791]에 따라 IPv4 용 IP MTU의 절대 최소값은 68 바이트로 낮아  
UDP 페이로드에 대한 보안 오버 헤드를 제외한 40 바이트 만 남게됩니다.
이 문제 세트에 매우 초점을 맞춘 구현은  
IPv4 DF 비트를 설정하고 경로 MTU 검색의 일부 형식을 수행 할 수도 있습니다 [RFC4821];
그러나 이는 CoAP의 실제 사용 사례에서는 일반적으로 불필요합니다.)
많은 제한된 네트워크에서 더 중요한 종류의 조각화는 적응 계층에서 발생하는 것입니다  
(예 : 6LoWPAN L2 패킷은 다양한 오버 헤드를 포함하여 127 바이트로 제한됨).
이는 구현이 패킷 크기를 절약하고 3 자리 메시지 크기에 접근 할 때  
블록 단위 전송 [BLOCK]으로 이동하도록 동기를 부여 할 수 있습니다.

- 메시지 크기는 제한된 노드에서 구현할 때도 상당히 중요합니다.
많은 구현에서 들어오는 메시지에 대한 버퍼를 할당해야합니다.
구현이 너무 제한되어 위에서 언급 한 상한을 할당 할 수없는 경우  
DTLS 보안을 사용하지 않는 메시지에 대해 다음 구현 전략을 적용 할 수 있습니다.
너무 작은 버퍼로 데이터 그램을 수신하는 구현은  
일반적으로 데이터 그램의 후행 부분이 삭제되었는지 여부를 판별하고  
초기 부분을 검색 할 수 있습니다.  
따라서 모든 페이로드가 아니라면 적어도 CoAP 헤더와 옵션은 버퍼에 맞을 가능성이 높습니다.  
따라서 서버는 요청을 완전히 해석하고  
페이로드가 잘린 경우 4.13 (요청 엔터티가 너무 큼; 섹션 5.9.2.9 참조)  
응답 코드를 반환 할 수 있습니다.  
멱등 요청을 보내고 버퍼에 맞는 것보다 큰 응답을받는 클라이언트는  
블록 옵션 [BLOCK]에 적합한 값으로 요청을 반복 할 수 있습니다.

### 4.7.  Congestion Control
- CoAP에 대한 기본 혼잡 제어는 섹션 4.2의 지수 백 오프 메커니즘에 의해 제공됩니다.

- 혼잡을 일으키지 않기 위해 클라이언트 (프록시 포함)는  
주어진 서버 (프록시 포함)에 대해 유지하는  
동시 미해결 상호 작용 수를 NSTART로 엄격하게 제한해야합니다.  
미해결 상호 작용은 ACK가 아직 수신되지 않았지만  
여전히 예상되는 CON (메시지 계층)이거나 응답이나 승인 메시지가 아직 수신되지 않았지만  
여전히 예상되는 요청 (둘 다 동시에 발생할 수 있음, 하나의 뛰어난 상호 작용으로 계산. )입니다.  
이 사양에 대한 NSTART의 기본값은 1입니다.

- 향후 추가적인 혼잡 제어 최적화 및 고려 사항이 예상되며,  
예를 들어 섹션 4.8에 정의 된 CoAP 전송 매개 변수의 자동 초기화를 제공 할 수 있으므로  
NSTART 값이 1보다 큰 값을 허용 할 수 있습니다.

- EXCHANGE_LIFETIME 이후 클라이언트는 확인 메시지가 수신되지 않은 확인 가능 요청에 대한 응답을 기대하지 않습니다.

- 클라이언트가 확인 된 확인 가능한 요청 또는 확인 불가능한 요청에 대한 응답을  
"기대"하기 위해 중지하는 특정 알고리즘은 정의되어 있지 않습니다.  
추가 혼잡 제어 최적화에 의해 수정되지 않는 한,  
엔드 포인트가 응답하지 않는 다른 엔드 포인트로 전송할 때   
평균 데이터 속도 PROBING_RATE를 초과하지 않는 방식으로 선택해야합니다.

- 참고 : CoAP는 대부분 클라이언트에게 혼잡 제어의 부담을줍니다.  
그러나 클라이언트는 오작동하거나 실제로 공격자가 될 수 있습니다 (예 : 증폭 공격 수행) (섹션 11.3).  
(네트워크 및 자체 에너지 자원에 대한) 손상을 제한하기 위해 서버는  
애플리케이션 요구 사항에 대한 합리적인 가정을 기반으로  
응답 전송에 대해 일부 속도 제한을 구현해야합니다 (SHOULD).  
이는 속도 제한이 오작동하는 엔드 포인트에 대해서만 효과적 일 수있는 경우 가장 유용합니다.

### 4.8.  Transmission Parameters
- 메시지 전송은 다음 매개 변수에 의해 제어됩니다.

      +-------------------+---------------+
      | name              | default value |
      +-------------------+---------------+
      | ACK_TIMEOUT       | 2 seconds     |
      | ACK_RANDOM_FACTOR | 1.5           |
      | MAX_RETRANSMIT    | 4             |
      | NSTART            | 1             |
      | DEFAULT_LEISURE   | 5 seconds     |
      | PROBING_RATE      | 1 byte/second |
      +-------------------+---------------+

        Table 2: CoAP Protocol Parameters

#### 4.8.1. Changing the Parameters

- ACK_TIMEOUT, ACK_RANDOM_FACTOR, MAX_RETRANSMIT,  
NSTART, DEFAULT_LEISURE (섹션 8.2) 및 PROBING_RATE의 값은  
동적으로 조정 된 값을 포함하여 응용 프로그램 환경에 특정한 값으로 구성 될 수 있습니다.  
그러나 구성 방법은이 문서의 범위를 벗어납니다.  
애플리케이션 환경은 이러한 매개 변수에 대해 일관된 값을 사용하는 것이 좋습니다.  
애플리케이션 환경에서 일관되지 않은 값으로 작동하는 특정 효과는 본 명세서의 범위를 벗어납니다.

- 전송 매개 변수는 인터넷에서 안전한 혼잡 상태에서 동작을 달성하기 위해 선택되었습니다.  
구성에서 다른 값을 사용하려는 경우 이러한 혼잡 제어 속성을 위반하지 않도록 구성에 책임이 있습니다.  
특히 ACK_TIMEOUT을 1 초 미만으로 줄이면 [RFC5405]의 지침에 위배됩니다.  
([RTO-CONSIDER]는 몇 가지 추가 배경 정보를 제공합니다.)  
CoAP는 왕복 시간 (RTT) 측정을 유지하지 않는 구현을 가능하게하도록 설계되었습니다.  
그러나 ACK_TIMEOUT을 크게 줄이거나 NSTART를 늘리려는 경우  
이러한 측정을 유지할 때만 안전하게 수행 할 수 있습니다.  
구성은 구성 또는 향후 표준 문서에 정의 된 혼잡 제어 안전을 보장하는 메커니즘을 사용하지 않고  
ACK_TIMEOUT을 줄이거 나 NSTART를 늘리면 안됩니다.

- ACK_RANDOM_FACTOR는 1.0 미만으로 감소되어서는 안되며,  
동기화 효과로부터 일부 보호를 제공하기 위해  
1.0과 충분히 다른 값을 가져야합니다 (SHOULD).

- MAX_RETRANSMIT는 자유롭게 조정할 수 있지만  
너무 작은 값은 Confirmable 메시지가 실제로 수신 될 확률을 줄이며  
여기에 제공된 것보다 큰 값은 시간 값을 추가로 조정해야합니다 (섹션 4.8.2 참조).

- 전송 매개 변수의 선택이 파생 된 시간 값의 증가로 이어지는 경우 (섹션 4.8.2 참조),  
구성 메커니즘은 조정 된 값이 통신에 사용되는 모든 엔드 포인트에서도  
조정 된 값을 사용할 수 있는지 확인해야합니다.

#### 4.8.2.  Time Values Derived from Transmission Parameters

- ACK_TIMEOUT, ACK_RANDOM_FACTOR 및  
MAX_RETRANSMIT의 조합은 재전송 타이밍에 영향을 미치며,  
이는 다시 구현에서 특정 정보 항목을 유지해야하는 기간에 영향을줍니다.  
이러한 파생 된 시간 값을 모호하지 않게 참조 할 수 있도록  
다음과 같이 이름을 지정합니다.
  - MAX_TRANSMIT_SPAN은 Confirmable 메시지의 첫 번째 전송부터 마지막 재전송까지의 최대 시간입니다.  
  기본 전송 매개 변수의 경우 값은 (2 + 4 + 8 + 16) * 1.5 = 45 초 또는  
  일반적으로 다음과 같습니다.

        ACK_TIMEOUT * ((2 ** MAX_RETRANSMIT)-1) * ACK_RANDOM_FACTOR

  - MAX_TRANSMIT_WAIT는 Confirmable 메시지가 처음 전송 된 후 보낸 사람이 승인  
  또는 재설정 수신을 포기할 때까지의 최대 시간입니다.  
  기본 전송 매개 변수의 경우 값은 (2 + 4 + 8 + 16 + 32) * 1.5 = 93 초 또는  
  일반적으로 다음과 같습니다.

        ACK_TIMEOUT * ((2 ** (MAX_RETRANSMIT + 1))-1) * ACK_RANDOM_FACTOR

- 또한 네트워크와 노드의 특성에 대한 몇 가지 가정이 필요합니다.
  - MAX_LATENCY는 데이터 그램이 전송 시작부터 수신 완료까지 걸릴 것으로 예상되는 최대 시간입니다.  
  이 상수는 [RFC0793]의 MSL(최대 세그먼트 수명)과 관련이 있으며,  
  이는 "임의적으로 2분으로 정의된다"([RFC0793] 용어집, 81페이지).
  MAX_LATENCY는 프로토콜이 잘 작동하는 상황을 설명하기위한 것이 아니라  
  프로토콜이 보호해야하는 최악의 상황을 설명하기위한 것이므로  
  이 값은 반드시 MAX_TRANSMIT_WAIT보다 작지는 않습니다.  
  또한 임의로 MAX_LATENCY를 100 초로 정의합니다.  
  이 값은 TCP에 대한 역사적 선택에 근접 하고   
  대부분 구성에 대해 합리적으로 현실적 일뿐만 아니라  
  메시지 ID 수명 타이머를 8 비트로 표시 할 수 있습니다 (초 단위로 측정시).  
  이 계산에서는 전송 방향이 무관하다는 가정이 없습니다 (즉, 네트워크가 대칭 적이라는 가정).  
  다만 동일한 값이 양방향의 최대 값으로 합리적으로 사용될 수 있다는 가정이 있습니다.  
  그렇지 않은 경우 다음 계산이 약간 더 복잡해집니다.

  - PROCESSING_DELAY는 노드가 확인 가능한 메시지를 승인으로 전환하는 데 걸리는 시간입니다.  
  우리는 노드가 보낸 사람이 시간 초과되기 전에 ACK를 보내려고한다고 가정하므로  
  보수적 인 가정으로 ACK_TIMEOUT과 동일하게 설정합니다.

  - MAX_RTT는 최대 왕복 시간입니다.

        (2 * MAX_LATENCY) + PROCESSING_DELAY

- 이 값에서 프로토콜 작업과 관련된 다음 값을 도출 할 수 있습니다.

  - EXCHANGE_LIFETIME은 Confirmable 메시지 전송 시작부터  
  승인이 더 이상 예상되지 않을 때까지의 시간입니다.  
  즉, 메시지 교환에 대한 메시지 계층 정보를 제거 할 수 있습니다.  
  EXCHANGE_LIFETIME에는 MAX_TRANSMIT_SPAN, MAX_LATENCY 포워드,  
  PROCESSING_DELAY 및 뒤로 돌아 가기위한 MAX_LATENCY가 포함됩니다.  
  마지막 대기 기간  
  (ACK_TIMEOUT * (2 ** MAX_RETRANSMIT) 또는 MAX_TRANSMIT_SPAN과 MAX_TRANSMIT_WAIT)의 차이가  
  MAX_LATENCY보다 작도록 구성을 선택한 경우  
  MAX_TRANSMIT_WAIT를 고려할 필요가 없습니다.  
  MAX_LATENCY는 실제 세계에서 만날 가능성이 거의없는 최악의 경우 값이므로 선택 가능성이 높습니다.  
  이 경우 EXCHANGE_LIFETIME은 다음과 같이 단순화됩니다.

        MAX_TRANSMIT_SPAN + (2 * MAX_LATENCY) + PROCESSING_DELAY
        
    또는 기본 전송 매개 변수로 247 초.

  - NON_LIFETIME은 확인 불가능한 메시지를 보낸 후 메시지 ID를 안전하게 재사용 할 수있는 시간까지의 시간입니다.  
  NON 메시지의 다중 전송이 사용되지 않는 경우  
  값은 MAX_LATENCY 또는 100 초입니다.  
  그러나 CoAP 보낸 사람은 특히 멀티 캐스트 응용 프로그램의 경우  
  NON 메시지를 여러 번 보낼 수 있습니다.  
  재사용 기간은 사양에 의해 제한되지 않지만  
  수신기에서 신뢰할 수있는 중복 감지에 대한 기대치는 MAX_TRANSMIT_SPAN의 시간 척도에 있습니다.  
  따라서이를 위해 다음 값을 사용하는 것이 더 안전합니다.

        MAX_TRANSMIT_SPAN + MAX_LATENCY

    또는 기본 전송 매개 변수로 145 초; 그러나 메시지 ID 사용 중지에 단일 시간 제한 값을 사용하려는 구현에서는 EXCHANGE_LIFETIME에 더 큰 값을 안전하게 사용할 수 있습니다.

- 표 3에는이 하위 섹션에 소개 된 파생 매개 변수가 기본값과 함께 나열되어 있습니다.

      +-------------------+---------------+
      | name              | default value |
      +-------------------+---------------+
      | MAX_TRANSMIT_SPAN |          45 s |
      | MAX_TRANSMIT_WAIT |          93 s |
      | MAX_LATENCY       |         100 s |
      | PROCESSING_DELAY  |           2 s |
      | MAX_RTT           |         202 s |
      | EXCHANGE_LIFETIME |         247 s |
      | NON_LIFETIME      |         145 s |
      +-------------------+---------------+

      Table 3: Derived Protocol Parameters

## 5.  Request/Response Semantics
- CoAP는 HTTP와 유사한 요청 / 응답 모델에서 작동합니다.  
"클라이언트"역할의 CoAP 엔드 포인트는  
하나 이상의 CoAP 요청을 "서버"로 보내며 CoAP 응답을 보내 요청을 처리합니다.  
HTTP와 달리 요청과 응답은 이전에 설정된 연결을 통해 전송되지 않고  
CoAP 메시지를 통해 비동기 적으로 교환됩니다.

### 5.1.  Requests
- CoAP 요청은 리소스에 적용 할 방법, 리소스 식별자,  
페이로드 및 인터넷 미디어 유형 (있는 경우),  
요청에 대한 선택적 메타 데이터로 구성됩니다.

- CoAP는 HTTP에 쉽게 매핑되는 GET, POST, PUT 및 DELETE의 기본 메서드를 지원합니다.  
HTTP ([RFC2616]의 섹션 9.1 참조)과 동일한 속성 (검색 만 가능) 및 멱등 (동일한 효과로 여러 번 호출 할 수 있음)이 있습니다.  
GET 메소드는 안전합니다.  
따라서 검색 이외의 리소스에 대해 다른 조치를 취해서는 안됩니다.  
GET, PUT 및 DELETE 메소드는 멱 등성이있는 방식으로 수행되어야합니다.  
POST는 그 효과가 원본 서버에 의해 결정되고  
대상 리소스에 따라 달라지기 때문에 멱 등성이 아닙니다.  
일반적으로 새 리소스가 생성되거나 대상 리소스가 업데이트됩니다.

- 요청은 Confirmable 또는 Non-confirmable 메시지의 CoAP 헤더에있는 Code 필드를 Method Code로 설정하고  
요청 정보를 포함하여 시작됩니다.

- 요청에 사용되는 방법은 섹션 5.8에 자세히 설명되어 있습니다.4

### 5.2.  Responses
- 요청을 수신하고 해석 한 후  
서버는 클라이언트가 생성 한 토큰 (5.3 절)을 통해  
요청과 일치하는 CoAP 응답으로 응답합니다.  
이 응답은 확인 가능한 메시지를 확인에 일치시키는 메시지 ID와 다릅니다.

- 응답은 응답 코드로 설정되는 CoAP 헤더의 코드 필드로 식별됩니다.  
HTTP 상태 코드와 유사하게 CoAP 응답 코드는  
요청을 이해하고 충족하려는 시도의 결과를 나타냅니다.  
이 코드는 섹션 5.9에 완전히 정의되어 있습니다.  
CoAP 헤더의 코드 필드에 설정되는 응답 코드 번호는  
CoAP 응답 코드 레지스트리 (섹션 12.1.2)에서 유지됩니다.

                               1
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |class|  detail |
                +-+-+-+-+-+-+-+-+

        Figure 9: Structure of a Response Code

- 8 비트 응답 코드 번호의 상위 3 비트는 응답 클래스를 정의합니다.  
하위 5 개 비트에는 분류 역할이 없습니다.  
전체 클래스에 추가 세부 정보를 제공합니다 (그림 9).

- 사양 및 프로토콜 진단을위한 사람이 읽을 수있는 표기법으로  
응답 코드를 포함한 CoAP 코드 번호는 "c.dd"형식으로 문서화됩니다.  
여기서 "c"는 10 진수로 된 클래스이고 "dd"는 2-자리 십진로 된 세부 사항입니다.   
예를 들어 "Forbidden"은 4.03으로 기록됩니다.  
이는 16 진수 0x83 (4*0x20+3) 또는 10 진수 131 (4*32+3)의 8 비트 코드 값을 나타냅니다.

- 응답 코드에는 3 가지 클래스가 있습니다.
  - 2-성공 : 요청이 성공적으로 수신, 이해 및 수락되었습니다.
  - 4-클라이언트 오류 : 요청에 잘못된 구문이 포함되어 있거나 수행 할 수 없습니다.
  - 5-서버 오류 : 서버가 명백하게 유효한 요청을 수행하지 못했습니다.

- 응답 코드는 확장 가능하도록 설계되었습니다.  
끝점에서 인식 할 수없는 클라이언트 오류 또는 서버 오류 클래스의 응답 코드는  
해당 클래스의 일반 응답 코드 (각각 4.00 및 5.00)와 동일한 것으로 처리됩니다.  
그러나 성공을 나타내는 일반적인 응답 코드가 없으므로  
엔드 포인트에서 인식하지 못하는 Success 클래스의 응답 코드는  
추가 세부 정보없이 요청이 성공했는지 확인하는 데만 사용할 수 있습니다.

- 가능한 응답 코드는 섹션 5.9에 자세히 설명되어 있습니다.

- 응답은 다음 하위 섹션에 정의 된 여러 방법으로 보낼 수 있습니다.

#### 5.2.1.  Piggybacked

- 가장 기본적인 경우 응답은 요청을 승인하는 승인 메시지로 직접 전달됩니다  
(요청이 확인 가능한 메시지로 전달되어야 함).  
이를 "피기 백 응답"이라고합니다.

- 응답이 성공 또는 실패를 나타내는 지 여부에 관계없이  
응답은 승인 메시지에 반환됩니다.  
실제로 응답은 Acknowledgment 메시지에 피기 백되며  
응답을 반환하는 데 별도의 메시지가 필요하지 않습니다.

  - 구현 참고 사항 : 프로토콜은 서버에 응답을 피기 백할지 여부  
  (즉, 별도의 응답을 전송) 여부를 결정합니다.  
  클라이언트는 둘 중 하나를받을 준비가되어 있어야합니다.  
  구현 품질(quality-of-implementation) 수준에서는  
  서버가 가능할 때마다 피기 백 할 코드를 구현할 것이라는 강한 기대가 있습니다.  
  즉, 네트워크와 클라이언트 및 서버 모두에서 리소스를 절약합니다.

#### 5.2.2.  Separate
- 모든 경우에 피기 백 된 응답을 반환하지 못할 수도 있습니다.  
예를 들어, 서버는 클라이언트가 요청 메시지를  
반복적으로 재전송하는 위험을 감수하지 않고  
확인 메시지를 다시 보낼 때까지 기다리는 것보다  
요청 된 리소스의 표현을 얻는 데 더 오래 필요할 수 있습니다  
(섹션 4.8.2의 PROCESSING_DELAY 설명 참조).  
확인 불가능한 메시지로 전달 된 요청에 대한 응답은  
항상 별도로 전송됩니다 (확인 메시지가 없기 때문).

- 서버에서 이를 구현하는 한 가지 방법은  
리소스 표현을 얻으려는 시도를 시작하고  
진행중인 동안 승인 타이머를 시간 초과하는 것입니다.  
또는 서버는 피기 백 된 응답이 없다는 것을 미리 알고있는 경우  
즉시 승인을 보낼 수도 있습니다.  
두 경우 모두 승인은 요청이 나중에 처리 될 것이라는 약속입니다.

- 서버가 마침내 리소스 표현을 획득하면 응답을 보냅니다.  
이 메시지가 손실되지 않기를 원하면  
서버에서 클라이언트로 확인 가능한 메시지로 전송되고  
클라이언트가 확인과 함께 응답하여  
서버에서 선택한 새 메시지 ID를 반영합니다.  
(확인할 수없는 메시지로도 전송 될 수 있습니다. 섹션 5.2.3을 참조하십시오.)

- 서버가 별도의 응답을 사용하기로 선택하면  
확인 가능 요청에 대한 확인을 Empty 메시지로 보냅니다.  
서버가 Empty Acknowledgement를 다시 보내면  
클라이언트가 다른 동일한 요청을 다시 전송하더라도  
다른 Acknowledgement에서 응답을 다시 보내면 안됩니다.  
재전송 된 요청이 수신되면 (아마도 원래 승인이 지연 되었기 때문에)  
다른 빈 승인이 전송되고 모든 응답은 별도의 응답으로 전송되어야합니다.

- 서버가 확인 가능한 응답을 전송하면  
해당 응답에 대한 클라이언트의 승인도 빈 메시지 여야합니다  
(요청도 응답도 전달하지 않는 메시지).  
서버는 일치하는 승인 (응답 코드 또는 페이로드를 자동으로 무시) 또는  
재설정 메시지에 대한 응답 재전송을 중지해야합니다.

- 구현 참고 사항 : 기본 데이터 그램 전송이 시퀀스 보존이 아닐 수 있으므로  
응답을 전달하는 확인 가능 메시지가 실제로 요청에 대한 승인 메시지 이전 또는  
이후에 도착할 수 있습니다.  
재전송 시퀀스를 종료 할 목적으로 이것은 또한 승인 역할을합니다.  
CoAP 프로토콜 자체는 여기에서 특정 요구를하지 않지만  
애플리케이션 관점에서 타당한 시간 프레임 내에 응답이 올 것이라는 기대가 있습니다.  
연결 유지 메커니즘을 실행하도록 지시 할 수있는 기본 전송 프로토콜이 없기 때문에 요청자는 서버가 파괴되거나 응답을 보낼 수없는 경우  
CoAP의 재전송 타이머와 관련이없는 제한 시간을 설정할 수 있습니다.

#### 5.2.3.  Non-confirmable
- 요청 메시지가 Non-confirmable이면  
응답도 Non-confirmable 메시지로 반환되어야 합니다(SHOULD).  
그러나 끝점은 확인 가능 요청에 대한 응답으로  
비확인 응답(앞 또는 뒤에 빈 확인 메시지가 옴) 또는  
확인 불가능 요청에 대한 응답으로  
확인 가능 응답을 수신할 준비가 되어 있어야 합니다(MUST).

### 5.3.  Request/Response Matching
- 응답이 전송되는 방식에 관계없이  
해당 엔드포인트의 추가 주소 정보와 함께  
클라이언트가 요청에 포함시킨 토큰을 통해 요청과 일치합니다.
- 응답을 보내는 방법에 관계없이  
클라이언트가 요청에 포함하는 토큰과 해당 끝점의 추가 주소 정보를 사용하여 요청에 일치됩니다.

#### 5.3.1.  Token
- 토큰은 요청과 응답을 일치시키는 데 사용됩니다.  
토큰 값은 0에서 8바이트의 시퀀스입니다.  
(모든 메시지는 길이가 0인 경우에도 토큰을 전달합니다.)  
모든 요청은 결과 응답에서 서버가 (수정 없이)  
반향해야 하는 클라이언트 생성 토큰을 전달합니다.

- 토큰은 동시 요청을 구별하기 위한  
클라이언트 로컬 식별자로 사용하기 위한 것입니다(섹션 5.3 참조).  
"요청 ID"라고 부를 수 있습니다.

- 클라이언트는 주어진 소스/대상 엔드포인트 쌍에 대해  
현재 사용 중인 토큰이 고유하도록 토큰을 생성해야 합니다(SHOULD).  
(클라이언트 구현은 매번 다른 끝점을 사용하는 경우(예: 다른 소스 포트 번호)  
모든 요청에 ​​대해 동일한 토큰을 사용할 수 있습니다.)  
빈 토큰 값이 적절한 상황들의 예로  
대상에 사용 중인 다른 토큰이 없는 경우  
또는 요청이 대상별로 순차적으로 이루어지고 피기백된 응답을 수신할 때 가 있다.  
그러나 이를 수행하기 위한 여러 가능한 구현 전략이 있습니다.

- 전송 계층 보안(섹션 9)을 사용하지 않고 요청을 보내는 클라이언트는  
응답 스푸핑(섹션 11.4)을 방지하기 위해 중요하지 않은 무작위 토큰을 사용해야 합니다(SHOULD).  
이러한 토큰의 보호 사용은 최대 8바이트 크기가 허용되는 이유입니다.  
토큰에 사용할 임의 구성 요소의 실제 크기는  
클라이언트의 보안 요구 사항과 응답 스푸핑으로 인한 위협 수준에 따라 다릅니다.  
일반 인터넷에 연결된 클라이언트는 인터넷에 직접 연결되지 않는 것이  
반드시 스푸핑에 대한 충분한 보호가 아니라는 점을 염두에 두고  
최소 32비트의 임의성을 사용해야 합니다(SHOULD).  
(메시지 ID는 일반적으로 순차적으로 할당되기 때문에  
보호 기능이 거의 추가되지 않습니다.  
즉, 추측 가능하고 별도의 응답을 스푸핑하여 우회할 수 있습니다.)  
토큰 길이를 최적화하려는 클라이언트는  
진행 중인 공격의 수준을 추가로 감지할 수 있습니다.  
(예: 수신 메시지에서 최근 토큰 불일치를 집계하여)  
토큰 길이를 적절하게 위쪽으로 조정합니다.  
[RFC4086]은 보안을 위한 임의성 요구 사항에 대해 설명합니다.

- 생성하지 않은 토큰을 수신하는 엔드포인트는  
토큰을 불투명한 것으로 취급하고  
콘텐츠 또는 구조에 대해 가정하지 않아야 합니다(MUST).

#### 5.3.2.  Request/Response Matching Rules

- 요청에 대한 응답을 일치시키는 정확한 규칙은 다음과 같습니다.

  1. 응답의 소스 끝점은 원래 요청의 대상 끝점과 동일해야 합니다(MUST).

  2. 피기백된 응답에서  
  확인 가능한 요청의 메시지 ID와 승인은 일치해야 하고  
  응답과 원래 요청의 토큰은 일치해야 합니다(MUST).  
  별도의 응답에서는   
  응답과 원래 요청의 토큰만 일치해야 합니다(MUST).

- 응답을 전달하는 메시지가  
예기치 않은 경우(클라이언트가 식별된 끝점,  
주소가 지정된 끝점 및/ 
또는 지정된 토큰의 응답을 기다리지 않음),  
응답은 거부됩니다(섹션 4.2 및 4.3).

- 구현 참고 사항:  
CON 메시지에서 응답을 수신한 클라이언트는  
ACK를 보낸 직후 메시지 상태를 정리하기를 원할 수 있습니다.  
해당 ACK가 손실되고 서버가 CON을 재전송하면  
클라이언트는 더 이상 이 응답을 연관시킬 상태를  
갖지 않을 수 있으므로 재전송이 예기치 않은 메시지가 됩니다.  
클라이언트는 더 이상 재전송을 받지 않도록  
재설정 메시지를 보낼 것입니다.  
이 동작은 정상이며 오류를 나타내는 것이 아닙니다.  
(상태 메모리 사용량이 적극적으로 최적화되지 않은 클라이언트는  
여전히 두 번째 CON을 재전송으로 식별하는  
메시지 상태를 갖게 됩니다.  
실제로 [OBSERVE] 서버에서  
더 많은 메시지를 기대하는 클라이언트는  
어떤 경우에도 상태를 유지해야 합니다.)

### 5.4.  Options

- 요청과 응답 모두에 하나 이상의 옵션 목록이 포함될 수 있습니다.  
예를 들어 요청의 URI는 여러 옵션으로 전송되며  
HTTP의 HTTP 헤더에 포함되는 메타데이터도 옵션으로 제공됩니다.

- CoAP는 요청과 응답 모두에 사용되는 단일 옵션 세트를 정의합니다.
  - Content-Format
  - ETag
  - Location-Path
  - Location-Query
  - Max-Age
  - Proxy-Uri
  - Proxy-Scheme
  - Uri-Host
  - Uri-Path
  - Uri-Port
  - Uri-Query
  - Accept
  - If-Match
  - If-None-Match
  - Size1

- 속성과 함께 이러한 옵션의 의미는 섹션 5.10에 자세히 정의되어 있습니다.

- 모든 방법 및 응답 코드와 함께 사용하기 위해  
모든 옵션이 정의된 것은 아닙니다.  
방법 및 응답 코드에 대한 가능한 옵션은 각각  
섹션 5.8 및 5.9에 정의되어 있습니다.  
방법 또는 응답 코드에 대해 옵션이 정의되어 있지 않은 경우에는  
발신자에 의해 포함되어서는 안되며  
수신자에 의해 인식되지 않는 옵션으로 취급되어야 합니다(MUST).

#### 5.4.1.  Critical/Elective

- 옵션은 "중요" 또는 "선택"의 두 가지 클래스 중 하나로 분류됩니다.  
이들의 차이점은 엔드포인트에서 인식하지 못하는 옵션이 처리되는 방식입니다.
  - 수신 시 "선택" 클래스의 인식할 수 없는 옵션은 조용히 무시되어야 합니다(MUST).
  - Confirmable 요청에서 발생하는 "critical" 클래스의 인식되지 않은 옵션은  
  4.02(Bad Option) 응답을 반환해야 합니다(MUST).  
  이 응답에는 인식할 수 없는 옵션을 설명하는  
  진단 페이로드가 포함되어야 합니다(섹션 5.5.2 참조).
  - Confirmable 응답에서 발생하거나  
  Acknowledgement에서 피기백되는  
  "critical" 클래스의 인식되지 않은 옵션은  
  응답이 거부되도록 해야 합니다(4.2절).
  - 확인 불가능한 메시지에서 발생하는  
  "중요" 등급의 인식되지 않은 옵션은  
  메시지가 거부되도록 해야 합니다(4.3절).

- 중요하거나 선택적인 옵션은 절대 "필수"가 아닙니다(항상 선택 사항입니다).  
이러한 규칙은 구현이 이해하지 못하거나  
구현하지 않는 옵션 처리를 중지할 수 있도록 하기 위해 정의됩니다.

- 중요/선택 규칙은 프록시가 아닌 끝점에 적용됩니다.  
프록시는 섹션 5.7에 정의된 대로  
Unsafe/Safe-to-Forward 클래스를 기반으로 옵션을 처리합니다.

#### 5.4.2.  Proxy Unsafe or Safe-to-Forward and NoCacheKey

- 중요 또는 선택으로 표시된 옵션 외에도  
옵션은 프록시가 옵션을 인식하지 못하는 경우  
해당 옵션을 처리하는 방법에 따라 분류됩니다.  
이를 위해 옵션은 전달하기에 안전하지 않음(UnSafe가 설정됨)  
또는 전달 안전(UnSafe가 해제됨)으로 간주될 수 있습니다.

- 또한 Safe-to-Forward로 표시된 옵션의 경우  
옵션 번호는 요청에서 Cache-Key(섹션 5.6)의 일부가 되도록  
의도되었는지 여부를 나타냅니다.  
NoCacheKey 비트 중 일부가 0이면 0입니다.  
모든 NoCacheKey 비트가 1이면 그렇지 않습니다(섹션 5.4.6 참조).

- 참고:  

  Cache-Key 표시는 지정된 옵션을 요청 옵션으로 구현하지 않고  
  대신 Unsafe/Safe-to-Forward 표시에만 의존하는 프록시에만 관련됩니다.  
  예를 들어 ETag의 경우  
  실제로 요청 옵션을 캐시 키의 일부로 사용하는 것은 매우 비효율적이지만,  
  요청 옵션의 존재에 따라 반응이 달라지기 때문에  
  ETag가 프록시에 의해 구현되지 않으면 할 수 있는 최선의 일이다.
  ETag 요청 옵션을 구현하는 더 유용한 프록시는  
  캐시 키의 일부로 ETag를 사용하지 않는 것입니다.

  'NoCacheKey'는 3 비트로 표시되므로  
  8개의 코드 포인트 중 1개만 'NoCacheKey'로 자격을 얻으며,  
  8개의 코드 포인트 중 7개가 더 가능성이 높은 경우로 나타납니다.

- 이러한 클래스에 대한 프록시 동작은 섹션 5.7에 정의되어 있습니다.

#### 5.4.3.  Length

- 옵션 값은 종종 상한 및 하한 형태로 특정 길이를 갖도록 정의됩니다.  
요청에 있는 옵션 값의 길이가 정의된 범위를 벗어나면  
해당 옵션은 인식할 수 없는 옵션처럼 취급되어야 합니다(섹션 5.4.1 참조).

#### 5.4.4.  Default Values

- 옵션은 기본값을 갖도록 정의될 수 있습니다.  
옵션의 값이 이 기본값이 되도록 의도된 경우  
옵션은 메시지에 포함되어서는 안 됩니다(SHOULD NOT).  
옵션이 없으면 기본값을 가정해야 합니다(MUST).

- 중요 옵션에 기본값이 있는 경우    
중요 옵션을 인식하지 못하는 구현과  
기본값이 있는 것으로 해석하는 구현 모두에서  
메시지에 옵션이 없는 것이 
적절하게 처리될 수 있는 방식으로 선택됩니다. 

#### 5.4.5. Repeatable Options
- 일부 옵션의 정의는 해당 옵션이 반복 가능하도록 지정합니다.  
반복 가능한 옵션은 메시지에 한 번 이상 포함될 수 있습니다.  
반복할 수 없는 옵션은 메시지에 두 번 이상 포함되어서는 안 됩니다(MUST NOT).

- 메시지에 옵션이 정의된 것보다 더 많이 발생하는 옵션이 포함된 경우  
메시지에 후속적으로 나타나는 각 초과 옵션 발생은  
인식되지 않는 옵션처럼 처리되어야 합니다(섹션 5.4.1 참조).

#### 5.4.6.  Option Numbers

- 옵션은 추가 의미 정보를 제공하는 옵션 번호로 식별됩니다.  
예를 들어 홀수는 중요한 옵션을 나타내고  
짝수는 선택 옵션을 나타냅니다.  
이것은 단순한 규칙이 아니라 프로토콜의 기능입니다.  
옵션이 선택인지 또는 중요할지 여부는  
옵션 번호가 짝수인지 홀수인지에 따라 완전히 결정됩니다.

- 보다 일반적으로 말해서 옵션 번호는  
비트 마스크로 구성되어 옵션이 중요 또는 선택,  
안전하지 않음 또는 Safe-to-Forward인지 표시하고  
Safe-to-Forward의 경우 다음 그림과 같이 캐시 키 표시를 제공합니다.  
다음 텍스트에서 비트 마스크는 부호 없는 정수 표현에서  
옵션 번호의 최하위 바이트에 적용되는 단일 바이트로 표현됩니다.  
비트 7(최하위 비트)이 1일 때 옵션은 중요(및 마찬가지로 0일 때 선택)입니다.  
비트 6이 1일 때 옵션은 안전하지 않습니다(0일 때도 마찬가지로 안전).  
비트 6이 0인 경우, 즉 옵션이 안전하지 않은 경우,  
비트 3-5가 모두 1로 설정된 경우에만 캐시 키(NoCacheKey)가 아닙니다.  
다른 모든 비트 조합은 실제로 캐시 키임을 의미합니다.  
이러한 옵션 클래스는 다음 섹션에서 설명합니다.

            0   1   2   3   4   5   6   7   8
            +---+---+---+---+---+---+---+---+
            |           | NoCacheKey| U | C |
            +---+---+---+---+---+---+---+---+

      Figure 10: Option Number Mask (Least Significant Byte)

- 끝점은 옵션 번호 "onum"의 특성을 도출하기 위해  
그림 11의 C 코드와 동등한 것을 사용할 수 있습니다.

      Critical = (onum & 1);
      UnSafe = (onum & 2);
      NoCacheKey = ((onum & 0x1e) == 0x1c);

      Figure 11: Determining Characteristics from an Option Number

- 이 문서에 정의된 옵션의 옵션 번호는  
"CoAP 옵션 번호" 레지스트리(섹션 12.2)에 나열되어 있습니다.

### 5.5.  Payloads and Representations

- 요청 및 응답에는 각각 방법 또는 응답 코드에 따라  
페이로드가 포함될 수 있습니다.  
방법 또는 응답 코드가 페이로드를 갖도록 정의되지 않은 경우  
발신자는 이를 포함하지 않아야 하고 수신자는 이를 무시해야 합니다(MUST).

#### 5.5.1.  Representation

- 요청 또는 성공을 나타내는 응답의 페이로드는  
일반적으로 리소스의 표현("리소스 표현") 또는  
요청된 작업의 결과("작업 결과")입니다.  
그 형식은 Content-Format Option에서 제공하는  
인터넷 미디어 유형 및 콘텐츠 코딩에 의해 지정됩니다.  
이 옵션이 없으면 기본값이 가정되지 않으며  
형식은 응용 프로그램에서 유추해야 합니다(예: 응용 프로그램 컨텍스트에서).  
콘텐츠 유형이 지정되지 않은 경우에만  
페이로드 "스니핑"을 시도해야 합니다(SHOULD).

- 구현 참고 사항: 
    
    구현 품질 수준에서는  
    가능하면 콘텐츠 형식 표시가  
    리소스 표현과 함께 제공될 것이라는 강한 기대가 있습니다.  
    이것은 프로토콜 요구 사항이 아니기 때문에  
    "SHOULD" 수준 요구 사항이 아니며  
    이 기대치를 위반할 수 있는 경우를  
    정확히 설명하는 것도 어려울 수 있습니다.

- 클라이언트 또는 서버 오류를 나타내는 응답의 경우  
페이로드는 Content-Format Option이 제공된 경우에만  
요청된 작업의 결과를 나타내는 것으로 간주됩니다.  
이 옵션이 없으면 페이로드는 진단 페이로드입니다(섹션 5.5.2).

#### 5.5.2.  Diagnostic Payload

- Content-Format 옵션이 제공되지 않으면  
클라이언트 또는 서버 오류를 나타내는 응답 페이로드는  
오류 상황을 설명하는 간단한 사람이 읽을 수 있는 진단 메시지입니다.  
이 진단 메시지는 UTF-8[RFC3629],  
특히 Net-Unicode 형식[RFC5198]을 사용하여 인코딩되어야 합니다(MUST).

- 메시지는 HTTP 상태 표시줄의 Reason-Phrase와 유사합니다.  
최종 사용자를 위한 것이 아니라  
디버깅하는 동안 현재 영어 사양의 맥락에서  
해석해야 하는 소프트웨어 엔지니어를 위한 것입니다.  
따라서 언어 태깅을 위한 메커니즘이  
필요하거나 제공되지 않습니다.  
HTTP에서 일반적으로 사용되는 것과 달리   
응답 코드 외에 추가 정보가 없는 경우  
페이로드는 비어 있어야 합니다(SHOULD).

#### 5.5.3.  Selected Representation
- 모든 응답이 요청에 의해 처리되는  
리소스의 표현을 제공하는 페이로드를 전달하는 것은 아닙니다.  
그러나 실제로 포함되었는지 여부와 관계없이  
응답과 관련하여 그러한 표현을 참조할 수 있는 것이 때때로 유용합니다.

- "선택된 표현"이라는 용어는  
해당 요청이 GET 방법을 사용하고  
조건부 요청 옵션을 제외했다면  
성공적인 응답에서 선택되었을 대상 리소스의  
현재 표현을 참조하는 데 사용합니다(섹션 5.10.8).

- 특정 응답 옵션은 선택한 표현에 대한 메타데이터를 제공하며,  
이는 일부 상태 변경 방법에 대한 응답에 대해  
메시지에 포함된 표현과 다를 수 있습니다.  
이 사양에서 정의된 응답 옵션 중  
ETag 응답 옵션(섹션 5.10.6)만 선택한 표현에 대한 메타데이터로 정의됩니다.

#### 5.5.4.  Content Negotiation

- 서버는 여러 표현 형식 중 하나로  
리소스에 대한 표현을 제공할 수 있습니다.  
클라이언트의 추가 정보가 없으면  
선호하는 형식으로 표현을 제공합니다.

- 요청에서 수락 옵션(섹션 5.10.4)을 사용하여  
클라이언트는 수신하기를 선호하는 콘텐츠 형식을 나타낼 수 있습니다.

### 5.6.  Caching

- CoAP 끝점은  
미래의 동등한 요청에 대한 응답 시간과  
네트워크 대역폭 소비를 줄이기 위해  
응답을 캐시할 수 있습니다(MAY).

- CoAP에서 캐싱의 목표는  
이전 응답 메시지를 재사용하여  
현재 요청을 충족시키는 것입니다.  
어떤 경우에는 저장된 응답을  
네트워크 요청 없이 재사용할 수 있어  
대기 시간과 네트워크 왕복을 줄일 수 있습니다.  
이를 위해 "freshness" 메커니즘이 사용됩니다(섹션 5.6.1 참조).  
새로운 요청이 필요한 경우에도  
요청을 충족시키기 위해  
이전 응답의 페이로드를 재사용하는 것이 종종 가능하므로  
네트워크 대역폭 사용량을 줄일 수 있습니다.  
이를 위해 "검증" 메커니즘이 사용됩니다(섹션 5.6.2 참조).

- HTTP와 달리 CoAP 응답의 캐시 가능성은  
요청 방법에 의존하지 않고 응답 코드에 의존합니다.  
각 응답 코드의 캐시 가능성은  
섹션 5.9의 응답 코드 정의에 따라 정의됩니다.  
성공을 나타내고 끝점에서 인식할 수 없는 응답 코드는  
캐시되어서는 안 됩니다(MUST NOT).

- 제시된 요청에 대해  
CoAP 엔드포인트는 다음을 제외하고  
저장된 응답을 사용해서는 안 됩니다(MUST NOT):

  - 제시된 요청 방법과 저장된 응답 일치를 얻는 데 사용된 방법,

  - NoCacheKey(섹션 5.4)로 표시된  
  요청 옵션과 일치할 필요가 없다는 점을 제외하고  
  모든 옵션은 제시된 요청의 옵션과  
  저장된 응답(요청 URI 포함)을 얻는 데 사용된  
  요청의 옵션 간에 일치합니다.  
  캐시에 의해 인식되고 지정된 캐시 동작과 관련하여  
  완전히 해석됩니다 
  (예: 섹션 5.10.6에 설명된 ETag 요청 옵션, 섹션 5.4.2 참조).

  - 저장된 응답이 신선하거나  
  아래에 정의된 대로 성공적으로 검증되었습니다.

- 캐시 항목을 일치시키는 데 사용되는 요청 옵션 집합을  
집합적으로 "Cache-Key"라고도 합니다.  
coap 및 coap 이외의 URI 체계의 경우  
요청 URI를 구성하는 옵션의 일치는  
URI 체계에 특정한 규칙에 따라 수행될 수 있습니다.

#### 5.6.1.  Freshness Model
- 캐시에서 응답이 "신선한" 경우  
원본 서버에 연결하지 않고  
후속 요청을 충족하는 데 사용할 수 있으므로  
효율성이 향상됩니다.

- 신선도를 결정하는 메커니즘은  
원 서버가 Max-Age 옵션을 사용하여  
미래에 명시적인 만료 시간을 제공하는 것입니다(섹션 5.10.5 참조).  
Max-Age 옵션은 응답이 지정된 시간(초)을 초과하면  
응답이 신선하지 않은 것으로 간주됨을 나타냅니다.

- Max-Age 옵션의 기본값은 60입니다.  
따라서 캐시 가능한 응답에 없으면  
응답이 60초를 초과하면 최신이 아닌 것으로 간주됩니다.  
원본 서버가 캐싱을 방지하려면  
0초 값을 가진 Max-Age 옵션을 명시적으로 포함해야 합니다.

- 클라이언트에 새로 저장된 응답이 있고  
저장된 응답에 대한 요청과 일치하는 새 요청을 하면  
새 응답이 이전 응답을 무효화합니다.

#### 5.6.2.  Validation Model

- 엔드포인트가 GET 요청에 대해  
하나 이상의 저장된 응답을 가지고 있지만  
그 중 아무 것도 사용할 수 없는 경우(예: 최신이 아니기 때문에),  
GET 요청에서 ETag 옵션(섹션 5.10.6)을 사용하여  
오리진을 제공할 수 있습니다.  
서버는 사용할 저장된 응답을 선택하고  
최신성을 업데이트할 수 있는 기회를 제공합니다.  
이 프로세스를 저장된 응답의 "검증" 또는 "재검증"이라고 합니다.

- 이러한 요청을 보낼 때  
끝점은 적용 가능한 각 저장된 응답의  
엔터티 태그를 지정하는 ETag 옵션을 추가해야 합니다(SHOULD).

- 2.03(유효) 응답은  
응답의 ETag 옵션에 제공된 entity-tag로 식별된  
저장된 응답이 섹션 5.9.1.3에 설명된 대로  
업데이트한 후 재사용될 수 있음을 나타냅니다.

다른 응답 코드는 요청에 지정된 저장된 응답 중 어느 것도 적합하지 않음을 나타냅니다. 대신 응답을 사용하여 요청을 충족하고 저장된 응답을 대체할 수 있습니다(MAY).

### 5.7.  Proxying
- 프록시는 CoAP 클라이언트가  
대신 요청을 수행하도록 할 수 있는 CoAP 끝점입니다.  
이는 예를 들어  
요청이 다른 방식으로 이루어질 수 없는 경우 또는  
응답 시간 및 네트워크 대역폭 또는 에너지 소비를 줄이기 위해  
캐시에서 응답을 처리하는 데 유용할 수 있습니다.

- 제한된 RESTful 환경의 전체 아키텍처에서 프록시는  
매우 다른 용도로 사용될 수 있습니다.  
프록시는 "전달 프록시"라고 하는 역할인 클라이언트가 명시적으로 선택할 수 있습니다.  
프록시는 우리가 "역 프록시"라고 부르는 역할인  
오리진 서버를 대신하기 위해 삽입될 수도 있습니다.  
이 구별에 직교하여 프록시는  
CoAP 요청에서 CoAP 요청으로 매핑(CoAP-to-CoAP 프록시)하거나  
다른 프로토콜에서 또는 다른 프로토콜로 변환("교차 프록시")할 수 있습니다.  
이 용어의 전체 정의는 섹션 1.2에 나와 있습니다.

- 참고: 

  이 사양의 용어는  
  모든 세부 사항에서 반드시 일치하지 않아도  
  광범위한 웹 애플리케이션 환경에서 사용되는 용어와  
  문화적으로 호환되도록 선택되었습니다 
  (제약된 RESTful 환경과 관련이 없을 수도 있음).  
  용어의 구성 요소(예: "forward", "reverse" 또는 "cross")에  
  너무 많은 의미를 부여해서는 안 됩니다.

  HTTP 프록시는 HTTP 프록시 역할 외에도  
  프록시를 통해 종단 간 전송 계층 보안을 가능하게 하는  
  전송 프로토콜 프록시 기능("CONNECT")을 제공하는 경우가 많습니다.  
  이 사양에서는 CoAP-to-CoAP 프록시에 대해  
  그러한 기능이 정의되어 있지 않습니다.  
  UDP 패킷의 전달은 제한된 RESTful 환경에서 큰 가치가 없을 것 같기 때문입니다.  
  교차 프록시의 경우 섹션 10.2.7도 참조하십시오.

- 클라이언트가 보안 URI 체계(예: "coaps" 또는 "https")를  
사용하는 요청을 하기 위해 프록시를 사용할 때  
해당 프록시에 대한 요청은  
클라이언트와 프록시 사이의 다리에  
동등한 하위 계층 보안이 사용되는 경우를 제외하고  
DTLS를 사용하여 보내야 합니다(SHOULD).  

#### 5.7.1.  Proxy Operation
- 프록시는 일반적으로 클라이언트로부터 받은 요청을 기반으로  
대상에 대한 잠재적인 요청 매개변수를 결정하는 방법이 필요합니다.  
이 방법은 순방향 프록시에 대해 완전히 지정되지만  
역방향 프록시에 대한 특정 구성에 따라 달라질 수 있습니다.  
특히, 리버스 프록시의 클라이언트는  
일반적으로 대상에 대한 로케이터를 나타내지 않으므로  
리버스 프록시에서 어떤 형태의 네임스페이스 변환이 필요합니다.  
그러나 프록시 작업의 일부 측면은 모든 형식에 공통입니다.

- 프록시가 캐시를 사용하지 않는 경우  
변환된 요청을 결정된 대상으로 전달합니다.  
그렇지 않고 캐시를 사용하지만  
번역된 요청과 일치하는 저장된 응답이 없고  
신선하다고 간주되는 경우  
섹션 5.6에 따라 캐시를 새로 고쳐야 합니다.  
프록시가 인식하는 요청의 옵션의 경우  
옵션이 캐시된 값을 조회하는데 사용되는 키의 일부로 작동하도록 의도되었는지 여부를 알 수 있습니다.  
예를 들어, 다른 Uri-Path 값에 대한 요청은  
다른 리소스를 다루기 때문에 Uri-Path 값은 항상 Cache-Key의 일부인 반면,  
예를 들어 Token 값은 Cache-Key의 일부가 아닙니다.  
프록시가 인식하지 못하지만 옵션 번호에 Safe-to-Forward로 표시된 옵션의 경우  
옵션은 Cache-Key에 포함될지(NoCacheKey가 모두 설정되지 않음)  
여부(NoCacheKey가 모두 설정되지 않음)도 나타냅니다.    
(인식되지 않고 Unsafe로 표시된 옵션은 4.02 Bad Option으로 이어집니다.)

- 대상에 대한 요청이 시간 초과되면  
5.04(게이트웨이 시간 초과) 응답이 반환되어야 합니다.  
목적지에 대한 요청이  
프록시에서 처리할 수 없는 응답을 반환하는 경우 
(예: 인식할 수 없는 중요한 옵션 또는 메시지 형식 오류로 인해)  
5.02(잘못된 게이트웨이) 응답이 반환되어야 합니다.  
그렇지 않으면 프록시가 클라이언트에 응답을 반환합니다.

- 캐시에서 응답이 생성되면  
생성된(또는 암시된) Max-Age 옵션은  
리소스 표현이 캐시에서 소비한 시간을 고려하여  
서버가 원래 설정한 max-age를 확장해서는 안 됩니다(MUST NOT).  
예를 들어 Max-Age 옵션은 다음 공식을 사용하여  
각 응답에 대해 프록시에서 조정할 수 있습니다.

  proxy-max-age = original-max-age - 캐시 사용 기간

- 예를 들어, 20초 전에 새로 고쳐지고  
원래 Max-Age가 60초였던 프록시 리소스에 대한 요청이 있는 경우  
해당 리소스의 프록시 최대 수명은 이제 40초입니다.  
원본 서버에서 오는 도중에 발생할 수 있는 네트워크 지연을 고려하여  
프록시는 제공되는 max-age 값에서 보수적이어야 합니다.

- 프록시 요청에 있는 모든 옵션은 프록시에서 처리되어야 합니다(MUST).  
프록시에서 인식하지 못하는 요청의 안전하지 않은 옵션은  
프록시에서 반환되는 4.02(잘못된 옵션) 응답으로 이어져야 합니다(MUST).  
CoAP-to-CoAP 프록시는 인식하지 못하는 모든 Safe-to-Forward 옵션을  
원본 서버에 전달해야 합니다(MUST).  
마찬가지로 CoAP-to-CoAP 프록시 서버가 인식하지 못하는 응답의 안전하지 않은 옵션은  
5.02(잘못된 게이트웨이) 응답으로 이어져야 합니다(MUST).  
다시 말하지만, 인식되지 않는 Safe-to-Forward 옵션은 반드시 전달되어야 합니다.

- CoAP와 HTTP 간의 크로스 프로토콜 프록시에 대한 추가 고려 사항은 섹션 10에서 설명합니다.

#### 5.7.2.  Forward-Proxies
- CoAP는 원본 서버에 대한 요청(마치)과 정방향 프록시를 통한 요청을 구분합니다.  
정방향 프록시에 대한 CoAP 요청은  
정방향 프록시 끝점에 대한 일반적인 확인 가능 또는  
확인 불가능 요청으로 이루어지지만  
요청 URI를 다른 방식으로 지정합니다.  
프록시 요청의 요청 URI는 Proxy-Uri Option(섹션 5.10.2 참조)에서 문자열로 지정되는 반면  
원본 서버에 대한 요청의 요청 URI는  
Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션(섹션 5.10.1 참조)으로 분할됩니다.  
또는 프록시 요청의 URI가 Proxy-Scheme 옵션과 언급된 분할 옵션에서 조합될 수 있습니다.

- 엔드포인트에 프록시 요청이 이루어지고  
엔드포인트가 요청 URI에 대한 프록시 역할을 하려고 하지 않거나 할 수 없는 경우  
5.05(프록시가 지원되지 않음) 응답을 반환해야 합니다(MUST).  
권한(호스트 및 포트)이 프록시 끝점 자체를 식별하는 것으로 인식되는 경우(섹션 5.10.2 참조)  
요청은 로컬(프록시되지 않은) 요청으로 처리되어야 합니다(MUST).

- 프록시가 프록시 요청을 다른 프록시로 전달하도록 구성되지 않은 경우,  
요청 URI의 체계는 나가는 프로토콜과 세부 정보를 정의합니다 
(예: CoAP는 "cops" 체계는 UDP를 통해, "cops" 체계는 DTLS를 통해 사용됩니다).  
CoAP-to-CoAP 프록시의 경우  
원본 서버의 IP 주소와 포트가 요청 URI의 권한 구성 요소에 의해 결정되고  
요청 URI는 디코딩되어 URI-Host, URI-Port, URI-Path 및 URI-Query 옵션으로 분할됩니다.  
이 경우 Proxy-Uri 또는 Proxy-Scheme 옵션이 사용되므로 원본 서버로 전달되지 않습니다.

#### 5.7.3.  Reverse-Proxies
- 역방향 프록시는  
Proxy-Uri 또는 Proxy-Scheme 옵션을 사용하지 않지만  
요청의 정보와 해당 구성의 정보에서 요청의 대상(다음 홉)을 결정해야 합니다.  
예를 들어 리버스 프록시는  
리소스 검색을 통해 자신의 존재를 알게 된 후  
마치 자신의 리소스인 것처럼 다양한 리소스를 제공할 수 있습니다.  
리버스 프록시는 이러한 리소스를 식별하는  
URI에 대한 네임스페이스를 자유롭게 구축할 수 있습니다.  
역방향 프록시는 또한  
예를 들어 호스트 식별자와 포트 번호를  
제공된 리소스의 URI 경로에 포함하여  
요청이 가는 위치에 대한 더 많은 제어를  
클라이언트에 제공하는 네임스페이스를 구축할 수 있습니다.

- 응답을 처리할 때 리버스 프록시는  
다른 소스의 ETag 옵션 값이  
클라이언트에게 제공되는 하나의 리소스에 섞이지 않도록 주의해야 합니다.  
많은 경우에 ETag는 변경되지 않고 전달될 수 있습니다.  
리버스 프록시가 제공하는 리소스에서  
다양한 원본 서버가 제공하는 리소스로의 매핑이 고유하지 않은 경우  
리버스 프록시는 새 ETag를 생성하여  
이 옵션의 의미 체계가 제대로 유지되도록 해야 할 수 있습니다.

### 5.8.  Method Definitions
- 이 섹션에서는 각 메서드가 동작과 함께 정의됩니다.  
인식되지 않거나 지원되지 않는 메소드 코드가 있는 요청은  
4.05(허용되지 않는 메소드) 피기백 응답을 생성해야 합니다(MUST).

#### 5.8.1.  GET
- GET 메소드는  
현재 요청 URI로 식별되는 리소스에 해당하는 정보에 대한 표현을 검색합니다.  
요청에 수락 옵션이 포함된 경우  
응답의 기본 콘텐츠 형식을 나타냅니다.  
요청에 ETag 옵션이 포함된 경우  
GET 메서드는 ETag의 유효성을 검사하고  
유효성 검사가 실패한 경우에만 표현이 전송되도록 요청합니다.  
성공하면 2.05(콘텐츠) 또는 2.03(유효) 응답 코드가 응답에 있어야 합니다(SHOULD).

- GET 메서드는 안전하고 멱등원입니다.

#### 5.8.2.  POST
- POST 메서드는 요청에 포함된 표현이 처리되도록 요청합니다.  
POST 메서드가 수행하는 실제 기능은  
원본 서버에 의해 결정되며 대상 리소스에 따라 다릅니다.  
일반적으로 새 리소스가 생성되거나 대상 리소스가 업데이트됩니다.

- 리소스가 서버에서 생성된 경우  
서버에서 반환된 응답에는 2.01(생성됨) 응답 코드가 있어야 하고  
하나 이상의 Location-Path 및/또는 Location-Query 옵션(섹션 5.10.7)  
시퀀스에 새 리소스의 URI를 포함해야 합니다(SHOULD).  
POST가 성공했지만 서버에 새 리소스가 생성되지 않으면  
응답에 2.04(변경된) 응답 코드가 있어야 합니다(SHOULD).  
POST가 성공하여 대상 리소스가 삭제되면  
응답에 2.02(삭제됨) 응답 코드가 있어야 합니다(SHOULD).  
POST는 안전하지도 멱등성도 아닙니다.

#### 5.8.3.  PUT
- PUT 메서드는 요청 URI로 식별된 리소스가  
포함된 표현으로 업데이트되거나 생성되도록 요청합니다.  
표현 형식은 제공되는 경우  
Content-Format Option에 제공된 미디어 유형 및 콘텐츠 코딩에 의해 지정됩니다.

- 리소스가 요청 URI에 존재하는 경우  
동봉된 표현은 해당 리소스의 수정된 버전으로 간주되어야 하고  
2.04(변경된) 응답 코드가 반환되어야 합니다(SHOULD).  
리소스가 존재하지 않는 경우  
서버는 해당 URI로 새 리소스를 생성할 수 있으며  
결과적으로 2.01(생성된) 응답 코드가 생성됩니다.  
리소스를 생성하거나 수정할 수 없는 경우  
적절한 오류 응답 코드를 보내야 합니다(SHOULD).

- 요청에 If-Match(섹션 5.10.8.1 참조) 또는  
If-None-Match(섹션 5.10.8.2 참조) 옵션을 포함하여  
PUT에 대한 추가 제한을 만들 수 있습니다.

- PUT은 안전하지 않지만 멱등원입니다.

#### 5.8.4.  DELETE
- DELETE 메서드는 요청 URI로 식별된 리소스를 삭제하도록 요청합니다.  
A 2.02(Deleted) 응답 코드는  
성공 시 또는 요청 전에 리소스가 존재하지 않은 경우에 사용해야 합니다(SHOULD).

- DELETE는 안전하지 않지만 멱등원입니다.

### 5.9.  Response Code Definitions
- 각 응답 코드는 응답에 필요한 옵션을 포함하여 아래에 설명되어 있습니다.  
적절한 경우 일부 코드는 HTTP [RFC2616]의 관련 응답 코드와 관련하여 지정됩니다.  
그렇다고 해서 그러한 관계가 섹션 10에 지정된 HTTP 매핑을 수정한다는 의미는 아닙니다.

#### 5.9.1.  Success 2.xx
- 이 응답 코드 클래스는  
클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.

##### 5.9.1.1.  2.01 Created
- HTTP 201 "Created"와 유사하지만  
POST 및 PUT 요청에 대한 응답으로만 사용됩니다.  
응답과 함께 반환된 페이로드(있는 경우)는 작업 결과를 나타냅니다.

- 응답에 하나 이상의 Location-Path 및/또는 Location-Query Options가 포함된 경우  
이러한 옵션의 값은 리소스가 생성된 위치를 지정합니다.  
그렇지 않으면 리소스가 요청 URI에 생성되었습니다.  
이 응답을 수신하는 캐시는  
생성된 리소스에 대해 저장된 응답을  
신선하지 않은 것으로 표시해야 합니다(MUST).

- 이 응답은 캐시할 수 없습니다.

##### 5.9.1.2.  2.02 Deleted
- 이 응답 코드는  
HTTP 204 "내용 없음"과 유사하지만  
DELETE 및 특정 상황에서는 POST와 같이  
리소스 사용을 중지하는 요청에 대한 응답으로만 사용됩니다.  
응답과 함께 반환된 페이로드(있는 경우)는 작업 결과를 나타냅니다.

- 이 응답은 캐시할 수 없습니다.  
그러나 캐시는 삭제된 리소스에 대해  
저장된 응답을 신선하지 않은 것으로 표시해야 합니다(MUST).

##### 5.9.1.3.  2.03 Valid
- 이 응답 코드는  
HTTP 304 "수정되지 않음"과 관련이 있지만  
포함된 ETag 옵션으로 식별된  
엔티티 태그로 식별된 응답이 유효함을 나타내는 데만 사용됩니다.  
따라서 응답은 ETag 옵션을 포함해야 하고  
페이로드를 포함해서는 안 됩니다(MUST NOT).

- ETag 응답 옵션을 인식하고 처리하는 캐시가 2.03(유효) 응답을 받으면  
응답에 포함된 Max-Age 옵션 값으로 저장된 응답을 업데이트해야 합니다 
(명시적 또는 암시적으로 기본값으로, 섹션 5.6.2).  
응답에 있는 Safe-to-Forward 옵션의 각 유형에 대해  
저장된 응답에 있는 이 유형의 옵션 세트(비어 있을 수 있음)는  
수신된 응답에서 이 유형의 옵션 세트로 대체되어야 합니다(MUST).  
(안전하지 않은 옵션은  
옵션에 정의된 것과 유사한 옵션별 처리를 트리거할 수 있습니다.)

##### 5.9.1.4.  2.04 Changed
- 이 응답 코드는  
HTTP 204 "내용 없음"과 유사하지만  
POST 및 PUT 요청에 대한 응답으로만 사용됩니다.  
응답과 함께 반환된 페이로드(있는 경우)는 작업 결과를 나타냅니다.

- 이 응답은 캐시할 수 없습니다.  
그러나 캐시는 변경된 리소스에 대해  
저장된 응답을 신선하지 않은 것으로 표시해야 합니다(MUST).


##### 5.9.1.5.  2.05 Content
- 이 응답 코드는 HTTP 200 "OK"와 비슷하지만  
GET 요청에 대한 응답으로만 사용됩니다.

- 응답과 함께 반환된 페이로드는 대상 리소스를 나타냅니다.

- 이 응답은 캐시 가능합니다.  
캐시는 신선도(섹션 5.6.1 참조)와  
유효성 검사를 위한 ETag 옵션(섹션 5.6.2 참조)을 결정하기 위해  
Max-Age 옵션을 사용할 수 있습니다.

#### 5.9.2.  Client Error 4.xx
- 이 응답 코드 클래스는  
클라이언트가 실수한 것처럼 보이는 경우를 위한 것입니다.  
이 응답 코드는 모든 요청 방법에 적용할 수 있습니다.

- 서버는 섹션 5.5.2에 설명된 조건에 따라  
진단 페이로드를 포함해야 합니다(SHOULD).

- 이 클래스의 응답은 캐시 가능합니다.  
캐시는 Max-Age 옵션을 사용하여  
신선도를 결정할 수 있습니다(섹션 5.6.1 참조).  
검증(유효성을 검사)할 수 없습니다.

##### 5.9.2.1.  4.00 Bad Request
- 이 응답 코드는 HTTP 400 "잘못된 요청"과 같습니다.

##### 5.9.2.2.  4.01 Unauthorized
- 클라이언트는 요청된 작업을 수행할 권한이 없습니다.  
클라이언트는 먼저 서버에 대한 인증 상태를 개선하지 않고  
요청을 반복해서는 안 됩니다(SHOULD NOT).  
이를 위해 사용할 수 있는 특정 메커니즘은 이 문서의 범위를 벗어납니다.  
섹션 9도 참조하십시오.

##### 5.9.2.3.  4.02 Bad Option
- 하나 이상의 인식할 수 없거나  
형식이 잘못된 옵션으로 인해  
서버에서 요청을 이해할 수 없습니다.  
클라이언트는 수정 없이 요청을 반복해서는 안 됩니다(SHOULD NOT).

##### 5.9.2.4.  4.03 Forbidden
- 이 응답 코드는 HTTP 403 "금지"와 같습니다.

##### 5.9.2.5.  4.04 Not Found
- 이 응답 코드는 HTTP 404 "찾을 수 없음"과 같습니다.

##### 5.9.2.6.  4.05 Method Not Allowed
- 이 응답 코드는 HTTP 405 "Method Not Allowed"와 유사하지만  
"Allow" 헤더 필드와 평행하지 않습니다.

##### 5.9.2.7.  4.06 Not Acceptable
- 이 응답 코드는 HTTP 406 "Not Acceptable"과 비슷하지만  
응답 엔터티가 없습니다.

##### 5.9.2.8.  4.12 Precondition Failed
- 이 응답 코드는 HTTP 412 "사전 조건 실패"와 같습니다.

##### 5.9.2.9.  4.13 Request Entity Too Large
- 이 응답 코드는 HTTP 413 "요청 엔터티가 너무 큼"과 같습니다.

- 응답은 서버가 이 정보를 사용할 수 있는 위치에 있지 않는 한  
서버가 처리할 수 있고 처리할 의향이 있는 요청 엔터티의  
최대 크기를 나타내는 Size1 옵션(섹션 5.10.9)을 포함해야 합니다(SHOULD).

##### 5.9.2.10.  4.15 Unsupported Content-Format
- 이 응답 코드는 HTTP 415 "지원되지 않는 미디어 유형"과 같습니다.

#### 5.9.3.  Server Error 5.xx
- 이 응답 코드 클래스는 서버가 오류가 발생했거나  
요청을 수행할 수 없음을 알고 있는 경우를 나타냅니다.  
이 응답 코드는 모든 요청 방법에 적용할 수 있습니다.

- 서버는 섹션 5.5.2에 설명된 조건에 따라  
진단 페이로드를 포함해야 합니다(SHOULD).

- 이 클래스의 응답은 캐시 가능합니다.  
캐시는 Max-Age 옵션을 사용하여  
신선도를 결정할 수 있습니다(섹션 5.6.1 참조).  
검증할 수 없습니다.

##### 5.9.3.1. 5.00 Internal Server Error
- 이 응답 코드는 HTTP 500 "내부 서버 오류"와 같습니다.

##### 5.9.3.2. 5.01 Not Implemented
- 이 응답 코드는 HTTP 501 "구현되지 않음"과 같습니다.

##### 5.9.3.3. 5.02 Bad Gateway
- 이 응답 코드는 HTTP 502 "Bad Gateway"와 같습니다.

##### 5.9.3.4. 5.03 Service Unavailable
- 이 응답 코드는 HTTP 503 "서비스를 사용할 수 없음"과 유사하지만  
"Retry-After" 헤더 필드 대신 Max-Age 옵션을 사용하여  
재시도할 시간(초)을 나타냅니다.

##### 5.9.3.5. 5.04 Gateway Timeout
- 이 응답 코드는 HTTP 504 "Gateway Timeout"과 같습니다.

##### 5.9.3.6. 5.05 Proxying Not Supported
- 서버는 Proxy-Uri Option 또는  
Proxy-Scheme(섹션 5.10.2 참조)에 지정된 URI에 대해  
정방향 프록시 역할을 할 수 없거나 원하지 않습니다.

### 5.10.  Option Definitions
- 개별 CoAP 옵션은 표 4에 요약되어 있으며 이 섹션의 하위 섹션에 설명되어 있습니다.

- 이 표에서 C, U 및 N 열은 각각  
Critical, UnSafe 및 NoCacheKey 속성을 나타냅니다.  
NoCacheKey는 앞으로 안전(안전하지 않은 것으로 표시되지 않음)인 옵션에만  
의미가 있으므로 열은 안전하지 않은 옵션에 대한 대시로 채워집니다.


      +-----+---+---+---+---+----------------+--------+--------+----------+
      | No. | C | U | N | R | Name           | Format | Length | Default  |
      +-----+---+---+---+---+----------------+--------+--------+----------+
      |   1 | x |   |   | x | If-Match       | opaque | 0-8    | (none)   |
      |   3 | x | x | - |   | Uri-Host       | string | 1-255  | (see     |
      |     |   |   |   |   |                |        |        | below)   |
      |   4 |   |   |   | x | ETag           | opaque | 1-8    | (none)   |
      |   5 | x |   |   |   | If-None-Match  | empty  | 0      | (none)   |
      |   7 | x | x | - |   | Uri-Port       | uint   | 0-2    | (see     |
      |     |   |   |   |   |                |        |        | below)   |
      |   8 |   |   |   | x | Location-Path  | string | 0-255  | (none)   |
      |  11 | x | x | - | x | Uri-Path       | string | 0-255  | (none)   |
      |  12 |   |   |   |   | Content-Format | uint   | 0-2    | (none)   |
      |  14 |   | x | - |   | Max-Age        | uint   | 0-4    | 60       |
      |  15 | x | x | - | x | Uri-Query      | string | 0-255  | (none)   |
      |  17 | x |   |   |   | Accept         | uint   | 0-2    | (none)   |
      |  20 |   |   |   | x | Location-Query | string | 0-255  | (none)   |
      |  35 | x | x | - |   | Proxy-Uri      | string | 1-1034 | (none)   |
      |  39 | x | x | - |   | Proxy-Scheme   | string | 1-255  | (none)   |
      |  60 |   |   | x |   | Size1          | uint   | 0-4    | (none)   |
      +-----+---+---+---+---+----------------+--------+--------+----------+

             C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable

                             Table 4: Options

#### 5.10.1.  Uri-Host, Uri-Port, Uri-Path, and Uri-Query  
- Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션은  
CoAP 원본 서버에 대한 요청의 대상 리소스를 지정하는 데 사용됩니다.  
옵션은 퍼센트 인코딩이 옵션 값에 표시되지 않고  
관련 엔드포인트에서 전체 URI를 재구성할 수 있는 방식으로  
요청 URI의 다른 구성요소를 인코딩합니다.  
CoAP URI의 구문은 섹션 6에 정의되어 있습니다.

- URI를 옵션으로 구문 분석하는 단계는 섹션 6.4에 정의되어 있습니다.  
이러한 단계를 수행하면 요청에 0개 이상의  
Uri-Host, Uri-Port, Uri-Path 및 Uri-Query 옵션이 포함되며  
각 옵션에는 다음 값이 포함됩니다.
  - Uri-Host Option은 요청되는 리소스의 인터넷 호스트를 지정합니다.
  - Uri-Port 옵션은 리소스의 전송 계층 포트 번호를 지정합니다.
  - 각 Uri-Path Option은 리소스에 대한 절대 경로의 한 세그먼트를 지정하고,
  - 각 Uri-Query Option은 리소스를 매개변수화하는 하나의 인수를 지정합니다.

- 참고: 조각([RFC3986], 섹션 3.5)은 요청 URI의 일부가 아니므로  
CoAP 요청에서 전송되지 않습니다.

- Uri-Host Option의 기본값은  
요청 메시지의 대상 IP 주소를 나타내는 IP 리터럴입니다.  
마찬가지로 Uri-Port Option의 기본값은 대상 UDP 포트입니다.  
Uri-Host 및 Uri-Port 옵션의 기본값은  
대부분의 서버에 대한 요청에 충분합니다.  
명시적 Uri-Host 및 Uri-Port 옵션은  
일반적으로 끝점이 여러 가상 서버를 호스트할 때 사용됩니다.

- Uri-Path 및 Uri-Query Option에는 모든 문자 시퀀스가 ​​포함될 수 있습니다.  
백분율 인코딩이 수행되지 않습니다.  
Uri-Path 옵션의 값은 "." 또는 ".."가 아니어야 합니다.  
(요청 URI를 옵션으로 구문 분석하기 전에 확인해야 함).

- 옵션에서 요청 URI를 구성하는 단계는 섹션 6.5에 정의되어 있습니다.  
구현에서 반드시 URI를 구성할 필요는 없습니다.  
개별 옵션을 검사하여 대상 리소스를 간단히 조회할 수 있습니다.

- 예제는 부록 B에서 찾을 수 있습니다.

#### 5.10.2.  Proxy-Uri and Proxy-Scheme
- Proxy-Uri Option은 정방향 프록시에 요청하는 데 사용됩니다(섹션 5.7 참조).  
전달 프록시는 요청을 전달하거나  
유효한 캐시에서 서비스를 제공하고 응답을 반환하도록 요청됩니다.

- 옵션 값은 절대 URI([RFC3986], 섹션 4.3)입니다.

- 전달 프록시는 요청을 다른 프록시로 전달하거나  
절대 URI에 의해 지정된 서버로 직접 전달할 수 있습니다(MAY).  
요청 루프를 피하기 위해 프록시는 별칭,  
로컬 변형 및 숫자 IP 주소를 포함하여  
모든 서버 이름을 인식할 수 있어야 합니다(MUST).

- Proxy-Uri Option이 포함된 요청을 수신하는 끝점은  
요청에 대한 정방향 프록시 역할을 할 수 없거나 원하지 않는 경우  
5.05(Proxying Not Supported) 응답을 반환해야 합니다(MUST).

- Proxy-Uri 옵션은  
Uri-Host, Uri-Port, Uri-Path 또는 Uri-Query 옵션보다 우선해야 합니다 
(각각 Proxy-Uri 옵션을 포함하는 요청에 포함되어서는 안 됨).

- 많은 프록시 클라이언트를 단순화하는 특별한 경우로  
Uri-* 옵션에서 절대 URI를 구성할 수 있습니다.  
Proxy-Scheme Option이 있는 경우 절대 URI는 다음과 같이 구성됩니다.  
CoAP URI는 섹션 6.5에 정의된 Uri-* 옵션에서 구성됩니다.  
결과 URI에서 다음 콜론까지(포함하지 않음)까지의 초기 체계는  
Proxy-Scheme Option의 내용으로 대체됩니다.  
이 경우는 scheme 구성요소가 아닌 원하는 URI의 구성요소가  
실제로 Uri-* 옵션을 사용하여 표현될 수 있는 경우에만  
적용된다는 점에 유의하십시오.  
예를 들어 권한에 userinfo 구성 요소가 있는 URI를 나타내려면  
Proxy-Uri만 사용할 수 있습니다.

#### 5.10.3.  Content-Format 
- Content-Format Option은 메시지 페이로드의 표현 형식을 나타냅니다.  
표현 형식은 "CoAP 콘텐츠 형식" 레지스트리(12.3절)에 정의된  
숫자 콘텐츠 형식 식별자로 제공됩니다.  
옵션이 없으면 기본값이 가정되지 않습니다.  
즉, 표현 메시지 페이로드의 표현 형식이 불확실합니다(5.5절).

#### 5.10.4.  Accept 
- CoAP Accept 옵션을 사용하여  
클라이언트가 수용할 수 있는 Content-Format을 표시할 수 있습니다.  
표현 형식은  
"CoAP 콘텐츠 형식" 레지스트리(섹션 12.3)에 정의된  
숫자 콘텐츠 형식 식별자로 제공됩니다.  
Accept 옵션이 주어지지 않으면 클라이언트는  
기본 설정을 표현하지 않습니다(따라서 기본값이 가정되지 않음).  
클라이언트는 서버에서 반환된 표현이 표시된  
Content-Format으로 표시되는 것을 선호합니다.  
서버는 가능한 경우 선호하는 Content-Format을 반환합니다.  
선호하는 콘텐츠 형식을 반환할 수 없는 경우  
이 응답에 대해 다른 오류 코드가 우선적으로 적용되지 않는 한  
4.06 "Not Acceptable"을 응답으로 보내야 합니다.

#### 5.10.5.  Max-Age 
- Max-Age 옵션은 응답이 신선하지 않은 것으로 간주되기 전에  
캐시될 수 있는 최대 시간을 나타냅니다(섹션 5.6.1 참조).

- 옵션 값은 0에서 2**32-1(약 136.1년 포함) 사이의 정수 초입니다.  
응답에 옵션이 없는 경우 기본값 60초가 가정됩니다.

- 값은 전송 시점의 현재 값입니다.  
Max-Age 값에 대해 엄격한 허용 오차를 가진 리소스를 제공하는 서버는  
각 재전송 전에 값을 업데이트해야 합니다(SHOULD).  
(섹션 5.7.1도 참조하십시오.)

#### 5.10.6.  ETag 
- entity-tag는 시간에 따라 변하는 동일한 리소스의 표현을 구별하기  
위한 리소스 로컬 식별자로 사용하기 위한 것입니다.  
리소스를 제공하는 서버에 의해 생성되며  
버전, 체크섬, 해시 또는 시간을 비롯한  
다양한 방식으로 리소스를 생성할 수 있습니다.  
엔터티 태그를 수신하는 엔드포인트는  
이를 불투명한 것으로 취급해야 하며  
콘텐츠 또는 구조에 대해 가정하지 않아야 합니다.  
(엔티티 태그를 생성하는 끝점은  
특히 여러 ETag 값을 저장하려는 클라이언트 및 중개자와 관련하여  
가능한 가장 간결한 표현을 사용하는 것이 좋습니다.)

##### 5.10.6.1. ETag as a Response Option
- 응답의 ETag 옵션은  
"태그된 표현"에 대한 엔티티 태그의 현재 값 
(즉, 요청이 처리된 후)을 제공합니다.  
Location-* 옵션이 없으면  
태그가 지정된 표현은 대상 리소스의 선택된 표현(섹션 5.5.3)입니다.  
하나 이상의 Location-* 옵션이 존재하여  
위치 URI가 표시되는 경우(섹션 5.10.7),  
태그가 지정된 표현은  
위치 URI에 대한 GET 요청에 의해 검색되는 표현입니다.

- ETag 응답 옵션은  
태그가 지정된 표현이 있는 모든 응답에 포함될 수 있습니다 
(예: 4.04 또는 4.00 응답에서는 의미가 없음).  
ETag 옵션은 응답에서 두 번 이상 발생해서는 안 됩니다(MUST NOT).

- ETag 옵션에는 기본값이 없습니다.  
응답에 없으면 서버는 태그가 지정된 표현에 대한  
엔터티 태그에 대해 설명하지 않습니다.

##### 5.10.6.2. ETag as a Request Option
- GET 요청에서 리소스에서 이전에 얻은 하나 이상의 표현이 있고  
이러한 표현으로 ETag 응답 옵션을 얻은 끝점은  
이러한 저장된 응답 중 하나 이상에 대해  
ETag 옵션의 인스턴스를 지정할 수 있습니다.

- 서버는 주어진 ETag 중 하나가  
현재 표현에 대한 엔터티 태그인 경우,  
즉 유효한 경우 2.05 콘텐츠 응답 대신  
2.03 유효한 응답(섹션 5.9.1.3)을 발행할 수 있습니다.  
2.03 유효한 응답은 응답 옵션에서 이 특정 ETag를 반향합니다.

- 실제로 클라이언트는 저장된 표현이 다시 전송할 필요 없이  
최신 상태인지 확인할 수 있습니다(섹션 5.6.2 참조).

- ETag 옵션은 요청에서 0번, 1번 또는 여러 번 발생할 수 있습니다.

#### 5.10.7.  Location-Path and Location-Query 
- 위치 경로 및 위치 쿼리 옵션은 함께  
절대 경로, 쿼리 문자열 또는 둘 다로 구성된 상대 URI를 나타냅니다.  
이러한 옵션의 조합은 2.01(Created) 응답에 포함되어  
POST 요청의 결과로 생성된 리소스의 위치를 ​​나타냅니다(섹션 5.8.2 참조).  
위치는 요청 URI를 기준으로 확인됩니다.

- 하나 이상의 위치 경로 및/또는 위치 쿼리 옵션이 있는 응답이  
이러한 옵션을 해석하는 캐시를 통과하고  
암시된 URI가 현재 저장된 하나 이상의 응답을 식별하는 경우  
해당 항목은 신선하지 않은 것으로 표시되어야 합니다(MUST).

- 각 Location-Path Option은  
리소스에 대한 절대 경로의 한 세그먼트를 지정하고,  
각 Location-Query Option은  
리소스를 매개변수화하는 하나의 인수를 지정합니다.  
Location-Path 및 Location-Query Option은  
모든 문자 시퀀스를 포함할 수 있습니다.  
백분율 인코딩이 수행되지 않습니다.  
위치 경로 옵션의 값은 "." 또는 ".." 가 아니어야 합니다.

- 옵션에서 위치 URI를 구성하는 단계는 처음 5단계를 건너뛰고  
결과가 요청 URI에 대해 상대적으로 해석되는  
상대 URI 참조라는 점을 제외하고 섹션 6.5와 유사합니다.  
이 방법으로 구성된 상대 URI 참조는  
항상 절대 경로를 포함합니다 
(예: Location-Path를 생략하지만  
Location-Query를 제공하는 것은  
URI의 경로 구성 요소가 "/"임을 의미함).

- 상대 URI 참조를 계산하는 데 사용되는 옵션을  
집합적으로 Location-* 옵션이라고 합니다.  
Location-Path 및 Location-Query 외에도  
더 많은 Location-* 옵션이 미래에 정의될 수 있으며  
옵션 번호 128, 132, 136 및 140이 예약되었습니다.  
이러한 예약된 옵션 번호가  
Location-Path 및 /또는 Location-Query가 지원되지 않는 경우  
4.02(Bad Option) 오류가 반환되어야 합니다(MUST).

#### 5.10.8.  Conditional Request Options  
- 조건부 요청 옵션을 사용하면  
옵션으로 지정된 특정 조건이 충족되는 경우에만  
클라이언트가 서버에 요청을 수행하도록 요청할 수 있습니다.

- 이러한 각 옵션에 대해  
주어진 조건이 충족되지 않으면  
서버는 요청된 방법을 수행해서는 안 됩니다(MUST NOT).  
대신, 서버는 4.12(사전 조건 실패) 응답 코드로 응답해야 합니다(MUST).

- 조건이 충족되면 서버는  
조건부 요청 옵션이 없는 것처럼 요청 메서드를 수행합니다.

- 조건부 요청 옵션 없이  
요청이 2.xx 또는 4.12 응답 코드 이외의 결과를 초래하는 경우  
모든 조건부 요청 옵션이 무시될 수 있습니다(MAY).

##### 5.10.8.1. If-Match
- If-Match 옵션은  
대상 자원의 하나 이상의 표현에 대한  
ETag의 현재 존재 또는 값에 대한  
조건부 요청을 만드는 데 사용될 수 있습니다(MAY).  
If-Match는 일반적으로  
여러 클라이언트가 동일한 리소스에서 병렬로 작동할 때 
(즉, "업데이트 손실" 문제)  
우발적인 덮어쓰기를 방지하기 위한 수단으로  
PUT 요청과 같은 리소스 업데이트 요청에 유용합니다.

- If-Match 옵션의 값은 ETag 또는 빈 문자열입니다.  
ETag가 있는 If-Match 옵션은 정확한 ETag가 있는 표현과 일치합니다.  
값이 비어 있는 If-Match 옵션은 기존 표현과 일치합니다 
(즉, 대상 리소스에 대한 현재 표현의 존재에 전제 조건을 둡니다).

- If-Match 옵션은 여러 번 발생할 수 있습니다.  
옵션 중 하나라도 일치하면 조건이 충족됩니다.

- If-Match 옵션이 하나 이상 있지만  
일치하는 옵션이 없으면  
조건이 충족되지 않습니다.

##### 5.10.8.2. If-None-Match
- If-None-Match 옵션은  
대상 리소스가 없는 경우  
요청을 조건부로 만드는 데 사용할 수 있습니다(MAY).  
If-None-Match는  
여러 클라이언트가 동일한 리소스에서  
병렬로 작동할 때 우발적인 덮어쓰기를 방지하기 위한 수단으로  
PUT 요청과 같은 리소스 생성 요청에 유용합니다.  
If-None-Match 옵션은 가치가 없습니다.

- 대상 리소스가 있으면 조건이 충족되지 않습니다.

- (If-Match 및 If-None-Match 옵션을  
하나의 요청에 결합하는 것은 그다지 유용하지 않습니다.  
그러면 조건이 절대 충족되지 않기 때문입니다.)

#### 5.10.9.  Size1 Option
- Size1 옵션은  
요청의 리소스 표현에 대한 크기 정보를 제공합니다.  
옵션 값은 정수 바이트 수입니다.  
주요 용도는 블록 단위 전송 [BLOCK]입니다.  
본 명세서에서는 서버가 처리할 수 있고  
처리할 의사가 있는 요청 엔터티의 최대 크기를 나타내기 위해  
4.13 응답(섹션 5.9.2.9)에서 사용됩니다.

## 6.  CoAP URIs
- CoAP는 CoAP 리소스를 식별하고 리소스를 찾는 수단을 제공하기 위해 
 "coap" 및 "coaps" URI 체계를 사용합니다.  
 리소스는 계층적으로 구성되며  
 주어진 UDP 포트에서 CoAP 요청("coap") 또는  
 DTLS 보안 CoAP 요청("coap")을 수신하는  
 잠재적인 CoAP 원본 서버에 의해 관리됩니다.  
 CoAP 서버는 호스트 구성 요소와  
 선택적 UDP 포트 번호를 포함하는  
 일반 구문의 권한 구성 요소를 통해 식별됩니다.  
 URI의 나머지 부분은 CoAP 프로토콜에서 정의한 방법으로  
 운영할 수 있는 리소스를 식별하는 것으로 간주됩니다.  
 따라서 "coap" 및 "coaps" URI 체계는  
 각각 "http" 및 "https" URI 체계와 비교할 수 있습니다.

- "coap" 및 "coaps" URI 체계의 구문은  
이 섹션에서 ABNF(Augmented Backus-Naur Form)[RFC5234]로 지정됩니다.  
"host", "port", "path-abempty", "query",  
"segment", "IP-literal", "IPv4address" 및 "reg-name"의 정의는  
[RFC3986]에서 채택되었습니다.

- 구현 참고 사항: 
    
    불행히도 시간이 지남에 따라 URI 형식이 상당히 복잡해졌습니다.  
    구현자는 [RFC3986]을 자세히 검토하는 것이 좋습니다.  
    예를 들어 IPv6 주소에 대한 ABNF는 예상보다 더 복잡합니다.  
    또한 구현자는 URI에서 디코딩된 구성 요소로 또는  
    그 반대로 가는 도중에 퍼센트 디코딩 또는  
    퍼센트 인코딩 처리를 정확히 한 번 수행하도록 주의해야 합니다.  
    백분율 인코딩은 데이터 투명성에 중요하지만  
    경로 구성 요소에 슬래시 문자와 같은  
    비정상적인 결과가 발생할 수 있습니다.

### 6.1.  coap URI Scheme
    
    coap-URI = "coap:" "//" 호스트 [ ":" 포트 ] 경로-abempty [ "?" 쿼리 ]

- 호스트 구성 요소가 IP 리터럴 또는 IPv4 주소로 제공되는 경우  
해당 IP 주소에서 CoAP 서버에 연결할 수 있습니다.  
호스트가 등록된 이름인 경우  
해당 이름은 간접 식별자로 간주되고  
끝점은 DNS와 같은 이름 확인 서비스를 사용하여  
해당 호스트의 주소를 찾을 수 있습니다.  
호스트가 비어 있으면 안 됩니다(MUST NOT).  
URI가 누락된 권한 또는 빈 호스트와 함께 수신된 경우  
유효하지 않은 것으로 간주되어야 합니다(MUST).  
포트 하위 구성 요소는 CoAP 서버가 있는 UDP 포트를 나타냅니다.  
비어 있거나 지정되지 않은 경우 기본 포트 5683이 사용됩니다.

- 경로는 호스트 및 포트 범위 내에서 리소스를 식별합니다.  
슬래시 문자(U+002F SOLIDUS "/")로 구분된 일련의 경로 세그먼트로 구성됩니다.

- 쿼리는 리소스를 추가로 매개변수화하는 역할을 합니다.  
앰퍼샌드 문자(U+0026 AMPERSAND "&")로 구분된 일련의 인수로 구성됩니다.  
인수는 종종 "key=value" 쌍의 형태입니다.

- "coap" URI 체계는 호스트의 이름 공간에서  
"잘 알려진 위치"에 대해 [RFC5785]에 정의된 경로 접두사  
"/.well-known/"을 지원합니다.  
이를 통해 호스트 리소스(섹션 7 참조)와 같은  
호스트("사이트 전체 메타데이터")에 대한 정책 또는  
기타 정보를 검색할 수 있습니다.

- 애플리케이션 디자이너는  
짧지만 설명이 포함된 URI를 사용하는 것이 좋습니다.  
CoAP가 사용되는 환경은 일반적으로  
대역폭과 에너지에 대해 제약을 받기 때문에  
이 두 품질 간의 균형은 설명을 무시하지 않고 단축에 치우쳐야 합니다.

### 6.2.  coaps URI Scheme

      coaps-URI = "coaps:" "//" host [ ":" port ] path-abempty
              [ "?" query ]

- "coap" 체계에 대해 위에 나열된 모든 요구 사항은  
또한 "coaps" 체계에 대한 요구 사항입니다.  
단, 포트 하위 구성 요소가 비어 있거나 지정되지 않은 경우  
기본 UDP 포트 5684가 가정되고 UDP 데이터그램은  
다음을 통해 보호되어야 합니다(MUST).  
섹션 9.1에 설명된 대로 DTLS 사용.

- "coaps" 식별 요청에 대한 응답 캐싱에 대한 고려 사항은 11.2절에서 설명합니다.

- "coap" 체계를 통해 사용 가능한 리소스는  
리소스 식별자가 동일한 권한(동일한 호스트가 동일한 UDP 포트를 수신함)을  
나타내더라도 "coap" 체계와 공유 ID가 없습니다.  
이들은 별개의 네임스페이스이며 별개의 원본 서버로 간주됩니다.

### 6.3.  Normalization and Comparison Rules
- "coap" 및 "coaps" 체계는  
URI 일반 구문을 따르므로 이러한 URI는 각 체계에 대해  
위에서 설명한 기본값을 사용하여 [RFC3986],  
6절에 정의된 알고리즘에 따라 정규화되고 비교됩니다.

- 포트가 체계의 기본 포트와 같으면  
일반적인 형식은 포트 하위 구성 요소를 생략하는 것입니다.  
마찬가지로 빈 경로 구성 요소는 "/"의 절대 경로와 동일하므로  
일반 형식은 대신 "/"의 경로를 제공하는 것입니다.  
체계와 호스트는 대소문자를 구분하지 않으며  
일반적으로 소문자로 제공됩니다.  
IP 리터럴은 권장 형식[RFC5952]입니다.  
다른 모든 구성 요소는 대소문자를 구분하여 비교됩니다.  
"reserved" 세트에 있는 문자 이외의 문자는  
백분율로 인코딩된 바이트와 동일합니다([RFC3986], 섹션 2.1 참조).  
일반적인 형식은 인코딩하지 않는 것입니다.

- 예를 들어 다음 세 URI는 동일하며 CoAP 메시지에 동일한 옵션 및 옵션 값이 표시됩니다.

  - coap://example.com:5683/~sensors/temp.xml 
  - coap://EXAMPLE.com/%7Esensors/temp.xml 
  - coap://EXAMPLE.com:/%7esensors/temp.xml

### 6.4.  Decomposing URIs into Options
- 문자열에서 요청 옵션을 구문 분석하는 단계 |url| 다음과 같다.  
이러한 단계를 수행하면 요청에 Uri-Host, Uri-Port, Uri-Path 및  
Uri-Query 옵션이 포함되지 않거나 실패하게 됩니다.

  1. |url| string이 절대 URI([RFC3986])가 아니면 이 알고리즘에 실패합니다.

  2. [RFC3986]에 정의된 참조 확인 프로세스를 통해  
  |url| 문자열을 해석한다.   
  이 단계에서 URL은 ASCII 인코딩[RFC0020]이지만  
  디코딩된 구성 요소는 5, 8, 9단계 후에 UTF-8[RFC3629]로 해석됩니다.

      참고: 이 시점에서 그것이 절대 URL이라는 것을 이미 알고 있기 때문에  
      상대적으로 해결되는 것은 중요하지 않습니다.

  3. |url|에 ASCII 소문자로 변환된 값이 "coap" 또는 "coap"인  
  \<scheme> 구성 요소가 없으면 이 알고리즘에 실패합니다.

  4. |url|에 \<fragment> 구성 요소가 있는 경우 이 알고리즘을 실패합니다.

  5. |url|의 \<host> 구성 요소가  
  요청의 대상 IP 주소를 IP 리터럴 또는 IPv4 주소로 나타내지 않는 경우  
  Uri-Host Option을 포함하고  
  해당 옵션의 값이 |url|의 \<host> 구성 요소 값이 되도록 하고  
  ASCII 소문자로 변환한 다음   
  모든 퍼센트 인코딩("%" 다음에 2개의 16진수)을 해당 문자로 변환합니다.

      참고: 요청의 대상 IP 주소가  
      호스트 부분에서 파생되는 일반적인 경우에는  
      Uri-Host 옵션이 reg-name 형식의  
      \<host> 구성 요소에만 사용됩니다.

  6. |url|에 \<port> 구성 요소가 있으면  
  |port|가 10진수 정수로 해석되는 해당 구성 요소의 값입니다.  
  그렇지 않으면 |port| 구성표의 기본 포트가 됩니다.

  7. |포트|가 요청의 대상 UDP 포트와 같지 않은 경우  
  Uri-Port 옵션을 포함하고 해당 옵션의 값을 |port|로 둡니다.

  8. |url|의 \<path> 구성 요소의 값이 비어 있거나  
  단일 슬래시 문자(U+002F SOLIDUS "/")로 구성된 경우  
  다음 단계로 이동합니다.

      그렇지 않으면 \<path> 구성 요소의 각 세그먼트에 대해  
      Uri-Path Option을 포함하고  
      각 백분율 인코딩("%" 다음에 두 개의 16진수 숫자)을 해당 바이트로 변환한 후  
      해당 옵션의 값을 세그먼트(구분 슬래시 문자 제외)로 설정합니다.  

  9. |url|에 \<query> 구성 요소가 있는 경우  
  \<query> 구성 요소의 각 인수에 대해 Uri-Query Option을 포함하고  
  각 백분율 인코딩을 해당 바이트로 변환한 후 해당 옵션의 값을  
  인수(물음표 및 구분 앰퍼샌드 문자 제외)로 설정합니다.  

- 이러한 규칙은 모든 백분율 인코딩을 완전히 해결합니다.

### 6.5.  Composing URIs from Options
- 요청 옵션에서 URI를 구성하는 단계는 다음과 같습니다.  
이러한 단계는 URI를 생성하거나 실패합니다.  
이 단계에서 문자를 퍼센트 인코딩한다는 것은  
각 (UTF-8 인코딩된) 바이트를 "%" 문자로 바꾸고  
그 뒤에 바이트를 나타내는 두 개의 16진수 숫자가 오는 것을 의미합니다.  
여기서 숫자 A-F는 대문자입니다(섹션 2.1에 정의된 대로).  
[RFC3986]의 가변성을 줄이기 위해  
CoAP URI의 퍼센트 인코딩에 대한 16진수 표기법은  
반드시 대문자를 사용해야 합니다.  
"unreserved" 및 "sub-delims"의 정의는 [RFC3986]에서 채택되었습니다.

  1. 요청이 DTLS를 사용하여 보호되는 경우  
  |url| "coaps://" 문자열이어야 합니다.  
  그렇지 않으면 |url| "coap://" 문자열이어야 합니다.

  2. 요청에 Uri-Host Option이 포함된 경우  
  |host|를 해당 옵션의 값으로 설정합니다.  
  여기서 ASCII가 아닌 문자는 해당하는 백분율 인코딩으로 대체됩니다.  
  |host|가 유효한 등록 이름, IP 리터럴 또는 IPv4 주소가 아니면  
  알고리즘에 실패합니다.  
  요청에 Uri-Host Option이 포함되지 않은 경우  
  |host|를 IP 리터럴([RFC5952] 규칙 사용) 또는  
  요청의 대상 IP 주소를 나타내는 IPv4address로 설정합니다.

  3. |url|에 호스트|를 추가합니다.

  4. 요청에 Uri-Port 옵션이 포함되어 있으면  
  |port|가 해당 옵션의 값이 됩니다.  
  그렇지 않으면 |port|는 요청의 대상 UDP 포트입니다.

  5. |포트|가 이 체계의 기본 포트가 아닌 경우  
  단일 U+003A COLON 문자(:) 다음에  
  |port|의 10진수 표현을 |url|애 추가합니다.

  6. |리소스 이름| 빈 문자열이 됩니다.  
  요청의 각 Uri-Path Option에 대해  
  단일 문자 "U+002F SOLIDUS(/)" 다음에 옵션 값을 |resource name|에 추가합니다.  
  "unreserved" 세트에 없는 문자를 변환한 후  
  "sub-delims" 세트, "U+003A COLON(:)" 문자 또는  
  "U+0040 COMMERCIAL AT(@)" 문자를 백분율로 인코딩된 형식으로 변환합니다.

  7. |리소스 이름|이 빈 문자열이면 단일 문자 U+002F SOLIDUS(/)로 설정합니다.

  8. 요청의 각 Uri-Query 옵션에 대해  
  단일 문자 U+003F QUESTION MARK(?)(첫 번째 옵션) 또는  
  U+0026 AMPERSAND(&)(후속 옵션)를 추가하고  
  옵션 값을 |리소스 이름| 뒤에 추가합니다.  
  "예약되지 않은" 세트, "하위 구분" 세트(U+0026 AMPERSAND(&) 제외),  
  U+003A COLON(:), U+0040 COMMERCIAL AT(@ ),  
  U+002F SOLIDUS(/) 또는 U+003F QUESTION MARK(?) 문자를  
  백분율로 인코딩된 형식으로 변환합니다.

  9. |url|에 |리소스 이름| 추가 .

  10. |url| 반환.

## 7.  Discovery

### 7.1.  Service Discovery
- CoAP 서버가 제공하는 서비스 검색의 일부로  
클라이언트는 서버에서 사용하는 끝점에 대해 알아야 합니다.

- 서버는 서버의 네임스페이스에 있는 리소스를 참조하는 URI를 알고 있거나  
학습하는 클라이언트에 의해 검색됩니다.  
또는 클라이언트는 멀티캐스트 CoAP(섹션 8 참조) 및  
"모든 CoAP 노드" 멀티캐스트 주소를 사용하여 CoAP 서버를 찾을 수 있습니다.

- "coap" 또는 "coaps" URI의 포트 하위 구성 요소가  
CoAP 서버가 있는 UDP 포트를 나타내지 않는 한  
서버는 기본 포트에서 연결할 수 있는 것으로 간주됩니다.

- CoAP 기본 포트 번호 5683은  
리소스 검색(아래 섹션 7.2 참조)을 위한 리소스를 제공하는 서버에서 지원해야 하며  
다른 리소스에 대한 액세스를 제공하기 위해 지원되어야 합니다(SHOULD).  
DTLS 보안 CoAP의 기본 포트 번호 5684는  
리소스 검색 및 다른 리소스에 대한 액세스 제공을 위해  
서버에서 지원할 수 있습니다(MAY).  
또한 다른 끝점은 다른 포트(예: 동적 포트 공간)에서 호스팅될 수 있습니다.

- 구현 참고 사항: 
    
    CoAP 서버가 6LoWPAN 노드에 의해 호스팅되는 경우  
    [RFC4944] 및 [RFC6282]에 정의된  
    61616-61631 압축 UDP 포트 공간의 포트 번호도 지원하면  
    헤더 압축 효율성이 향상됩니다.  
    (단, UDP 포트가 기본 포트와 다르기 때문에  
    기본 포트에 있는 서버와 엔드포인트가 다릅니다.)

### 7.2.  Resource Discovery
- CoAP 끝점에서 제공하는 리소스 검색은  
루프에 사람이 없고 정적 인터페이스가 취약성을 초래하는  
M2M 애플리케이션에서 매우 중요합니다.  
CoRE 환경에서 상호 운용성을 극대화하기 위해  
CoAP 끝점은 완전히 수동 구성이 필요한 경우를 제외하고  
[RFC6690]에 설명된 대로 검색 가능한 리소스의  
CoRE 링크 형식을 지원해야 합니다(SHOULD).  
리소스를 검색 가능하게 만드는 것은 서버에 달려 있습니다(있는 경우).

#### 7.2.1.  'ct' Attribute
- 이 섹션에서는 [RFC6690]과 함께 사용할  
새로운 웹 연결 [RFC5988] 속성을 정의합니다.  
콘텐츠 형식 코드 "ct" 속성은  
이 리소스가 반환하는 콘텐츠 형식에 대한 힌트를 제공합니다.  
이것은 힌트일 뿐이며 실제로 리소스 표현을 요청하여 얻은  
CoAP 응답의 Content-Format Option을 재정의하지 않습니다.  
값은 10진수 ASCII 정수로 된 CoAP 식별자 코드 형식이며  
0-65535(16비트 부호 없는 정수) 범위에 있어야 합니다(MUST).  
예를 들어 "application/xml"은 "ct=41"로 표시됩니다.  
Content-Format 코드 속성이 없으면  
유형에 대해 아무 것도 가정할 수 없습니다.  
Content-Format 코드 속성은 공백으로 구분된  
Content-Format 코드 시퀀스를 포함할 수 있으며  
이는 여러 콘텐츠 형식을 사용할 수 있음을 나타냅니다.  
속성 값의 구문은 [RFC6690]에서와 같이  
"cardinal", "SP" 및 "DQUOTE"가 정의된  
그림 12의 프로덕션 "ct-value"에 요약되어 있습니다.

```
  ct-value = cardinal / DQUOTE cardinal *( 1*SP cardinal ) DQUOTE

                      Figure 12
```


## 8.  Multicast CoAP
- CoAP는 IP 멀티캐스트 그룹에 대한 요청을 지원합니다.  
이것은 유니캐스트 CoAP에 대한 일련의 델타로 정의됩니다.  
CoAP와의 그룹 통신에 대한 보다 일반적인 논의는 [GROUPCOMM]에 있습니다.

- 다른 끝점이 멀티캐스트 서비스 검색을 사용하여  
찾을 수 있기를 원하는 서비스를 제공하는 CoAP 끝점은  
적절한 전체 CoAP 노드 멀티캐스트 주소(12.8절) 중  
하나 이상에 가입하고 기본 CoAP 포트에서 수신 대기합니다.  
엔드포인트는 모든 노드 IPv6 주소를 포함하여(또는 IPv4의 브로드캐스트를 통해)  
다른 멀티캐스트 주소에서 멀티캐스트 요청을 수신할 수 있습니다.  
따라서 엔드포인트는 이러한 메시지를 수신할 준비가 되어 있어야 하지만  
멀티캐스트 서비스 검색이 원하지 않는 경우 이를 무시할 수 있습니다(MAY).

### 8.1.  Messaging Layer
- 멀티캐스트 요청은 CoAP 엔드포인트 대신  
IP 멀티캐스트 주소로 지정되는 CoAP 메시지로 전송되는 것이 특징입니다.  
이러한 멀티캐스트 요청은 확인 불가능해야 합니다(MUST).

- 서버는 가능한 경우  
IPV6_RECVPKTINFO [RFC3542]와 같은 최신 API를 사용하여  
멀티캐스트를 통해 요청이 도착했음을 인식해야 합니다(SHOULD).

- 오류 응답의 파열을 피하기 위해  
서버가 멀티캐스트를 통해 요청이 도착했음을 인지할 때  
확인 불가능 메시지에 대한 응답으로  
재설정 메시지를 반환해서는 안 됩니다(MUST NOT).  
인식하지 못하는 경우 평소와 같이  
확인 불가능 메시지에 대한 응답으로  
재설정 메시지를 반환할 수 있습니다(MAY).  
이러한 재설정 메시지는 보낸 사람의  
유니캐스트 메시지와 동일하게 보이기 때문에  
보낸 사람은 멀티캐스트 메시지를 수신할 수 있는  
유니캐스트 끝점과 함께 이 끝점에서도  
여전히 활성 상태인 메시지 ID를 사용하지 않아야 합니다.

- 글을 쓰는 시점에서 멀티캐스트 메시지는  
DTLS가 아닌 UDP로만 전달할 수 있습니다.  
즉, 이 문서에서 CoAP에 대해 정의된 보안 모드는  
멀티캐스트에 적용할 수 없습니다.

### 8.2.  Request/Response Layer
- 서버가 멀티캐스트를 통해 요청이 도착했음을 알고 있을 때,  
특히 응답할 유용한 것이 없는 경우 
(예: 빈 페이로드 또는 오류 응답만 있는 경우)  
서버는 항상 요청을 무시할 수 있습니다.  
이에 대한 결정은 애플리케이션에 따라 달라질 수 있습니다.  
(예를 들어 [RFC6690]에 설명된 쿼리 필터링에서  
필터가 일치하지 않으면 서버는 멀티캐스트 요청에 응답하지 않아야 합니다.  
더 많은 예는 [GROUPCOMM]에 있습니다.)

- 서버가 멀티캐스트 요청에 응답하기로 결정한 경우  
즉시 응답해서는 안 됩니다.  
대신 응답하려는 기간 동안 지속 시간을 선택해야 합니다.  
이 설명의 목적을 위해 우리는 이 기간을 Leisure라고 부릅니다.  
이 Leisure의 구체적인 가치는 응용 프로그램에 따라 달라질 수 있으며  
아래에 설명된 대로 파생될 수 있습니다(MAY).  
그런 다음 서버는 선택한 Leisure 기간 내에서  
임의의 시점을 선택하여 멀티캐스트 요청에 대한  
유니캐스트 응답을 다시 보내야 합니다(SHOULD).  
동일한 멀티캐스트 주소 구성원을 기반으로  
추가 응답을 보내야 하는 경우  
이전 기간이 끝난 후 가장 빠른 새 여가 기간이 시작됩니다.

- Leisure에 대한 값을 계산하려면  
서버에 그룹 크기 추정값 G,  
목표 데이터 전송 속도 R(둘 다 신중하게 선택해야 함) 및  
예상 응답 크기 S가 있어야 합니다.  
Leisure에 대한 대략적인 하한은 다음과 같이 계산할 수 있습니다.
```
                    lb_Leisure = S * G / R
```

- 예를 들어, 2.4GHz IEEE 802.15.4(6LoWPAN) 네트워크에서  
링크 로컬 범위가 있는 멀티캐스트 요청의 경우  
G는 (상대적으로 보수적으로) 100으로, S는 100바이트로,  
목표 속도는 8kbit/s = 1kB/s로 설정할 수 있습니다.  
Leisure에 대한 결과 하한은 10초입니다.

- CoAP 끝점에 레저 값을 계산하는 데 적합한 데이터가 없으면  
DEFAULT_LEISURE에 의존할 수 있습니다(MAY).

- 멀티캐스트 요청에 대한 응답을 일치시킬 때 토큰만 일치해야 합니다.  
응답의 소스 끝점은  
원래 요청의 대상 끝점과 같을 필요가 없으며  
동일하지 않을 것입니다.

- Location-* 옵션과 표현에 포함된 링크를 해석하기 위해  
요청 URI(즉, 응답이 해석되는 기본 URI)는  
원래 요청의 Host 구성 요소에 있는 멀티캐스트 주소를  
실제로 응답하는 끝점의 리터럴 IP 주소로 대체하여 형성됩니다.

#### 8.2.1.  Caching
- 클라이언트가 멀티캐스트 요청을 하면  
항상 멀티캐스트 그룹에 새 요청을 합니다 
(그 동안 가입한 새 그룹 구성원이나  
이전 요청을 받지 못한 구성원이 있을 수 있기 때문).  
수신된 응답으로 캐시를 업데이트할 수 있습니다(MAY).  
그런 다음 요청의 결과로 캐시된  
여전히 신선한 응답과 새 응답을 모두 사용합니다.

- 멀티캐스트 그룹에 대한 GET 요청에 대한 응답으로 수신된 응답은  
관련 유니캐스트 요청 URI에 대한  
후속 요청을 충족하는 데 사용될 수 있습니다(MAY).  
유니캐스트 요청 URI는 요청 URI의 권한 부분을  
응답 메시지의 전송 계층 소스 주소로 대체하여 얻습니다.

- 캐시는 관련 유니캐스트 요청 URI에 대해  
GET 요청을 하여 응답을 재검증할 수 있습니다(MAY).

- 멀티캐스트 그룹에 대한 GET 요청에는  
ETag 옵션이 포함되어서는 안 됩니다(MUST NOT).  
클라이언트가 이미 가지고 있는 응답을 억제하는 메커니즘은  
추가 연구를 위해 남겨둡니다.

#### 8.2.2.  Proxying
- forward-proxy가  
Proxy-Uri 또는 멀티캐스트 주소를 나타내는 Proxy-Scheme에서  
구성된 URI가 포함된 요청을 수신하면  
프록시는 위에서 설명한 응답 집합을 얻고  
모든 응답(cashed-still-fresh 및 new 모두)을 보냅니다.  
원래 클라이언트로 돌아갑니다.

- 이 사양은 이렇게 전달된 응답에서  
유니캐스트 수정 요청 URI(기본 URI)를 나타내는 방법을 제공하지 않습니다.  
멀티캐스트 요청 프록시는 [GROUPCOMM]에서 더 자세히 설명합니다.  
기본 URI 문제를 해결하기 위한 한 가지 제안은  
[CoAP-MISC]의 섹션 3에서 찾을 수 있습니다.

## 9.  Securing CoAP
- 이 섹션에서는 CoAP에 대한 DTLS 바인딩을 정의합니다.

- 프로비저닝 단계에서 CoAP 장치에는  
키 자료 및 액세스 제어 목록을 포함하여  
필요한 보안 정보가 제공됩니다.  
이 사양은 섹션 9.1.3.2.1에서  
RawPublicKey 모드에 대한 프로비저닝을 정의합니다.  
프로비저닝 단계가 끝나면 장치는 주어진 모드에 대해  
다음 정보가 포함된 네 가지 보안 모드 중 하나가 됩니다.  
NoSec 및 RawPublicKey 모드는 이 사양을 구현하는 데 필수입니다.

  - NoSec: 
      
      프로토콜 수준 보안이 없습니다(DTLS 비활성화됨).  
      적절한 경우 하위 계층 보안을 제공하는  
      대체 기술을 사용해야 합니다(SHOULD).  
      IPsec의 사용은 [IPsec-CoAP]에서 논의됩니다.  
      제한된 노드와 함께 사용되는 특정 링크 계층은  
      적절한 키 관리와 함께 적절할 수 있는 링크 계층 보안도 제공합니다.

  - PreSharedKey: 
      
      DTLS가 활성화되고 사전 공유 키 목록[RFC4279]이 있으며  
      각 키에는 섹션 9.1.3.1에 설명된 대로  
      통신에 사용할 수 있는 노드 목록이 포함되어 있습니다.  
      극단적으로 이 CoAP 노드가 통신해야 하는 각 노드에 대해  
      하나의 키가 있을 수 있습니다(1:1 노드/키 비율).  
      반대로 두 개 이상의 엔터티가  
      특정 사전 공유 키를 공유하는 경우  
      이 키는 엔터티가 특정 피어가 아닌  
      해당 그룹의 구성원으로만 인증할 수 있도록 합니다.

  - RawPublicKey: 
      
      DTLS가 활성화되고 장치에 9.1.3.2절에 설명된 대로  
      대역 외 메커니즘[RFC7250]을 사용하여  
      검증된 인증서(원시 공개 키)가 없는 비대칭 키 쌍이 있습니다.  
      또한 장치에는 공개 키에서 계산된 ID와  
      통신할 수 있는 노드의 ID 목록이 있습니다.

  - 인증서: 
      
      DTLS가 활성화되어 있고  
      장치에 X.509 인증서[RFC5280]가 있는  
      비대칭 키 쌍이 있어 주체에 바인딩하고  
      섹션 9.1.3.3에 설명된 대로  
      일부 공통 신뢰 루트에 의해 서명됩니다.  
      또한 장치에는 인증서 유효성 검사에 사용할 수 있는  
      루트 트러스트 앵커 목록이 있습니다.
  
- "NoSec" 모드에서  
시스템은 IP를 통해 일반 UDP를 통해 패킷을 보내고  
"coap" 체계와 CoAP 기본 포트로 표시됩니다.  
시스템은 공격자가 CoAP 노드를 사용하여  
네트워크에서 패킷을 보내거나 받을 수 없도록 함으로써만 보호됩니다.  
이 접근 방식의 추가 합병증에 대해서는 11.5절을 참조하십시오.

- 다른 세 가지 보안 모드는 DTLS를 사용하여 달성되며  
"coap" 체계와 DTLS 보안 CoAP 기본 포트로 표시됩니다.  
그 결과 (보안 모델의 한계 내에서) 인증하고 이 인증을 기반으로  
통신 파트너를 승인하는 데 사용할 수 있는 보안 연결이 생성됩니다.  
CoAP 자체는 인증 또는 권한 부여를 위한 프로토콜 프리미티브를 제공하지 않습니다.  
이것이 필요한 경우 통신 보안(예: IPsec 또는 DTLS) 또는  
개체 보안(페이로드 내)에 의해 제공될 수 있습니다.  
특정 작업에 대한 승인이 필요한 장치에는  
이 두 가지 보안 형식 중 하나가 필요합니다.  
반드시 중개자가 관련된 경우  
통신 보안은 해당 중개자가 신뢰 관계의 일부일 때만 작동합니다.  
CoAP는 클라이언트가 중개자와 함께 가질 수 있는  
다른 수준의 권한 부여를 추가 중개자 또는  
원본 서버에 전달할 수 있는 방법을 제공하지 않습니다.  
따라서 첫 번째 중개자에서 모든 권한 부여를 수행해야 할 수 있습니다.

### 9.1.  DTLS-Secured CoAP
- HTTP가 TCP를 통한 TLS(전송 계층 보안)를 사용하여 보호되는 것처럼  
CoAP는 UDP를 통한 DTLS(Datagram TLS)[RFC6347]를  
사용하여 보호됩니다(그림 13 참조).  
이 섹션에서는 제한된 환경에 적합한  
최소한의 필수 구현 구성과 함께  
DTLS에 대한 CoAP 바인딩을 정의합니다.  
바인딩은 유니캐스트 CoAP에 대한 일련의 델타로 정의됩니다.  
실제로 DTLS는 UDP 전송의 신뢰할 수 없는 특성을  
처리하는 기능이 추가된 TLS입니다.

                      +----------------------+
                      |      Application     |
                      +----------------------+
                      +----------------------+
                      |  Requests/Responses  |
                      |----------------------|  CoAP
                      |       Messages       |
                      +----------------------+
                      +----------------------+
                      |         DTLS         |
                      +----------------------+
                      +----------------------+
                      |          UDP         |
                      +----------------------+

          Figure 13: Abstract Layering of DTLS-Secured CoAP

- 일부 제한된 노드(제한된 플래시 및/또는 RAM) 및  
네트워크(제한된 대역폭 또는 높은 확장성 요구 사항)에서는  
사용 중인 특정 암호 제품군에 따라  
모든 DTLS 모드가 적용되지 않을 수 있습니다.  
일부 DTLS 암호 제품군은 보안 연결을 설정할 때  
필요한 초기 핸드셰이크 오버헤드뿐만 아니라  
상당한 구현 복잡성을 추가할 수 있습니다.  
초기 핸드셰이크가 완료되면  
DTLS는 초기화 벡터/nonce 
(예: TLS_PSK_WITH_AES_128_CCM_8[RFC6655]의 경우 8바이트),  
무결성 검사 값(예: TLS_PSK_WITH_AES_128_CCM_8[RFC6655]의 경우 8바이트) 및  
암호 제품군에 필요한 패딩을 포함하지 않는  
약 13바이트의 제한된 데이터그램당 오버헤드를 추가합니다.  
주어진 DTLS 모드의 사용이  
CoAP 기반 응용 프로그램에 적용 가능한지 여부는  
적용할 수 있는 특정 암호 제품군,  
세션 유지 관리가 응용 프로그램 흐름과 호환되는지 여부,  
제한된 노드 및 추가된 네트워크 오버헤드에서  
충분한 리소스를 사용할 수 있는지 여부를 신중하게 고려해야 합니다.  
(DTLS를 사용하는 일부 모드의 경우  
이 사양은 구현해야 하는 암호 제품군을 식별합니다.  
이는 이러한 암호 제품군이 실제로 적절한 경우  
상호 운용성을 극대화하기 위한 구현 요구 사항입니다.  
응용 프로그램의 특정 보안 정책은 실제 사용할 수 있는 암호 모음 집합입니다.)  
DTLS는 그룹 키잉(멀티캐스트 통신)에 적용할 수 없습니다.  
그러나 향후 그룹 키 관리 프로토콜의 구성 요소가 될 수 있습니다.

#### 9.1.1.  Messaging Layer
- CoAP 클라이언트 역할을 하는 엔드포인트는  
DTLS 클라이언트 역할도 해야 합니다.  
적절한 포트에서 서버에 대한 세션을 시작해야 합니다.  
DTLS 핸드셰이크가 완료되면  
클라이언트는 첫 번째 CoAP 요청을 시작할 수 있습니다.  
모든 CoAP 메시지는 DTLS "애플리케이션 데이터"로 전송되어야 합니다(MUST).

- Acknowledgement 메시지 또는 Reset 메시지를  
Confirmable 메시지와 일치시키거나  
Reset 메시지를 Non-confirmable 메시지와 일치시키기 위해  
다음 규칙이 추가됩니다.  
    
    : DTLS 세션은 동일해야 하고 에포크는 동일해야 합니다(MUST).

- 동일한 DTLS 세션 및 동일한 에포크 내에서 전송되고  
동일한 메시지 ID를 갖는 메시지는 동일합니다.

- 참고: 
    
    Confirmable 메시지가 재전송되면  
    CoAP 메시지 ID가 동일하게 유지되더라도  
    각 시도마다 새로운 DTLS sequence_number가 사용됩니다.  
    따라서 수신자는 섹션 4.5에 설명된 대로  
    중복 제거를 수행해야 합니다.  
    재전송은 에포크에 걸쳐 수행되어서는 안 됩니다(MUST NOT).

- RawPublicKey 및 인증서 모드의 DTLS 연결은  
상호 인증을 사용하여 설정되므로  
양방향으로 향후 메시지 교환을 위해 계속 사용할 수 있습니다.  
장치는 리소스를 복구해야 할 때  
DTLS 연결을 닫을 수 있지만 일반적으로  
가능한 한 오랫동안 연결을 유지해야 합니다.  
모든 CoAP 메시지 교환 후에 DTLS 연결을 닫는 것은 매우 비효율적입니다.

#### 9.1.2.  Request/Response Layer
- 요청에 대한 응답을 일치시키기 위해 다음 규칙이 추가됩니다.  
    
    : DTLS 세션은 동일해야 하고 에포크는 동일해야 합니다(MUST).

- 이는 DTLS 보안 요청에 대한 응답이  
항상 동일한 보안 세션 및 에포크를 사용하여  
DTLS 보안이어야 함을 의미합니다.  
DTLS 요청에 NoSec 응답을 제공하려는 모든 시도는  
단순히 요청과 일치하지 않으므로 거부되어야 합니다 
(관련 없는 NoSec 요청과 일치하지 않는 한).

#### 9.1.3.  Endpoint Identity
- 장치는 [RFC6066] 섹션 3에 정의된 대로  
SNI HostName 필드에서 권한을 나타내기 위해  
SNI(서버 이름 표시)를 지원해야 합니다(SHOULD).  
이는 여러 기관의 가상 서버 역할을 하는 호스트가  
새 DTLS 연결을 수신할 때 DTLS 세션에 사용할 키를 알기 위해 필요합니다.

##### 9.1.3.1.  Pre-Shared Keys
- 새 노드에 연결할 때  
시스템은 도달하려는 노드에 따라 적절한 키를 선택한 다음  
DTLS의 PSK(Pre-Shared Key) 모드를 사용하여 DTLS 세션을 형성합니다.  
이러한 모드의 구현은 [RFC6655]에 지정된 대로  
구현해야 하는 필수 암호 제품군  
TLS_PSK_WITH_AES_128_CCM_8을 지원해야 합니다(MUST).

- 커미셔닝 모델에 따라  
애플리케이션은 PSK ID 힌트를 사용할 수 있도록  
ID 힌트에 대한 애플리케이션 프로필을 정의해야 할 수도 있습니다 
([RFC4279]의 섹션 5.2에 자세히 설명되어 있음).

- [RFC4279] 섹션 7의 보안 고려 사항이 적용됩니다.  
특히 애플리케이션은 PFS(Perfect Forward Secrecy)가  
필요한지 여부를 신중하게 평가하고  
적절한 암호 제품군을 선택해야 합니다([RFC4279]의 섹션 7.1).  
PSK의 엔트로피는 무차별 대입 및  
(PSK가 무작위로 선택되지 않고 사람에 의해 선택되는 경우)  
사전 공격([RFC4279]의 섹션 7.2)을 완화하기에 충분해야 합니다.  
클라이언트 ID의 일반 텍스트 통신은 데이터를 누출하거나  
개인 정보를 손상시킬 수 있습니다([RFC4279]의 섹션 7.3).

##### 9.1.3.2.  Raw Public Key Certificates
- 이 모드에서 장치에는 비대칭 키 쌍이 있지만  
X.509 인증서(원시 공개 키라고 함)가 없습니다.  
예를 들어 비대칭 키 쌍은 제조업체에서 생성하고  
장치에 설치합니다(섹션 11.6 참조).  
장치는 여러 원시 공개 키로 구성될 수 있습니다(MAY).  
원시 공개 키의 유형과 길이는 사용된 암호 제품군에 따라 다릅니다.  
RawPublicKey 모드의 구현은 [RFC7251], [RFC5246] 및 [RFC4492]에  
지정된 대로 구현해야 하는 필수 암호 제품군  
TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8을 지원해야 합니다(MUST).  
사용된 키는 ECDSA를 사용할 수 있어야 합니다.  
곡선 secp256r1은 반드시 지원되어야 합니다[RFC4492].  
이 곡선은 NIST P-256 곡선과 동일합니다.  
해시 알고리즘은 SHA-256입니다.  
구현은 지원되는 타원 곡선 및  
지원되는 포인트 형식 확장[RFC4492]을 사용해야 합니다.  
압축되지 않은 포인트 형식이 지원되어야 합니다.  
[RFC6090]을 구현 방법으로 사용할 수 있습니다.  
이 암호 제품군의 구현과 관련된 몇 가지 지침은  
[W3CXMLSEC]에서 찾을 수 있습니다.  
원시 공개 키를 TLS와 함께 사용하는 메커니즘은  
[RFC7250]에 지정되어 있습니다.

- 구현 참고 사항: 
    
    특히 이것은 그림 14에 나열된  
    확장이 최소한 나열된 값과 함께  
    DTLS 핸드셰이크에 존재한다는 것을 의미합니다.

- 확장자: elliptic_curves 

    유형: elliptic_curves(0x000a)  
    길이: 4  
    타원 곡선 길이: 2  
    타원 곡선(1 곡선)  
    타원 곡선: secp256r1(0x0017)

- 확장자: ec_point_formats  

    유형: ec_point_formats(0x000b)  
    길이: 2  
    EC 포인트 형식 길이: 1  
    타원 곡선 포인트 형식(1)  
    EC 포인트 형식: 비압축(0)

- 확장자: signature_algorithms  

    유형: signature_algorithms(0x000d)  
    길이: 4  
    데이터(4바이트): 00 02 04 03  
    HashAlgorithm: sha256(4)  
    SignatureAlgorithm: ecdsa(3)
                  
            Figure 14: DTLS Extensions Present for
            TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8

###### 9.1.3.2.1.  Provisioning
- RawPublicKey 모드는 M2M 배포에서 쉽게 프로비저닝되도록 설계되었습니다.  
각 장치에는 적절한 비대칭 공개 키 쌍이 설치되어 있다고 가정합니다.  
식별자는 [RFC6920]의 섹션 2에 설명된 대로 공개 키의 끝점에서 계산됩니다.  
RawPublicKey ID 확인을 지원하는 모든 구현은  
최소한 sha-256-120 모드(SHA-256은 120비트로 잘림)를 지원해야 합니다(MUST).  
구현은 더 긴 길이의 식별자도 지원해야 하고  
더 짧은 길이를 지원할 수도 있습니다(MAY).  
길이가 짧을수록 공격에 대한 보안이 낮으므로 사용을 권장하지 않습니다.

- 식별자를 확인하는 시스템에 식별자를 부여하는 방법에 따라  
URI, 바이너리 및/또는 사람이 말할 수 있는 형식[RFC6920]에 대한  
지원을 구현해야 합니다.  
모든 구현은 바이너리 모드를 지원해야 하고  
사용자 인터페이스가 있는 구현은  
사람이 말할 수 있는 형식도 지원해야 합니다(SHOULD).

- 프로비저닝하는 동안 각 노드의 식별자는  
예를 들어 장치 외부의 바코드를 읽거나  
미리 컴파일된 식별자 목록을 획득하여 수집됩니다.  
그런 다음 이러한 식별자는  
해당 엔드포인트(예: M2M 데이터 수집 서버)에 설치됩니다.  
식별자는 엔드포인트를 추가 장치 정보와 연결하고  
액세스 제어를 수행하는 두 가지 목적으로 사용됩니다.  
(초기 및 진행 중인) 프로비저닝 중에  
장치가 DTLS 세션을 시작할 수 있는 식별자의 액세스 제어 목록도  
설치 및 유지 관리해야 합니다(SHOULD).

##### 9.1.3.3.  X.509 Certificates
- 인증서 모드의 구현은  
[RFC7251], [RFC5246] 및 [RFC4492]에 지정된 대로  
구현해야 하는 필수 암호 제품군  
TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8을 지원해야 합니다(MUST).  
즉, 인증서에는 namedCurves secp256r1[RFC5480]과 함께  
id-ecPublicKey의 알고리즘을 나타내는 SubjectPublicKeyInfo가 포함됩니다.  
공개 키 형식이 압축되지 않음 [RFC5480]; 해시 알고리즘은 SHA-256입니다.  
포함된 경우 키 사용 확장은 digitalSignature를 나타냅니다.  
인증서는 secp256r1을 사용하여 ECDSA로 서명해야 하며  
서명은 SHA-256을 사용해야 합니다(MUST).  
사용된 키는 ECDSA를 사용할 수 있어야 합니다.  
곡선 secp256r1은 반드시 지원되어야 합니다[RFC4492].  
이 곡선은 NIST P-256 곡선과 동일합니다.  
해시 알고리즘은 SHA-256입니다.  
구현은 지원되는 타원 곡선 및  
지원되는 포인트 형식 확장[RFC4492]을 사용해야 합니다.  
압축되지 않은 포인트 형식이 지원되어야 합니다.  
[RFC6090]을 구현 방법으로 사용할 수 있습니다.

- 인증서의 주체는 EUI-64[EUI64]와 같은 장치의 장기 고유 식별자로 구성됩니다.  
제목은 CoAP URI의 호스트 부분으로 사용된  
FQDN(정규화된 도메인 이름)을 기반으로 할 수도 있습니다.  
그러나 장치의 IP 주소는 시간이 지남에 따라 변경되므로  
일반적으로 제목으로 사용해서는 안 됩니다.  
시스템에서 사용되는 검색 프로세스는  
주어진 장치의 IP 주소와 각 장치의 주제 간의 매핑을 구축합니다.  
일부 장치에는 둘 이상의 주체가 있을 수 있으며 하나 이상의 인증서가 필요합니다.

- 새로운 연결이 형성되면 원격 장치의 인증서를 확인해야 합니다.  
CoAP 노드에 절대 시간 소스가 있는 경우  
노드는 인증서의 유효 날짜가 범위 내에 있는지 확인해야 합니다(SHOULD).  
인증서는 [RFC5280]의 6절에 지정된 알고리즘과 동일한 기능을 사용하여  
보안 요구 사항에 적절하게 검증되어야 합니다(MUST).  
인증서에 SubjectAltName이 포함된 경우  
요청 URI의 권한은 SubjectAltName 집합의  
URI 유형 필드에서 발견된 CoAP URI의 권한 중  
적어도 하나와 일치해야 합니다(MUST).  
인증서에 SubjectAltName이 없는 경우 요청 URI의 권한은  
와일드카드가 있는 인증서가 허용되지 않는다는 점을 제외하고  
[RFC3280]에 정의된 일치 규칙을 사용하여  
인증서에서 찾은 일반 이름(CN)과 일치해야 합니다.

- 인증서 상태 확인을 위한 Core 지원은 추가 연구가 필요합니다.  
OCSP(Online Certificate Status Protocol)[RFC6960]를  
CoAP에 매핑하는 것이 현재 정의되어 있지 않고  
OCSP가 모든 환경에서 쉽게 적용되지 않을 수도 있으므로  
대체 접근 방식은 TLS 인증서 상태 요청 확장([ RFC6066],  
"OCSP 스테이플링"이라고도 함) 또는  
가능한 경우 다중 인증서 상태 확장([RFC6961])을 사용하는 것이 좋습니다.

- 시스템에 인증서 외에 공유 키가 있는 경우  
TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA [RFC5489]와 같은  
공유 키를 포함하는 암호 제품군을 사용해야 합니다(SHOULD).

## 10.  Cross-Protocol Proxying between CoAP and HTTP
- CoAP는 HTTP 기능의 제한된 하위 집합을 지원하므로  
HTTP에 대한 프로토콜 간 프록시가 간단합니다.  
CoAP와 HTTP 사이에 프록시를 사용하는 데는  
여러 가지 이유가 있을 수 있습니다.  
마찬가지로 CoAP는 XMPP[RFC6120] 또는  
SIP[RFC3264]와 같은 다른 프로토콜에 동등하게 프록시될 수 있습니다.  
이러한 메커니즘의 정의는 이 사양의 범위를 벗어납니다.

- 정방향 프록시를 통해 리소스에 액세스하는 방법에는 두 가지가 있습니다.

  - CoAP-HTTP 프록시: 
      
      CoAP 클라이언트가 중개자를 통해  
      HTTP 서버의 리소스에 액세스할 수 있도록 합니다.  
      이것은 CoAP-HTTP 프록시에 대한 CoAP 요청에  
      "http" 또는 "https" URI가 있는 Proxy-Uri 또는  
      Proxy-Scheme Option을 포함하여 시작됩니다.

  - HTTP-CoAP 프록시: 
      
      HTTP 클라이언트가 중개자를 통해  
      CoAP 서버의 리소스에 액세스할 수 있도록 합니다.  
      이것은 HTTP-CoAP 프록시에 대한 HTTP 요청의 Request-Line에  
      "coap" 또는 "coaps" URI를 지정하여 시작됩니다.

- 어느 쪽이든 CoAP의 요청/응답 모델만 HTTP에 매핑됩니다.  
Confirmable 또는 Non-confirmable 메시지 등의 기본 모델은  
보이지 않으며 프록시 기능에 영향을 미치지 않아야 합니다(MUST).  
다음 섹션에서는 정방향 프록시에 대한 요청 처리에 대해 설명합니다.  
프록시 기능은 마치 원본 서버인 것처럼 작동하는 프록시를 사용하여  
클라이언트에 투명하기 때문에 역방향 프록시는 지정되지 않습니다.  
그러나 유사한 고려 사항이  
정방향 프록시와 마찬가지로 역방향 프록시에 적용되며  
일반적으로 역방향 프록시가 전달자 프록시와 유사한 방식으로  
작동할 것으로 예상됩니다.  
구현 참고 사항으로, HTTP 클라이언트 라이브러리는  
HTTP 요청 라인에 CoAP URI를 배치하는 방법을 제공하지 않아  
HTTP-CoAP 정방향 프록시를 작동하기 어렵게 만들 수 있습니다.  
따라서 역 프록시는 프록시의 더 넓은 적용 가능성으로 이어질 수 있습니다.  
HTTP-CoAP 역방향 프록시 [MAPPING]를 작동하는 URI에 대한 규칙은  
별도의 사양에서 정의할 수 있습니다.

### 10.1.  CoAP-HTTP Proxying
- 요청에 'http' 또는 'https' URI[RFC2616]가 있는  
Proxy-Uri 또는 Proxy-Scheme Option이 포함된 경우  
수신 CoAP 엔드포인트(이후 "프록시"라고 함)는  
요청에 지정된 작업을 수행하도록 요청됩니다.  
지정된 HTTP 리소스에 대한 메서드를 호출하고  
그 결과를 클라이언트에 반환합니다.  
(보안 요구 사항을 포함하여 프록시에 대한 요청이 공식화되는 방법에 대해서는  
섹션 5.7도 참조하십시오.)

- 이 섹션에서는 모든 CoAP 요청에 대해  
프록시가 클라이언트에 반환해야 하는 CoAP 응답을 지정합니다.  
프록시가 실제로 요청을 충족시키는 방법은 구현 세부 사항이지만,  
일반적인 경우는 프록시가 요청을 변환하여  
HTTP 원본 서버로 전달하는 것으로 예상됩니다.

- HTTP와 CoAP는 기본 요청 방법 집합을 공유하므로  
HTTP 리소스에서 CoAP 요청을 수행하는 것은  
CoAP 리소스에서 수행하는 것과 크게 다르지 않습니다.  
HTTP 리소스에서 수행되는 개별 CoAP 방법의 의미는  
이 섹션의 하위 섹션에 설명되어 있습니다.

- 프록시가 HTTP URI로 요청을 처리할 수 없거나  
서비스할 의사가 없으면  
5.05(프록시가 지원되지 않음) 응답이 클라이언트에 반환됩니다.  
프록시가 제3자(예: HTTP 원본 서버)와 상호 작용하여 요청을 처리하고  
합리적인 시간 프레임 내에 결과를 얻을 수 없는 경우  
5.04(게이트웨이 시간 초과) 응답이 반환됩니다.  
결과를 얻을 수 있지만 이해할 수 없는 경우  
5.02(잘못된 게이트웨이) 응답이 반환됩니다.


#### 10.1.1.  GET
- GET 메서드는  
요청 URI로 식별되는 HTTP 리소스의 표현을 반환하도록 프록시를 요청합니다.

- 성공하면 2.05(콘텐츠) 응답 코드가 반환되어야 합니다(SHOULD).  
응답의 페이로드는 대상 HTTP 리소스의 표현이어야 하고  
그에 따라 Content-Format Option을 설정해야 합니다(MUST).  
응답은 표현이 새로운 것으로 간주될 수 있는  
남은 시간보다 크지 않은 Max-Age 값을 나타내야 합니다(MUST).  
HTTP 엔터티에 엔터티 태그가 있는 경우  
프록시는 응답에 ETag 옵션을 포함하고  
아래 설명된 대로 요청에서 ETag 옵션을 처리해야 합니다(SHOULD).

- 클라이언트는 다음 옵션을 포함하여 GET 요청 처리에 영향을 줄 수 있습니다.
  - 수락: 
      
      요청은 선호하는 응답 콘텐츠 형식을 식별하는  
      수락 옵션을 포함할 수 있습니다(MAY).

  - ETag: 
  
      요청에는 클라이언트가 저장한 응답을 식별하는  
      하나 이상의 ETag 옵션이 포함될 수 있습니다(MAY).  
      이것은 프록시가 요청된 세트의 엔티티 태그와 함께  
      2.05(콘텐츠) 응답을 보낼 때마다  
      2.03(유효) 응답을 보내도록 요청합니다.  
      CoAP ETag는 HTTP 의미에서 항상 강력한 ETag입니다.  
      CoAP에는 HTTP 약한 ETag가 없으며  
      교차 프록시에서 이를 사용할 좋은 방법이 없습니다.

#### 10.1.2.  PUT
- PUT 메서드는 포함된 표현으로  
요청 URI로 식별되는 HTTP 리소스를 업데이트하거나  
생성하도록 프록시에 요청합니다.

- 요청 URI에서 새 리소스가 생성되면  
2.01(Created) 응답이 클라이언트에 반환되어야 합니다(MUST).  
기존 리소스가 수정되면 요청의 성공적인 완료를 나타내기 위해  
2.04(변경됨) 응답이 반환되어야 합니다.

#### 10.1.3.  DELETE
- DELETE 메서드는 HTTP 원본 서버에서  
요청 URI로 식별된 HTTP 리소스를 삭제하도록 프록시에 요청합니다.

- 2.02(삭제됨) 응답은 성공 시 또는 요청 시 리소스가 존재하지 않는 경우  
클라이언트에 반환되어야 합니다.

#### 10.1.4.  POST
- POST 메서드는 요청에 포함된 표현이  
HTTP 원본 서버에서 처리되도록 프록시에 요청합니다.  
POST 메서드에 의해 수행되는 실제 기능은  
원본 서버에 의해 결정되며 요청 URI로 식별되는 리소스에 따라 달라집니다.

- POST 메서드에 의해 수행된 작업으로 인해  
URI로 식별할 수 있는 리소스가 생성되지 않으면  
2.04(변경됨) 응답이 클라이언트에 반환되어야 합니다(MUST).  
원본 서버에서 리소스가 생성된 경우  
2.01(Created) 응답이 반환되어야 합니다.

### 10.2.  HTTP-CoAP Proxying
- HTTP 요청에 "coap" 또는 "coaps" URI가 있는 Request-URI가 포함된 경우  
수신 HTTP 끝점(이후 "프록시"라고 함)은  
표시된 CoAP 리소스에 대한 요청 메서드에  
지정된 작업을 수행하도록 요청되고  
결과를 클라이언트에 반환합니다.

- 이 섹션은 모든 HTTP 요청에 대해  
프록시가 클라이언트에 반환해야 하는 HTTP 응답을 지정합니다.  
달리 지정하지 않는 한 모든 진술은 RECOMMENDED 동작입니다.  
일부 고도로 제한된 구현은 바로 가기에 의존해야 할 수도 있습니다.  
프록시가 실제로 요청을 충족시키는 방법은  
구현 세부 사항이지만 프록시가 요청을 변환하여  
CoAP 원본 서버로 전달하는 것이 일반적인 경우일 것으로 예상됩니다.  
CoAP 리소스에서 수행되는 개별 HTTP 메서드의 의미는  
이 섹션의 하위 섹션에 설명되어 있습니다.

- 프록시가 CoAP URI로 요청을 처리할 수 없거나  
서비스할 의사가 없으면 501(구현되지 않음) 응답이 클라이언트에 반환됩니다.  
프록시가 제3자(CoAP 원본 서버 등)와 상호 작용하여 요청을 처리하고  
합리적인 시간 프레임 내에 결과를 얻을 수 없는 경우  
504(게이트웨이 시간 초과) 응답이 반환됩니다.  
결과를 얻을 수 있지만 이해할 수 없는 경우  
502(잘못된 게이트웨이) 응답이 반환됩니다.

#### 10.2.1.  OPTIONS and TRACE
- OPTIONS 및 TRACE 메서드는  
CoAP에서 지원되지 않으므로  
501(구현되지 않음) 오류가 클라이언트에 반환되어야 합니다(MUST).

#### 10.2.2.  GET
- GET 메서드는 프록시가 Request-URI로 식별된  
CoAP 리소스의 표현을 반환하도록 요청합니다.

- 성공하면 200(OK) 응답이 반환됩니다.  
응답의 페이로드는 대상 CoAP 리소스의 표현이어야 하며,  
그에 따라 Content-Type 및 Content-Encoding 헤더 필드를 설정해야 합니다(MUST).  
응답은 표현이 신선하다고 간주될 수 있는  
남은 시간보다 크지 않은 값을 나타내는 max-age 지시문을 나타내야 합니다(MUST).  
CoAP 응답에 ETag 옵션이 있는 경우  
프록시는 응답에 ETag 헤더 필드를 포함해야 합니다.

- 클라이언트는 다음 옵션을 포함하여 GET 요청 처리에 영향을 줄 수 있습니다.

  - 수락: 
  
      요청에서 HTTP 수락 헤더 필드의 가장 선호되는 미디어 유형이  
      CoAP 수락 옵션에 매핑됩니다.  
      HTTP Accept 미디어 유형 범위,  
      매개변수 및 확장은 CoAP Accept 옵션에서 지원되지 않습니다.  
      프록시가 결합된 Accept 필드 값에 따라  
      수락 가능한 응답을 보낼 수 없는 경우  
      프록시는 406(Not Acceptable) 응답을 보냅니다.  
      그런 다음 프록시는 HTTP Accept 헤더 필드에서  
      추가 미디어 유형으로 요청을 재시도할 수 있습니다.

  - 조건부 GET: 
      
      "If-Match" 또는 "If-None-Match" 요청 헤더 필드를 포함하는  
       조건부 HTTP GET 요청을 해당 CoAP 요청에 매핑할 수 있습니다.  
       "If-Modified-Since" 및 "If-Unmodified-Since" 요청 헤더 필드는  
       CoAP에서 직접 지원되지 않지만 캐싱 프록시에 의해 로컬로 구현됩니다.

#### 10.2.3.  HEAD
- HEAD 방법은 서버가 응답에서  
메시지 본문을 반환하지 않아야 한다는 점을 제외하고는 GET과 동일합니다.

- CoAP에 HTTP의 HEAD 방식과 직접적으로 동등한 것은 없지만  
HTTP-CoAP 프록시는 CoAP 리소스에 대한 HEAD 요청에 응답하고  
HTTP 헤더는 메시지 본문 없이 반환됩니다.

- 구현 참고 사항: 

    HTTP-CoAP 프록시는  
    실제로 전송되는 데이터의 양을 최소화하기 위해  
    블록 단위 전송 옵션 [BLOCK]을 사용하려고 할 수 있지만  
    원본 서버가 블록 단위전송을 지원하지 않는 경우에 대비해야 합니다.

#### 10.2.4.  POST
- POST 메서드는 요청에 포함된 표현이  
CoAP 원본 서버에서 처리되도록 프록시에 요청합니다.  
POST 메서드에 의해 수행되는 실제 기능은  
원본 서버에 의해 결정되며 요청 URI로 식별되는 리소스에 따라 달라집니다.

- POST 메서드에 의해 수행된 작업으로 인해  
URI로 식별할 수 있는 리소스가 생성되지 않으면  
200(OK) 또는 204(콘텐츠 없음) 응답이 클라이언트에 반환되어야 합니다(MUST).  
원본 서버에서 리소스가 생성된 경우 201(Created) 응답이 반환되어야 합니다.

- CoAP 응답에 Location-* 옵션이 있는 경우  
이러한 옵션의 값으로 구성된 Location 헤더 필드가 반환됩니다.

#### 10.2.5.  PUT
- PUT 메서드는 포함된 표현으로  
Request-URI에 의해 식별된 CoAP 리소스를  
업데이트하거나 생성하도록 프록시에 요청합니다.

- Request-URI에서 새 리소스가 생성되면  
201(Created) 응답이 클라이언트에 반환됩니다.  
기존 리소스가 수정되면 200(OK) 또는 204(No Content) 응답 코드가 전송되어  
요청이 성공적으로 완료되었음을 나타냅니다.

#### 10.2.6.  DELETE
- DELETE 메소드는 CoAP 원서버에서 Request-URI로 식별된  
CoAP 자원을 삭제하도록 프록시에 요청합니다.

- 응답에 상태를 설명하는 엔터티가 포함된 경우 성공적인 응답은 200(OK)이고,  
조치가 제정되었지만 응답에 엔터티가 포함되지 않은 경우 204(콘텐츠 없음)입니다.

#### 10.2.7.  CONNECT
- TLS에서 DTLS로의 터널링이 아직 지정되지 않았기 때문에  
이 방법은 현재 HTTP-CoAP 프록시 기능으로 만족할 수 없습니다.  
현재로서는 501(구현되지 않음) 오류가 클라이언트에 반환됩니다.

## 11.  Security Considerations
- 이 섹션에서는 프로토콜에 대한 가능한 위협을 분석합니다.  
이 문서에서 설명하는 CoAP의 보안 제한 사항에 대해  
프로토콜 및 응용 프로그램 개발자에게 알리기 위한 것입니다.  
CoAP가 HTTP/1.1 기능의 하위 집합을 실현함에 따라  
[RFC2616] 섹션 15의 보안 고려 사항도 CoAP와 관련이 있습니다.  
이 섹션에서는 CoAP와 관련된 제한 사항을 설명하는 데 집중합니다.

### 11.1.  Parsing the Protocol and Processing URIs
- 네트워크 연결 응용 프로그램은  
수신 패킷에 대한 처리 논리에 취약성을 보일 수 있습니다.  
복잡한 파서는 노드를 원격으로 충돌시키거나  
원격으로 임의의 코드를 실행하는 능력과 같은  
취약점의 가능성 있는 소스로 잘 알려져 있습니다.  
CoAP는 파서 복잡성을 줄이고,  
인코딩 가능한 값의 전체 범위에 가능한 한 의미를 부여하고,  
같은 것을 의미하는 여러 표현 사이에서  
불필요한 선택으로 인해 종종 발생하는 복잡성을 적극적으로 줄임으로써  
이러한 취약성을 도입할 기회를 좁히려고 시도합니다.  
URI 처리의 대부분이 클라이언트로 이동되어  
서버에 취약점이 발생할 가능성이 더욱 줄어듭니다.  
그럼에도 불구하고 CoAP 구현의 URI 처리 코드는  
남아 있는 취약점의 큰 원인이 될 수 있으므로  
특별한 주의를 기울여 구현해야 합니다.  
CoAP 액세스 제어 구현은  
URI에서 액세스 제어 결정을 파생하는 코드와  
URI가 지정하는 리소스를 최종적으로 제공하는 코드 간의  
불일치를 통해 취약점을 도입하지 않도록 해야 합니다.  
가장 복잡한 파서는 CoRE 링크 형식에 대한 것이지만  
구현 복잡성을 줄이기 위해 설계되었습니다[RFC6690].  
([RFC2616]의 섹션 15.2도 참조하십시오.)

### 11.2.  Proxying and Caching
- [RFC2616]의 섹션 15.7에서 언급했듯이  
프록시는 본질적으로 중간자이며  
직접 CoAP 메시지 교환이 가질 수 있는 모든 IPsec 또는 DTLS 보호를 깨뜨립니다.  
따라서 CoAP 메시지 교환의 기밀성 또는 무결성을 깨뜨리는 흥미로운 대상입니다.  
[RFC2616]에 언급된 것처럼 가용성을 깨는 흥미로운 대상이기도 합니다.

- 요청/응답 데이터의 기밀성과 무결성에 대한 위협은  
프록시도 캐시하는 곳에서 증폭됩니다.  
CoAP는 민감한 데이터를 더 잘 보호하기 위해  
HTTP/1.1이 제공하는 캐시 억제 Cache-Control 옵션을 정의하지 않습니다.

- 캐싱 구현의 경우  
캐시 항목을 생성한 요청을 만드는 데 적용되는  
액세스 제어 고려 사항도 캐시의 값에 적용해야 합니다.  
이는 여러 보안 도메인을 구현하는  
클라이언트와 여러 클라이언트에 서비스를 제공할 수 있는  
프록시와 관련이 있습니다.  
또한 캐싱 프록시는  
프록시가 처음에 요청 전달을 수행하는 데 필요한 것보다  
전송 보안 속성이 낮은 요청에 캐시된 값을 제공해서는 안 됩니다(MUST NOT).

- "coap" 체계와 달리 "coaps" 식별 요청에 대한 응답은  
결코 "공개"되지 않으므로 캐시가 캐시된 항목으로 이어진 것과 동일한  
액세스 제어 결정을 내릴 수 없는 경우  
공유 캐싱에 재사용해서는 안 됩니다(MUST NOT).  
그러나 메시지가 기본적으로 CoAP에서 캐시 가능한 경우  
개인 캐시에서 재사용할 수 있습니다.

- 마지막으로, 여러 개의 원래 요청자에게  
개별 응답(피기백된 응답과 반대)을 팬아웃하는 프록시는  
추가 증폭을 제공할 수 있습니다(섹션 11.3 참조).

### 11.3.  Risk of Amplification
- CoAP 서버는 일반적으로 응답 패킷으로 요청 패킷에 응답합니다.  
이 응답 패킷은 요청 패킷보다 훨씬 클 수 있습니다.  
공격자는 CoAP 노드를 사용하여  
작은 공격 패킷을 더 큰 공격 패킷으로 전환할 수 있으며,  
이를 증폭이라고 합니다.  
따라서 CoAP 노드가 프로토콜의 증폭 속성을 사용하여  
서비스 거부(DoS) 공격에 연루될 위험이 있습니다.  
공격자는 피해자에게 과부하를 주려고 시도하지만  
생성할 수 있는 트래픽 양이 제한됩니다.  
증폭을 사용하여 더 많은 양의 트래픽을 생성할 수 있습니다.

- 이것은 UDP 프로토콜이  
요청 패킷에 제공된 소스 주소를 확인할 방법을 제공하지 않기 때문에  
NoSec 액세스를 가능하게 하고  
공격자가 액세스할 수 있으며 잠재적인 피해자(예: 일반 인터넷에서)에  
액세스할 수 있는 노드에서 특히 문제입니다.  
공격자는 피해자를 향하는 더 큰 패킷을 생성하기 위해  
적절한 요청 패킷의 소스 주소에 피해자의 IP 주소를 배치하기만 하면 됩니다.

- 완화 요소로 제한된 많은 네트워크는  
소량의 트래픽만 생성할 수 있으므로  
CoAP 노드가 이 공격에 덜 매력적일 수 있습니다.  
그러나 제한된 네트워크의 제한된 용량으로 인해  
네트워크 자체가 증폭 공격의 희생자가 될 수 있습니다.

- 따라서 요청이 인증되지 않은 경우  
응답에 큰 증폭 요소를 제공해서는 안 됩니다(SHOULD NOT).  
CoAP 서버는 CoAP[BLOCK]의 슬라이싱/차단 모드를 사용하고  
비교적 작은 슬라이스에서만 큰 리소스 표현을 제공함으로써  
공격자에게 제공하는 증폭의 양을 줄일 수 있습니다.  
예를 들어, 1000바이트 리소스의 경우 10바이트 요청은  
1016바이트 응답 대신 80바이트 응답(64바이트 블록 포함)을 생성하여  
제공된 증폭을 상당히 줄일 수 있습니다.

- CoAP는 또한 M2M의 중요한 요구 사항인  
요청에서 멀티캐스트 IP 주소 사용을 지원합니다.  
멀티캐스트 CoAP 요청은 특히  
제한된 네트워크에서 우발적이거나 고의적인 DoS 공격의 원인이 될 수 있습니다.  
이 사양은 응답이 반환되는 시기를 제한하여  
멀티캐스트 요청의 증폭 효과를 줄이려고 합니다.  
악의적인 사용 가능성을 제한하기 위해  
CoAP 서버는 암호화 방식으로 또는 잠재적인 소스를 제한하는  
일부 멀티캐스트 경계에 의해  
인증될 수 없는 멀티캐스트 요청을 수락해서는 안 됩니다(SHOULD NOT).  
가능한 경우 CoAP 서버는 멀티캐스트 요청 지원을  
기능이 필요한 특정 리소스로 제한해야 합니다(SHOULD).

- POSIX 스타일 API[IEEE1003.1]를 제공하는 일부 범용 운영 체제에서는  
수신된 패킷이 멀티캐스트 주소로 지정되었는지 여부를  
확인하는 것이 간단하지 않습니다.  
많은 구현이 멀티캐스트 그룹에 가입했는지 여부를 알 수 있지만  
모든 IPv6 노드에서 수신하는 FF0x::1 형식의  
멀티캐스트 주소로 주소 지정된 패킷에 문제가 발생합니다.  
구현 시 IPV6_RECVPKTINFO [RFC3542]와 같은  
최신 API를 사용하여 이러한 결정을 내려야 합니다(SHOULD).

### 11.4.  IP Address Spoofing Attacks
- UDP에서 핸드셰이크가 없기 때문에  
제한된 네트워크(즉, 노드/키 비율이 > 1:1인 NoSec 또는 PreSharedKey 배포)가  
전달하는 메시지를 읽고 쓸 수 있는 악성 엔드포인트는  
단일 공격을 쉽게 공격할 수 있습니다.  
엔드포인트, 엔드포인트 그룹 및 전체 네트워크, 예:

  - Confirmable 메시지 또는 Non-confirmable 메시지에 대한 응답으로  
  Reset 메시지를 스푸핑하여 엔드포인트를 "귀먹은" 상태로 만듭니다. 또는

  - CON 메시지에 대한 응답으로 ACK를 스푸핑하여  
  잠재적으로 CON 메시지 발신자가 재전송하는 것을 방지하고  
  실제 응답을 익사시킵니다. 또는

  - 위조된 페이로드/옵션으로  
  전체 응답을 스푸핑 
  (이는 단일 응답 중단에서 지원 인프라에 대한  
  훨씬 더 대담한 공격 
  (예: 프록시 캐시 중독 또는  
  리소스 디렉토리의 유효성 검사/조회 인터페이스 속임)에 이르기까지  
  다양한 수준의 영향을 미칩니다.  
  일반적으로 글로벌 네트워크 상태를 저장하고  
  CoAP를 메시징 기능으로 사용하여  
  상태 설정 또는 업데이트를 처리하는 모든 구성 요소가  
  잠재적인 대상입니다.) 또는

  - 타겟 노드에 대한 멀티캐스트 요청을 스푸핑(spoofing)하는 단계;  
  이로 인해 네트워크 정체/붕괴,  
  피해자에 대한 DoS 공격 또는 강제 절전 모드 해제가 발생할 수 있습니다. 또는

  - 스푸핑 관찰 메시지 등

- 경로를 벗어난 공격자에 의한 응답 스푸핑은  
요청에서 중요하지 않은 무작위 토큰을 선택하여  
전송 계층 보안 없이도 감지되고 완화될 수 있습니다 (섹션 5.3.1).  
[RFC4086]은 보안을 위한 임의성 요구 사항에 대해 설명합니다.

- 원칙적으로 다른 종류의 스푸핑은  
속임수에서 오는 예기치 않은 Acknowledgement 또는  
Reset 메시지로 인해 Confirmable 메시지 의미 체계가 사용되는 경우에만  
CoAP에 의해 탐지될 수 있습니다.  
그러나 이렇게 하면 사용된 메시지 ID를 추적해야 하므로  
항상 가능한 것은 아니며  
일반적으로 손상이 이미 완료된 후에 탐지가 가능해집니다.  
이러한 종류의 공격은 NoSec 이외의 보안 모드를 사용하여 방지할 수 있습니다.

- 소스 주소 스푸핑이 있든 없든,  
클라이언트는 요청, 오히려 복잡한 요청을 서버에 전송하여  
서버에 과부하를 줄 수 있습니다.  
주소 스푸핑은 이 공격을 역추적하고 차단하는 것을 더 어렵게 만듭니다.  
CON 요청의 비용이 작다는 점을 감안할 때 이 공격은 쉽게 실행할 수 있습니다.  
이 공격에서 사용 가능한 총 에너지가 한정된 제한된 노드는  
계획보다 훨씬 빨리 해당 에너지를 소진할 수 있습니다(배터리 고갈 공격).  
또한 클라이언트가 Confirmable 메시지를 사용하고  
서버가 응답하지 않는 (아마도 스푸핑된) 주소에 대해  
Confirmable 별도의 응답으로 응답하는 경우  
서버는 MAX_TRANSMIT_SPAN이 소진될 때까지 각 응답에 대해  
버퍼 및 재전송 논리를 할당해야 합니다.  
합법적인 트래픽을 처리하기 위한 리소스가 부족할 가능성이 높아집니다.  
후자의 문제는 섹션 4.7에서 논의된 바와 같이  
응답 속도를 제한함으로써 어느 정도 완화될 수 있습니다.  
공격자는 합법적인 클라이언트의 주소를 스푸핑할 수도 있습니다.  
이로 인해 서버가 별도의 응답을 사용하는 경우 NSTART=1 때문에  
해당 클라이언트에 대한 합법적인 응답을 차단할 수 있습니다.  
이러한 모든 공격은 NoSec 이외의 보안 모드를 사용하여 방지할 수 있으므로  
보안 프로토콜에 대한 공격만 남게 됩니다.

### 11.5.  Cross-Protocol Attacks
- CoAP 엔드포인트가 가짜 소스 주소로 패킷을 보내도록 유도하는 기능은  
증폭뿐만 아니라 주어진 주소(IP 주소 및 포트)에서  
UDP 패킷을 수신하는 피해자에 대한 교차 프로토콜 공격에도 사용할 수 있습니다.  
이는 다음과 같이 발생합니다.

  - 공격자는 주어진 주소를 가짜 소스 주소로 사용하여  
  CoAP 엔드포인트에 메시지를 보냅니다.
  - CoAP 끝점은 주어진 소스 주소에 메시지로 응답합니다.
  - 주어진 주소의 피해자는  
  다른 프로토콜의 규칙에 따라 해석하는 UDP 패킷을 받습니다.

- 이것은 공격자가 피해자로 직접 통신하는 것을 방지하지만  
CoAP 끝점(다른 프로토콜에서 유효한 역할을 호스트할 수도 있음)에서  
피해자로의 통신을 허용하는 방화벽 규칙을 우회하는 데 사용될 수 있습니다.

- 또한 CoAP 엔드포인트는  
DNS와 같은 다른 UDP 기반 프로토콜의 엔드포인트를 통해 생성된  
크로스 프로토콜 공격의 희생자가 될 수 있습니다.  
두 경우 모두 끝점의 보안 속성이  
IP 주소 확인에 의존하는 경우 공격이 가능합니다 
(그리고 가짜 IP 주소를 사용하여 외부에서 보낸 직접 공격에 대한 방화벽 차단).  
일반적으로 컨텍스트가 부족하기 때문에  
UDP 기반 프로토콜은 프로토콜 간 공격의 대상이 되기 쉽습니다.

- 마지막으로, 다른 수단으로 전송된 CoAP URI는  
클라이언트가 다른 프로토콜의 끝점으로  
메시지를 보내도록 유도하는 데 사용될 수 있습니다.

- 프로토콜 간 공격에 대한 한 가지 완화 방법은  
수신된 패킷의 구문에 대한 엄격한 검사와  
구문의 충분한 차이를 결합하는 것입니다.  
예를 들어 CoAP 끝점의 검사를 통과하는 DNS 응답을 보내도록  
DNS 서버를 유도하는 것이 어려운 경우에 도움이 될 수 있습니다.  
불행히도 DNS 응답의 처음 2바이트는 공격자가 선택할 수 있고  
CoAP 헤더의 관심 있는 부분에 매핑할 수 있는 ID이며  
다음 2바이트는 CoAP의 메시지 ID로 해석됩니다(즉, 모든 값은 허용).  
DNS 카운트 단어는 (존재하지 않지만 선택적인)  
CoAP 옵션 0의 여러 인스턴스로 해석되거나  
토큰으로 해석될 수 있습니다.  
반향된 쿼리는 최종적으로 CoAP 끝점에  
원하는 효과를 얻기 위해 공격자가 제조할 수 있습니다.  
서버에서 추가한 응답(있는 경우)은 추가된 페이로드로 해석될 수 있습니다.

      0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |                      ID                       | T, TKL, code
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   | Message ID
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |                    QDCOUNT                    | (options 0)
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |                    ANCOUNT                    | (options 0)
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |                    NSCOUNT                    | (options 0)
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
      |                    ARCOUNT                    | (options 0)
      +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

        Figure 15: DNS Header ([RFC1035], Section 4.1.1) vs. CoAP Message

- 일반적으로 프로토콜 쌍에 대해  
프로토콜 중 하나는 공격자가 다른 프로토콜의 메시지처럼 보이는 응답을  
생성할 수 있는 방식으로 매우 잘 설계되었을 수 있습니다.  
실행 가능한 공격의 부재를 확인하거나 증명하는 것이  
아직 공격을 완전히 가능하게 하지는 않지만  
더 창의적인 마음에 의해 더 개발될 수 있는  
예를 생성하는 것보다 훨씬 더 어렵습니다.  
따라서 프로토콜 간 공격은  
엔드포인트가 패킷의 소스 IP 주소를 신뢰하는 것만으로  
공격자가 원하는 작업을 승인하지 않는 경우에만 완전히 완화될 수 있습니다.  
반대로 CoAP 보안을 위해 방화벽에 완전히 의존하는 NoSec 환경은  
CoAP 끝점에서 방화벽을 차단해야 할 뿐만 아니라  
다른 UDP 기반 프로토콜을 사용하여  
CoAP 끝점에 UDP 메시지를 보내도록  
유도될 수 있는 다른 모든 끝점도 차단해야 합니다.

- 위의 고려 사항 외에도  
크로스 프로토콜 공격과 관련하여  
DTLS에 대한 보안 고려 사항이 적용됩니다.  
예를 들어 동일한 DTLS 보안 연결("연결")이  
여러 프로토콜의 데이터를 전송하는 데 사용되는 경우  
DTLS는 더 이상 이러한 프로토콜 간의  
cross프로토콜 간 공격에 대한 보호를 제공하지 않습니다.

### 11.6.  Constrained-Node Considerations
- 제한된 노드의 구현자는  
엔트로피의 좋은 소스가 없는 경우가 많습니다[RFC4086].  
이 경우 노드는 키 생성과 같이  
양호한 엔트로피를 필요로 하는 프로세스에 사용되어서는 안 됩니다(MUST NOT).  
대신 키를 외부에서 생성하고  
제조 또는 시운전 중에 장치에 추가해야 합니다.

- 처리 능력이 낮기 때문에  
제한된 노드는 특히 타이밍 공격에 취약합니다.  
암호화 프리미티브를 구현할 때는 특별한 주의가 필요합니다.

- 많은 수의 제한된 노드가 노출된 환경에 설치되며  
키 자료 복구를 포함하여 변조에 대한 저항이 거의 없습니다.  
할당된 자격 증명의 범위를 정의할 때 이를 고려해야 합니다.  
특히, 노드 그룹에 공유 키를 할당하면  
단일 제약 노드가 전체 그룹을 파괴하기 위한 대상이 될 수 있습니다.

## 12.  IANA Considerations

### 12.1.  CoAP Code Registries
- 이 문서는 "CoRE(Constrained RESTful Environments) 매개변수" 레지스트리 
(이하 "CoRE 매개변수" 레지스트리라고 함) 내  
CoAP 헤더의 코드 필드 값에 대한 두 개의 하위 레지스트리를 정의합니다.

- 두 하위 레지스트리의 값은  
첫 번째와 두 번째 숫자 사이의 마침표로 구분된 3개의 10진수  
c.dd로 표기된 8비트 값입니다.  
첫 번째 숫자 c는 0에서 7 사이이며 코드 클래스를 나타냅니다.  
두 번째 및 세 번째 숫자 dd는 세부 사항에 대해  
00에서 31 사이의 십진수를 나타냅니다.

- 모든 코드 값은 다음 범위에 따라 하위 레지스트리에 의해 할당됩니다.
  - 0.00 
  
      빈 메시지를 나타냅니다(섹션 4.1 참조).

  - 0.01-0.31 
      
      요청을 나타냅니다.   
      이 범위의 값은 "CoAP 방법 코드" 하위 레지스트리에 의해 할당됩니다 
      (섹션 12.1.1 참조).

  - 1.00-1.31 
  
      예약

  - 2.00-5.31 
      
      응답을 나타냅니다.  
      이 범위의 값은 "CoAP 응답 코드" 하위 레지스트리에 의해 할당됩니다 
      (섹션 12.1.2 참조).

  - 6.00-7.31 
  
      예약

#### 12.1.1.  Method Codes
- 하위 레지스트리의 이름은 "CoAP 방법 코드"입니다.

- 하위 레지스트리의 각 항목에는  
0.01-0.31 범위의 방법 코드,  
방법 이름 및 방법 설명서에 대한 참조가 포함되어야 합니다.

- 이 하위 레지스트리의 초기 항목은 다음과 같습니다.

            +------+--------+-----------+
            | Code | Name   | Reference |
            +------+--------+-----------+
            | 0.01 | GET    | [RFC7252] |
            | 0.02 | POST   | [RFC7252] |
            | 0.03 | PUT    | [RFC7252] |
            | 0.04 | DELETE | [RFC7252] |
            +------+--------+-----------+

              Table 5: CoAP Method Codes

- 다른 모든 메소드 코드는 할당되지 않습니다.

- 이 하위 레지스트리에 대한 향후 추가를 위한 IANA 정책은  
[RFC5226]에 설명된 대로 "IETF 검토 또는 IESG 승인"입니다.

- 메서드 코드 문서는 다음 속성을 포함하여  
해당 코드로 요청의 의미를 지정해야 합니다.
  - 성공 사례에서 메서드가 반환하는 응답 코드입니다.
  - 메서드가 멱등성인지, 안전한지 또는 둘 다인지 여부.

#### 12.1.2.  Response Codes
- 하위 레지스트리의 이름은 "CoAP 응답 코드"입니다.

- 하위 레지스트리의 각 항목에는  
2.00-5.31 범위의 응답 코드, 응답 코드에 대한 설명,  
응답 코드 문서에 대한 참조가 포함되어야 합니다.

- 이 하위 레지스트리의 초기 항목은 다음과 같습니다.

      +------+------------------------------+-----------+
      | Code | Description                  | Reference |
      +------+------------------------------+-----------+
      | 2.01 | Created                      | [RFC7252] |
      | 2.02 | Deleted                      | [RFC7252] |
      | 2.03 | Valid                        | [RFC7252] |
      | 2.04 | Changed                      | [RFC7252] |
      | 2.05 | Content                      | [RFC7252] |
      | 4.00 | Bad Request                  | [RFC7252] |
      | 4.01 | Unauthorized                 | [RFC7252] |
      | 4.02 | Bad Option                   | [RFC7252] |
      | 4.03 | Forbidden                    | [RFC7252] |
      | 4.04 | Not Found                    | [RFC7252] |
      | 4.05 | Method Not Allowed           | [RFC7252] |
      | 4.06 | Not Acceptable               | [RFC7252] |
      | 4.12 | Precondition Failed          | [RFC7252] |
      | 4.13 | Request Entity Too Large     | [RFC7252] |
      | 4.15 | Unsupported Content-Format   | [RFC7252] |
      | 5.00 | Internal Server Error        | [RFC7252] |
      | 5.01 | Not Implemented              | [RFC7252] |
      | 5.02 | Bad Gateway                  | [RFC7252] |
      | 5.03 | Service Unavailable          | [RFC7252] |
      | 5.04 | Gateway Timeout              | [RFC7252] |
      | 5.05 | Proxying Not Supported       | [RFC7252] |
      +------+------------------------------+-----------+

                  Table 6: CoAP Response Codes

- 응답 코드 3.00-3.31은 향후 사용을 위해 예약되어 있습니다.  
다른 모든 응답 코드는 할당되지 않습니다.

- 이 하위 레지스트리에 대한 향후 추가를 위한 IANA 정책은  
[RFC5226]에 설명된 대로 "IETF 검토 또는 IESG 승인"입니다.

- 응답 코드의 문서는 다음 속성을 포함하여  
해당 코드로 응답의 의미를 지정해야 합니다.
  - 응답 코드가 적용되는 방법.
  - 페이로드가 필수인지, 선택 사항인지 또는 허용되지 않는지 여부.
  - 페이로드의 의미.  
  예를 들어 2.05(콘텐츠) 응답의 페이로드는 대상 리소스를 나타냅니다.  
  오류 응답의 페이로드는 사람이 읽을 수 있는 진단 페이로드입니다.
  - 페이로드의 형식.  
  예를 들어, 2.05(Content) 응답의 형식은  
  Content-Format Option으로 표시됩니다.  
  오류 응답의 페이로드 형식은 항상 Net-Unicode 텍스트입니다.
  - 신선도 모델에 따라 응답이 캐시 가능한지 여부.
  - 검증 모델에 따라 응답이 검증 가능한지 여부.
  - 응답으로 인해 캐시가 요청 URI에 대해  
  저장된 응답을 최신이 아닌 것으로 표시하는지 여부.

### 12.2.  CoAP Option Numbers Registry
- 이 문서는 "CoRE 매개변수" 레지스트리 내의  
CoAP 옵션에 사용되는 옵션 번호에 대한 하위 레지스트리를 정의합니다.  
하위 레지스트리의 이름은 "CoAP 옵션 번호"입니다.

- 하위 레지스트리의 각 항목에는  
옵션 번호, 옵션 이름 및 옵션 설명서에 대한  
참조가 포함되어야 합니다.

- 이 하위 레지스트리의 초기 항목은 다음과 같습니다.


        +--------+------------------+-----------+
        | Number | Name             | Reference |
        +--------+------------------+-----------+
        |      0 | (Reserved)       | [RFC7252] |
        |      1 | If-Match         | [RFC7252] |
        |      3 | Uri-Host         | [RFC7252] |
        |      4 | ETag             | [RFC7252] |
        |      5 | If-None-Match    | [RFC7252] |
        |      7 | Uri-Port         | [RFC7252] |
        |      8 | Location-Path    | [RFC7252] |
        |     11 | Uri-Path         | [RFC7252] |
        |     12 | Content-Format   | [RFC7252] |
        |     14 | Max-Age          | [RFC7252] |
        |     15 | Uri-Query        | [RFC7252] |
        |     17 | Accept           | [RFC7252] |
        |     20 | Location-Query   | [RFC7252] |
        |     35 | Proxy-Uri        | [RFC7252] |
        |     39 | Proxy-Scheme     | [RFC7252] |
        |     60 | Size1            | [RFC7252] |
        |    128 | (Reserved)       | [RFC7252] |
        |    132 | (Reserved)       | [RFC7252] |
        |    136 | (Reserved)       | [RFC7252] |
        |    140 | (Reserved)       | [RFC7252] |
        +--------+------------------+-----------+

              Table 7: CoAP Option Numbers

- 이 하위 레지스트리에 대한 향후 추가를 위한 IANA 정책은  
다음과 같이 세 가지 계층으로 나뉩니다.  
0..255의 범위는 IETF(IETF 검토 또는 IESG 승인)에서  
정의한 옵션을 위해 예약되어 있습니다.  
256..2047의 범위는 공개 사양(사양 필요)과 함께  
일반적으로 사용되는 옵션을 위해 예약되어 있습니다.  
2048..64999의 범위는 옵션 의미 체계가 올바르게 정의되었는지  
확인하는 데 도움이 되는 지정 전문가 검토를 받는  
개인 또는 공급업체별 옵션을 포함한 다른 모든 옵션에 대한 것입니다.  
65000에서 65535 사이의 옵션 번호는  
실험용으로 예약되어 있습니다.  
어떤 종류의 공급업체별 사용을 위한 것이 아니며  
운영 배포에 사용해서는 안됩니다(MUST NOT).

      +-------------+---------------------------------------+
      |       Range | Registration Procedures               |
      +-------------+---------------------------------------+
      |       0-255 | IETF Review or IESG Approval          |
      |    256-2047 | Specification Required                |
      |  2048-64999 | Expert Review                         |
      | 65000-65535 | Experimental use (no operational use) |
      +-------------+---------------------------------------+

        Table 8: CoAP Option Numbers: Registration Procedures

- 옵션 번호에 대한 문서는  
다음 속성을 포함하여 해당 번호가 있는 옵션의 의미를 지정해야 합니다.
  - 요청에서 옵션의 의미.
  - 응답에서 옵션의 의미.
  - 옵션 번호에 의해 결정된 옵션이 중요 또는 선택인지 여부.
  - 옵션이 Safe-to-Forward인지 여부,  
  그리고 그렇다면 옵션 번호에 의해 결정된  
  캐시 키의 일부인지 여부(섹션 5.4.2 참조).
  - 옵션 값의 형식과 길이.
  - 옵션이 최대 한 번만 발생해야 하는지 또는 여러 번 발생할 수 있는지 여부.
  - 기본값(있는 경우).  
  기본값이 있는 중요한 옵션의 경우  
  기본값이 중요한 옵션을 지원하지 않는 구현에 의한 처리를  
  가능하게 하는 방법에 대한 논의(섹션 5.4.4).

### 12.3.  CoAP Content-Formats Registry
- 인터넷 미디어 유형은  
"application/xml"[RFC2046]과 같은 문자열로 식별됩니다.  
페이로드 형식을 나타내기 위해  
이러한 미디어 유형을 사용하는 오버헤드를 최소화하기 위해  
이 문서는 CoAP에서 사용할 인터넷 미디어 유형의 하위 집합에 대한  
하위 레지스트리를 정의하고 각각의 콘텐츠 코딩과 함께 숫자 식별자를 할당합니다.   
하위 레지스트리의 이름은 "CoRE 매개변수" 레지스트리 내에서  
"CoAP Content-Formats"입니다.

- 하위 레지스트리의 각 항목에는  
IANA에 등록된 미디어 유형, CoAP에서 해당 미디어 유형에 사용할  
0-65535 범위의 숫자 식별자,  
이 식별자와 관련된 콘텐츠 코딩 및 문서에 대한 참조가 포함되어야 합니다.  
해당 미디어 유형의 페이로드가 의미적으로 무엇을 의미하는지 설명합니다.

- CoAP에는 요청 또는 응답과 함께  
콘텐츠 인코딩 정보를 전달하는 별도의 방법이 포함되어 있지 않으므로  
콘텐츠 인코딩도 각 식별자(있는 경우)에 대해 지정됩니다.  
여러 콘텐츠 인코딩이 미디어 유형과 함께 사용되는 경우  
각각에 대해 별도의 콘텐츠 형식 식별자가 등록되어야 합니다.  
유사하게, 수준과 같은 인터넷 미디어 유형과 관련된 다른 매개변수는  
CoAP 콘텐츠 형식 항목에 대해 정의될 수 있습니다.

- 하위 레지스트리의 초기 항목은 다음과 같습니다.

      +--------------------------+----------+----+------------------------+
      | Media type               | Encoding | ID | Reference              |
      +--------------------------+----------+----+------------------------+
      | text/plain;              | -        |  0 | [RFC2046] [RFC3676]    |
      | charset=utf-8            |          |    | [RFC5147]              |
      | application/link-format  | -        | 40 | [RFC6690]              |
      | application/xml          | -        | 41 | [RFC3023]              |
      | application/octet-stream | -        | 42 | [RFC2045] [RFC2046]    |
      | application/exi          | -        | 47 | [REC-exi-20140211]     |
      | application/json         | -        | 50 | [RFC7159]              |
      +--------------------------+----------+----+------------------------+

                          Table 9: CoAP Content-Formats

- 65000에서 65535 사이의 식별자는 실험용으로 예약되어 있습니다.  
어떤 종류의 공급업체별 사용을 위한 것이 아니며  
운영 배포에 사용해서는 안됩니다(MUST NOT).  
256에서 9999 사이의 식별자는 IETF 사양(IETF 검토 또는 IESG 승인)에서  
향후 사용을 위해 예약되어 있습니다.  
다른 모든 식별자는 할당되지 않음입니다.

- 단일 바이트 식별자의 네임스페이스가 너무 작기 때문에  
하위 레지스트리를 포함하는 0-255 범위의 향후 추가에 대한 IANA 정책은  
[RFC5226]에 설명된 대로 "전문가 검토"입니다.  
10000-64999 범위의 추가에 대한 IANA 정책은  
[RFC5226]에 설명된 대로 "선착순"입니다.  
다음 표에 요약되어 있습니다.


          +-------------+---------------------------------------+
          |       Range | Registration Procedures               |
          +-------------+---------------------------------------+
          |       0-255 | Expert Review                         |
          |    256-9999 | IETF Review or IESG Approval          |
          | 10000-64999 | First Come First Served               |
          | 65000-65535 | Experimental use (no operational use) |
          +-------------+---------------------------------------+

          Table 10: CoAP Content-Formats: Registration Procedures

- Machine-to-Machine 응용 프로그램에서  
text/plain, application/xml 또는 application/octet-stream과 같은  
일반적인 인터넷 미디어 유형은  
장기적으로 실제 응용 프로그램에 유용할 것으로 예상되지 않습니다.  
CoAP를 사용하는 M2M 애플리케이션은  
페이로드를 생성하거나 구문 분석하는 방법에 대한  
의미론적 정보를 나타내는 IANA로부터  
새로운 인터넷 미디어 유형을 요청하는 것이 좋습니다.  
예를 들어 XML로 전달되는 Smart Energy 애플리케이션 페이로드는  
application/se+xml 또는 application/se-exi와 같은  
보다 구체적인 유형을 요청할 수 있습니다.

### 12.4.  URI Scheme Registration
- 이 문서에는 URI(Uniform Resource Identifier) 체계  
"coap"의 등록 요청이 포함되어 있습니다.  
등록 요청은 [RFC4395]를 준수합니다.
  - URI scheme name.
      
      coap

  - Status.
      
      Permanent.

  - URI scheme syntax.
      
      Defined in Section 6.1 of [RFC7252].

  - URI scheme semantics.  
    
    "coap" URI 체계는 CoAP(Constrained Application Protocol)를 통해  
    잠재적으로 액세스할 수 있는 리소스를 식별하는 방법을 제공합니다.  
    리소스는 관리 CoAP 서버에 연결하여 찾을 수 있으며  
    서버에 CoAP 요청을 전송하여 운영할 수 있습니다.  
    따라서 이 체계는 "http" URI 체계[RFC2616]와 비교할 수 있습니다.  
    동작에 대한 자세한 내용은 [RFC7252]의 6절을 참조하십시오.

  - Encoding considerations

    체계 인코딩은 [RFC3986]의 URI에 대해 설정된 인코딩 규칙을 따릅니다.  
    즉, 국제화 및 예약된 문자는  
    UTF-8 기반 백분율 인코딩을 사용하여 표현됩니다.

  - Applications/protocols that use this URI scheme name.
      
      이 체계는 CoAP 엔드포인트에서 CoAP 리소스에 액세스하는 데 사용됩니다.

  - Interoperability considerations.
      
      None.

  - Security considerations.
      
      See Section 11.1 of [RFC7252].

  - Contact.
      
      IETF Chair <chair@ietf.org>

  - Author/Change controller.
      
      IESG <iesg@ietf.org>

  - References.
      
      [RFC7252]

### 12.5.  Secure URI Scheme Registration
- 이 문서에는 URI(Uniform Resource Identifier) 체계  
"coaps" 등록 요청이 포함되어 있습니다.  
등록 요청은 [RFC4395]를 준수합니다.

  - URI scheme name.
      
      coaps

  - Status.
      
      Permanent.

  - URI scheme syntax.
      
      Defined in Section 6.2 of [RFC7252].

  - URI scheme semantics.

    "coaps" URI 체계는 전송 보안을 위해  
    DTLS(Datagram Transport Layer Security)를 사용하여  
    CoAP(Constrained Application Protocol)를 통해  
    잠재적으로 액세스할 수 있는 리소스를 식별하는 방법을 제공합니다.  
    리소스는 관리 CoAP 서버에 연결하여 찾을 수 있으며  
    서버에 CoAP 요청을 전송하여 운영할 수 있습니다.  
    따라서 이 체계는 "https" URI 체계[RFC2616]와 비교할 수 있습니다.  
    동작에 대한 자세한 내용은 [RFC7252]의 6절을 참조하십시오.

  - Encoding considerations.

    체계 인코딩은 [RFC3986]의 URI에 대해 설정된 인코딩 규칙을 따릅니다.  
    즉, 국제화 및 예약된 문자는  
    UTF-8 기반 백분율 인코딩을 사용하여 표현됩니다.
    
  - Applications/protocols that use this URI scheme name.
      
      The scheme is used by CoAP endpoints to access CoAP resources
      using DTLS.

  - Interoperability considerations.
      
      None.

  - Security considerations.
      
      See Section 11.1 of [RFC7252].

  - Contact.
      
      IETF Chair <chair@ietf.org>

  - Author/Change controller.
      
      IESG <iesg@ietf.org>

  - References.
      
      [RFC7252]


### 12.6.  Service Name and Port Number Registration
- CoAP의 기능 중 하나는 리소스 검색입니다.  
CoAP 클라이언트는 CoAP 서버가 제공하는 리소스에 대해  
CoAP 서버에 요청할 수 있습니다(섹션 7 참조).  
IP 주소에 대한 지식만으로 자원 탐색을 가능하게 하려면  
자원 탐색을 위한 CoAP 포트를 표준화해야 합니다.

- IANA는 [RFC6335]에 따라 포트 번호 5683과 서비스 이름 "coap"을 할당했습니다.

- 유니캐스트 외에도 CoAP는 멀티캐스트 및 애니캐스트와 함께 사용할 수 있습니다.

  
  - Service Name.
  
      coap

  - Transport Protocol.
  
      udp

  - Assignee.
  
      IESG <iesg@ietf.org>

  - Contact.
  
      IETF Chair <chair@ietf.org>

  - Description.
  
      Constrained Application Protocol (CoAP)

  - Reference.
  
      [RFC7252]

  - Port Number.

      5683

### 12.7.  Secure Service Name and Port Number Registration
- CoAP 리소스 검색은  
DTLS 보안 CoAP "coap" 체계를 사용하여 제공될 수도 있습니다.  
따라서 안전한 자원 탐색을 위한 CoAP 포트의 표준화가 필요하다.

- IANA는 [RFC6335]에 따라 포트 번호 5684와 서비스 이름 "coaps"를 할당했습니다.

- 유니캐스트 외에도 DTLS 보안 CoAP를 애니캐스트와 함께 사용할 수 있습니다.

  - Service Name.

      coaps

  - Transport Protocol.

      udp

  - Assignee.

      IESG <iesg@ietf.org>

  - Contact.

      IETF Chair <chair@ietf.org>

  - Description.

      DTLS-secured CoAP

  - Reference.

      [RFC7252]

  - Port Number.

      5684

### 12.8.  Multicast Address Registration
- 섹션 8, "멀티캐스트 CoAP"는 멀티캐스트 사용을 정의합니다.  
IANA는 CoAP 노드에서 사용할 다음 멀티캐스트 주소를 할당했습니다.

- IPv4 --  

    "IPv4 멀티캐스트 주소 공간 레지스트리"의  
    "모든 CoAP 노드" 주소는 224.0.1.187.  
    주소는 단일 네트워크를 넘어 확장될 수 있는 검색에 사용되므로  
    인터네트워크 제어 블록(224.0.1.x, RFC 5771)에서 가져왔습니다.

- IPv6 -- 

    "가변 범위 멀티캐스트 주소" 공간(RFC 3307)의  
    "IPv6 멀티캐스트 주소 공간 레지스트리"에서  
    "모든 CoAP 노드" 주소 FF0X::FD.  
    관심 있는 CoAP 노드가 수신 대기해야 하는 각 범위에 대해  
    고유한 멀티캐스트 주소가 있습니다.  
    CoAP에는 Link-Local 및 Site-Local 범위만 필요합니다.
  
## 13.  Acknowledgements
- Brian Frank는 이 사양의 초기 버전에 대한 기여자이자 공동 작성자였습니다.

- 수많은 상세한 리뷰와 토론과 함께  
문서의 아이디어와 텍스트에 상당한 기여를 한  
Peter Bigot, Esko Dijk, Cullen Jennings에게 특별한 감사를 전합니다.

- Floris Van den Abeele, Anthony Baire, Ed Beroset, Berta Carballido,  
Angelo P. Castellani, Gilbert Clark, Robert Cragie, Pierre David,  
Esko Dijk, Lisa Dusseault, Mehmet Ersue, Thomas Fossati, Tobias Gondrom,  
Bert Greevenbosch, Tom Herbst에게 감사드립니다.  
, Jeroen Hoebeke, Richard Kelsey, Sye Loong Keoh, Ari Keranen,  
Matthias Kovatsch, Avi Lior, Stephan Lohse, Salvatore Loreto,  
Kerry Lynn, Andrew McGregor, Alexey Melnikov, Guido Moritz,  
Petri Mutka, Colin O'Flynn, Charles Palmer, Adriano Pezzuto,  
Thomas Poetsch, Robert Quattlebaum, Akbar Rahman, Eric Rescorla,  
Dan Romascanu, David Ryan, Peter Saint-Andre, Szymon Sasin,  
Michael Scharf, Dale Seed, 로비 심슨, Peter van der Stok,  
Michael Stuber, Linyi Tian, ​​Gilman Tolle , Matthieu Vial,  
Maciej Wasilak, Fan Xianyou 및 Alper Yegin에게 문서를 형성하는 데  
도움이 되는 의견과 토론을 제공합니다.  
완료 당시 책임 있는 IETF 지역 책임자 Barry Leiba와 IESG 검토자,  
Adrian Farrel, Martin Stiemerling, Pete Resnick, Richard Barnes,  
Sean Turner, Spencer Dawkins, Stephen Farrell 및  
Ted Lemon에게 심층 리뷰 참여에 특별히 감사드립니다.

- 일부 텍스트는 IETF HTTPBIS 작업 그룹의 작업 문서에서 차용했습니다.

## 14.  References

### 14.1.  Normative References

- [RFC0768]  

    Postel, J., "User Datagram Protocol", STD 6, RFC 768, August 1980.

- [RFC2045]  

    Freed, N. and N. Borenstein, "Multipurpose Internet Mail  
    Extensions (MIME) Part One: Format of Internet Message  
    Bodies", RFC 2045, November 1996. 

- [RFC2046]  

    Freed, N. and N. Borenstein, "Multipurpose Internet Mail  
    Extensions (MIME) Part Two: Media Types", RFC 2046,  
    November 1996.

- [RFC2119]  

    Bradner, S., "Key words for use in RFCs to Indicate  
    Requirement Levels", BCP 14, RFC 2119, March 1997.

- [RFC2616]  
    
    Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,  
    Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext  
    Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

- [RFC3023]  

    Murata, M., St. Laurent, S., and D. Kohn, "XML Media  
    Types", RFC 3023, January 2001.

- [RFC3629]  

    Yergeau, F., "UTF-8, a transformation format of ISO  
    10646", STD 63, RFC 3629, November 2003.

- [RFC3676]  

    Gellens, R., "The Text/Plain Format and DelSp Parameters",  
    RFC 3676, February 2004.

- [RFC3986]  

    Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform  
    Resource Identifier (URI): Generic Syntax", STD 66, RFC  
    3986, January 2005.

- [RFC4279]  

    Eronen, P. and H. Tschofenig, "Pre-Shared Key Ciphersuites  
    for Transport Layer Security (TLS)", RFC 4279, December  
    2005.

- [RFC4395]
    
    Hansen, T., Hardie, T., and L. Masinter, "Guidelines and  
    Registration Procedures for New URI Schemes", BCP 35, RFC  
    4395, February 2006.

- [RFC5147]  

    Wilde, E. and M. Duerst, "URI Fragment Identifiers for the  
    text/plain Media Type", RFC 5147, April 2008.

- [RFC5198]  

    Klensin, J. and M. Padlipsky, "Unicode Format for Network  
    Interchange", RFC 5198, March 2008.

- [RFC5226]  

    Narten, T. and H. Alvestrand, "Guidelines for Writing an  
    IANA Considerations Section in RFCs", BCP 26, RFC 5226,  
    May 2008.

- [RFC5234]  

    Crocker, D. and P. Overell, "Augmented BNF for Syntax  
    Specifications: ABNF", STD 68, RFC 5234, January 2008.

- [RFC5246]  

    Dierks, T. and E. Rescorla, "The Transport Layer Security  
    (TLS) Protocol Version 1.2", RFC 5246, August 2008.

- [RFC5280]  

    Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,  
    Housley, R., and W. Polk, "Internet X.509 Public Key  
    Infrastructure Certificate and Certificate Revocation List  
    (CRL) Profile", RFC 5280, May 2008.

- [RFC5480]

    Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,  
    "Elliptic Curve Cryptography Subject Public Key  
    Information", RFC 5480, March 2009. 

- [RFC5785]  

    Nottingham, M. and E. Hammer-Lahav, "Defining Well-Known  
    Uniform Resource Identifiers (URIs)", RFC 5785, April  
    2010.

- [RFC5952]  
    
    Kawamura, S. and M. Kawashima, "A Recommendation for IPv6  
    Address Text Representation", RFC 5952, August 2010.

- [RFC5988]  
    
    Nottingham, M., "Web Linking", RFC 5988, October 2010.

- [RFC6066]  

    Eastlake, D., "Transport Layer Security (TLS) Extensions:  
    Extension Definitions", RFC 6066, January 2011.

- [RFC6347]  

    Rescorla, E. and N. Modadugu, "Datagram Transport Layer  
    Security Version 1.2", RFC 6347, January 2012.

- [RFC6690]  

    Shelby, Z., "Constrained RESTful Environments (CoRE) Link  
    Format", RFC 6690, August 2012.

- [RFC6920]  
    
    Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B.,  
    Keranen, A., and P. Hallam-Baker, "Naming Things with  
    Hashes", RFC 6920, April 2013.

- [RFC7250]  

    Wouters, P., Tschofenig, H., Gilmore, J., Weiler, S., and  
    T. Kivinen, "Using Raw Public Keys in Transport Layer  
    Security (TLS) and Datagram Transport Layer Security  
    (DTLS)", RFC 7250, June 2014.

- [RFC7251]  

    McGrew, D., Bailey, D., Campagna, M., and R. Dugal, "AES-  
    CCM Elliptic Curve Cryptography (ECC) Cipher Suites for  
    Transport Layer Security (TLS)", RFC 7251, June 2014. 

### 14.2.  Informative References

- [BLOCK]    

    Bormann, C. and Z. Shelby, "Blockwise transfers in CoAP",  
    Work in Progress, October 2013.

- [CoAP-MISC]

    Bormann, C. and K. Hartke, "Miscellaneous additions to  
    CoAP", Work in Progress, December 2013.

- [EUI64]    

    IEEE Standards Association, "Guidelines for 64-bit Global  
    Identifier (EUI-64 (TM))", Registration Authority  
    Tutorials, April 2010,  
    <http://standards.ieee.org/regauth/oui/tutorials/EUI64.html>.

- [GROUPCOMM]

    Rahman, A. and E. Dijk, "Group Communication for CoAP",  
    Work in Progress, December 2013.

- [HHGTTG]   

    Adams, D., "The Hitchhiker's Guide to the Galaxy", Pan  
    Books ISBN 3320258648, 1979.

- [IEEE1003.1]

    IEEE and The Open Group, "Portable Operating System  
    Interface (POSIX)", The Open Group Base Specifications  
    Issue 7, IEEE 1003.1, 2013 Edition,  
    <http://pubs.opengroup.org/onlinepubs/9699919799/>.

- [IPsec-CoAP]
    Bormann, C., "Using CoAP with IPsec", Work in Progress,  
    December 2012.

- [MAPPING]  

    Castellani, A., Loreto, S., Rahman, A., Fossati, T., and  
    E. Dijk, "Guidelines for HTTP-CoAP Mapping  
    Implementations", Work in Progress, February 2014.

- [OBSERVE]  

    Hartke, K., "Observing Resources in CoAP", Work in  
    Progress, April 2014.

- [REC-exi-20140211]

    Schneider, J., Kamiya, T., Peintner, D., and R. Kyusakov,  
    "Efficient XML Interchange (EXI) Format 1.0 (Second  
    Edition)", W3C Recommendation REC-exi-20140211, February  
    2014, <http://www.w3.org/TR/2014/REC-exi-20140211/>.

- [REST]     

    Fielding, R., "Architectural Styles and the Design of  
    Network-based Software Architectures", Ph.D. Dissertation,  
    University of California, Irvine, 2000,  
    <http://www.ics.uci.edu/~fielding/pubs/dissertation/  
    fielding_dissertation.pdf>.

- [RFC0020]  

    Cerf, V., "ASCII format for network interchange", RFC 20,  
    October 1969.

- [RFC0791]  

    Postel, J., "Internet Protocol", STD 5, RFC 791, September  
    1981.

- [RFC0792]  

    Postel, J., "Internet Control Message Protocol", STD 5,  
    RFC 792, September 1981.

- [RFC0793]   

    Postel, J., "Transmission Control Protocol", STD 7, RFC  
    793, September 1981.

- [RFC1035]  

    Mockapetris, P., "Domain names - implementation and  
    specification", STD 13, RFC 1035, November 1987.

- [RFC3264]  

    Rosenberg, J. and H. Schulzrinne, "An Offer/Answer Model  
    with Session Description Protocol (SDP)", RFC 3264, June  
    2002.

- [RFC3280]  

    Housley, R., Polk, W., Ford, W., and D. Solo, "Internet  
    X.509 Public Key Infrastructure Certificate and  
    Certificate Revocation List (CRL) Profile", RFC 3280,  
    April 2002.

- [RFC3542]  

    Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei,  
    "Advanced Sockets Application Program Interface (API) for  
    IPv6", RFC 3542, May 2003.

- [RFC3828]  

    Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and  
    G. Fairhurst, "The Lightweight User Datagram Protocol  
    (UDP-Lite)", RFC 3828, July 2004.

- [RFC4086]  

    Eastlake, D., Schiller, J., and S. Crocker, "Randomness  
    Requirements for Security", BCP 106, RFC 4086, June 2005.

- [RFC4443]  

    Conta, A., Deering, S., and M. Gupta, "Internet Control  
    Message Protocol (ICMPv6) for the Internet Protocol  
    Version 6 (IPv6) Specification", RFC 4443, March 2006.

- [RFC4492]  

    Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.  
    Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites  
    for Transport Layer Security (TLS)", RFC 4492, May 2006.

- [RFC4821]  
    Mathis, M. and J. Heffner, "Packetization Layer Path MTU  
    Discovery", RFC 4821, March 2007.

- [RFC4944]  

    Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,  
    "Transmission of IPv6 Packets over IEEE 802.15.4  
    Networks", RFC 4944, September 2007.

- [RFC5405]  

    Eggert, L. and G. Fairhurst, "Unicast UDP Usage Guidelines  
    for Application Designers", BCP 145, RFC 5405, November 2008.

- [RFC5489]  

    Badra, M. and I. Hajjeh, "ECDHE_PSK Cipher Suites for  
    Transport Layer Security (TLS)", RFC 5489, March 2009.

- [RFC6090]  

    McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic  
    Curve Cryptography Algorithms", RFC 6090, February 2011.

- [RFC6120]  

    Saint-Andre, P., "Extensible Messaging and Presence  
    Protocol (XMPP): Core", RFC 6120, March 2011.

- [RFC6282]  

    Hui, J. and P. Thubert, "Compression Format for IPv6  
    Datagrams over IEEE 802.15.4-Based Networks", RFC 6282,  
    September 2011.

- [RFC6335]  

    Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.  
    Cheshire, "Internet Assigned Numbers Authority (IANA)  
    Procedures for the Management of the Service Name and  
    Transport Protocol Port Number Registry", BCP 165, RFC  
    6335, August 2011.

- [RFC6655]  

    McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for  
    Transport Layer Security (TLS)", RFC 6655, July 2012.

- [RFC6936]  

    Fairhurst, G. and M. Westerlund, "Applicability Statement  
    for the Use of IPv6 UDP Datagrams with Zero Checksums",  
    RFC 6936, April 2013.

- [RFC6960]  

    Santesson, S., Myers, M., Ankney, R., Malpani, A.,  
    Galperin, S., and C. Adams, "X.509 Internet Public Key  
    Infrastructure Online Certificate Status Protocol - OCSP",  
    RFC 6960, June 2013.

- [RFC6961]  

    Pettersen, Y., "The Transport Layer Security (TLS)  
    Multiple Certificate Status Request Extension", RFC 6961,  
    June 2013.

- [RFC7159]  

    Bray, T., "The JavaScript Object Notation (JSON) Data  
    Interchange Format", RFC 7159, March 2014.

- [RFC7228]  

    Bormann, C., Ersue, M., and A. Keranen, "Terminology for  
    Constrained-Node Networks", RFC 7228, May 2014.

- [RTO-CONSIDER]

    Allman, M., "Retransmission Timeout Considerations",  
    Work in Progress, May 2012.

- [W3CXMLSEC]
    Wenning, R., "Report of the XML Security PAG", W3C XML  
    Security PAG, October 2012,  
    <http://www.w3.org/2011/xmlsec-pag/pagreport.html>.

## Appendix A.  Examples
- 이 섹션에서는 GET 요청에 대한 메시지 흐름과 함께  
여러 가지 짧은 예를 제공합니다.  
이러한 예는 기본 작업, 재전송이 있는 경우의 작업 및 멀티캐스트를 보여 줍니다.

- 그림 16은 피기백된 응답을 유발하는 기본 GET 요청을 보여줍니다.  
클라이언트는 리소스 coap://server/temperature에 대한  
확인 가능한 GET 요청을 메시지 ID가 0x7d34인 서버로 보냅니다.  
요청에는 하나의 Uri-Path 옵션 
(Delta 0 + 11 = 11, Length 11, Value "temperature")이 포함됩니다.  
토큰은 비어 있습니다. 이 요청은 총 16바이트입니다.  
2.05(콘텐츠) 응답은 확인 요청을 확인하는 확인 메시지에 반환되어  
메시지 ID 0x7d34와 빈 토큰 값을 모두 반영합니다.  
응답에는 "22.3 C"의 페이로드가 포함되며 길이는 11바이트입니다.


      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d34)
          | GET  |   Uri-Path: "temperature"
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d34)
          | 2.05 |    Payload: "22.3 C"
          |      |


      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | 1 | 0 |   0   |     GET=1     |          MID=0x7d34           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  11   |  11   |      "temperature" (11 B) ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | 1 | 2 |   0   |    2.05=69    |          MID=0x7d34           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |1 1 1 1 1 1 1 1|      "22.3 C" (6 B) ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

              Figure 16: Confirmable Request; Piggybacked Response

- 그림 17은 비슷한 예를 보여주지만  
요청과 응답에 비어 있지 않은 토큰(값 0x20)을 포함하여  
크기를 각각 17바이트와 12바이트로 늘립니다.


      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d35)
          | GET  |      Token: 0x20
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d35)
          | 2.05 |      Token: 0x20
          |      |    Payload: "22.3 C"
          |      |


      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | 1 | 0 |   1   |     GET=1     |          MID=0x7d35           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     0x20      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  11   |  11   |      "temperature" (11 B) ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | 1 | 2 |   1   |    2.05=69    |          MID=0x7d35           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     0x20      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |1 1 1 1 1 1 1 1| "22.3 C" (6 B) ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

              Figure 17: Confirmable Request; Piggybacked Response

- 그림 18에서는 확인 가능한 GET 요청이 손실되었습니다.  
ACK_TIMEOUT초 후에 클라이언트는 요청을 다시 전송하여  
이전 예에서와 같이 피기백된 응답을 생성합니다.


      Client    Server
          |      |
          |      |
          +----X |     Header: GET (T=CON, Code=0.01, MID=0x7d36)
          | GET  |      Token: 0x31
          |      |   Uri-Path: "temperature"
      TIMEOUT    |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d36)
          | GET  |      Token: 0x31
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d36)
          | 2.05 |      Token: 0x31
          |      |    Payload: "22.3 C"
          |      |

    Figure 18: Confirmable Request (Retransmitted); Piggybacked Response

- 그림 19에서 서버에서 클라이언트로의 첫 번째 승인 메시지가 손실되었습니다.   
ACK_TIMEOUT초 후에 클라이언트는 요청을 재전송합니다.

      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
          | GET  |      Token: 0x42
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          | X----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
          | 2.05 |      Token: 0x42
          |      |    Payload: "22.3 C"
      TIMEOUT    |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d37)
          | GET  |      Token: 0x42
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=ACK, Code=2.05, MID=0x7d37)
          | 2.05 |      Token: 0x42
          |      |    Payload: "22.3 C"
          |      |

    Figure 19: Confirmable Request; Piggybacked Response (Retransmitted)

- 그림 20에서 서버는 Confirmable 요청을 확인하고  
Confirmable 메시지에서 별도로 2.05(Content) 응답을 보냅니다.  
Acknowledgement 메시지와 Confirmable 응답이  
반드시 전송된 순서대로 도착하는 것은 아닙니다.  
클라이언트는 확인 가능한 응답을 확인합니다.


      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d38)
          | GET  |      Token: 0x53
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          |<- - -+     Header: (T=ACK, Code=0.00, MID=0x7d38)
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7b)
          | 2.05 |      Token: 0x53
          |      |    Payload: "22.3 C"
          |      |
          |      |
          +- - ->|     Header: (T=ACK, Code=0.00, MID=0xad7b)
          |      |

            Figure 20: Confirmable Request; Separate Response

- 그림 21은 Confirmable 요청을 보낸 직후  
클라이언트가 상태를 잃어버리므로(예: 충돌 및 재부팅됨)  
잠시 후에 별도의 응답이 예기치 않게 도착하는 예를 보여 줍니다.  
이 경우 클라이언트는 Reset 메시지와 함께 Confirmable 응답을 거부합니다.  
예기치 않은 ACK는 자동으로 무시됩니다.


      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=CON, Code=0.01, MID=0x7d39)
          | GET  |      Token: 0x64
          |      |   Uri-Path: "temperature"
        CRASH    |
          |      |
          |<- - -+     Header: (T=ACK, Code=0.00, MID=0x7d39)
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=CON, Code=2.05, MID=0xad7c)
          | 2.05 |      Token: 0x64
          |      |    Payload: "22.3 C"
          |      |
          |      |
          +- - ->|     Header: (T=RST, Code=0.00, MID=0xad7c)
          |      |

          Figure 21: Confirmable Request; Separate Response (Unexpected)

- 그림 22는 요청과 응답이 확인 불가능하므로  
둘 다 예고 없이 손실될 수 있는 기본 GET 요청을 보여줍니다.

      Client    Server
          |      |
          |      |
          +----->|     Header: GET (T=NON, Code=0.01, MID=0x7d40)
          | GET  |      Token: 0x75
          |      |   Uri-Path: "temperature"
          |      |
          |      |
          |<-----+     Header: 2.05 Content (T=NON, Code=2.05, MID=0xad7d)
          | 2.05 |      Token: 0x75
          |      |    Payload: "22.3 C"
          |      |

      Figure 22: Non-confirmable Request; Non-confirmable Response

- 그림 23에서 클라이언트는 Non-confirmable한 GET 요청을  
링크 로컬 범위의 모든 노드인 멀티캐스트 주소로 보냅니다.  
링크에는 A, B, C의 3개의 서버가 있습니다.  
서버 A와 B에는 일치하는 리소스가 있으므로  
Non-confirmable 2.05(콘텐츠) 응답을 다시 보냅니다.  
B가 보낸 응답이 손실됩니다.  
C에는 일치하는 응답이 없으므로  
Non-confirmable 4.04(찾을 수 없음) 응답을 보냅니다.

      Client   ff02::1  A  B  C
          |       |     |  |  |
          |       |     |  |  |
          +------>|     |  |  |  Header: GET (T=NON, Code=0.01, MID=0x7d41)
          |  GET  |     |  |  |   Token: 0x86
          |             |  |  |   Uri-Path: "temperature"
          |             |  |  |
          |             |  |  |
          |<------------+  |  |  Header: 2.05 (T=NON, Code=2.05, MID=0x60b1)
          |      2.05   |  |  |   Token: 0x86
          |             |  |  |   Payload: "22.3 C"
          |             |  |  |
          |             |  |  |
          |   X------------+  |  Header: 2.05 (T=NON, Code=2.05, MID=0x01a0)
          |      2.05   |  |  |   Token: 0x86
          |             |  |  |   Payload: "20.9 C"
          |             |  |  |
          |             |  |  |
          |<------------------+  Header: 4.04 (T=NON, Code=4.04, MID=0x952a)
          |      4.04   |  |  |   Token: 0x86
          |             |  |  |

          Figure 23: Non-confirmable Request (Multicast);  
                     Non-confirmable Response

## Appendix B.  Examples
- 다음 예는 다양한 Uri 옵션 세트와  
이 옵션에서 URI를 구성한 후의 결과를 보여줍니다.  
옵션 외에도 섹션 6.5는 대상 IP 주소 및 포트를 참조하지만  
알고리즘의 모든 경로가 대상 IP 주소 및 포트를 URI에 포함하는 것은 아닙니다.

  - Input:

      Destination IP Address = [2001:db8::2:1]  
      Destination UDP Port = 5683

    - Output:

        coap://[2001:db8::2:1]/

  - Input:

      Destination IP Address = [2001:db8::2:1]  
      Destination UDP Port = 5683  
      Uri-Host = "example.net"

    - Output:

        coap://example.net/

  -  Input:

      Destination IP Address = [2001:db8::2:1]  
      Destination UDP Port = 5683  
      Uri-Host = "example.net"  
      Uri-Path = ".well-known"  
      Uri-Path = "core"

      - Output:

        coap://example.net/.well-known/core

  -  Input:

      Destination IP Address = [2001:db8::2:1]  
      Destination UDP Port = 5683  
      Uri-Host = "xn--18j4d.example"  
      Uri-Path = the string composed of the Unicode characters U+3053  
      U+3093 U+306b U+3061 U+306f, usually represented in UTF-8 as  
      E38193E38293E381ABE381A1E381AF hexadecimal

      - Output:

        coap://xn--18j4d.example/  
        %E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF  
        (The line break has been inserted for readability;  
        it is not part of the URI.)

  -  Input:

      Destination IP Address = 198.51.100.1  
      Destination UDP Port = 61616  
      Uri-Path = ""  
      Uri-Path = "/"  
      Uri-Path = ""  
      Uri-Path = ""  
      Uri-Query = "//"  
      Uri-Query = "?&"  

        - Output:

            coap://198.51.100.1:61616//%2F//?%2F%2F&?%26  


